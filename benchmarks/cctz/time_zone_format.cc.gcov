        -:    0:Source:src/time_zone_format.cc
        -:    0:Graph:/home/yfy/iut/benchmarks/cctz/time_zone_format.gcno
        -:    0:Data:/home/yfy/iut/benchmarks/cctz/time_zone_format.gcda
        -:    0:Runs:3
        -:    0:Programs:1
        -:    1:// Copyright 2016 Google Inc. All Rights Reserved.
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://   http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9://   Unless required by applicable law or agreed to in writing, software
        -:   10://   distributed under the License is distributed on an "AS IS" BASIS,
        -:   11://   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12://   See the License for the specific language governing permissions and
        -:   13://   limitations under the License.
        -:   14:
        -:   15:#if !defined(HAS_STRPTIME)
        -:   16:# if !defined(_WIN32) && !defined(_WIN64)
        -:   17:#  define HAS_STRPTIME 1  // assume everyone has strptime() except windows
        -:   18:# endif
        -:   19:#endif
        -:   20:
        -:   21:#include "time_zone.h"
        -:   22:#include "time_zone_if.h"
        -:   23:
        -:   24:#include <cctype>
        -:   25:#include <chrono>
        -:   26:#include <cstdint>
        -:   27:#include <cstring>
        -:   28:#include <ctime>
        -:   29:#include <limits>
        -:   30:#include <vector>
        -:   31:#if !HAS_STRPTIME
        -:   32:#include <iomanip>
        -:   33:#include <sstream>
        -:   34:#endif
        -:   35:
        -:   36:namespace cctz {
        -:   37:namespace detail {
        -:   38:
        -:   39:namespace {
        -:   40:
        -:   41:#if !HAS_STRPTIME
        -:   42:// Build a strptime() using C++11's std::get_time().
        -:   43:char* strptime(const char* s, const char* fmt, std::tm* tm) {
        -:   44:  std::istringstream input(s);
        -:   45:  input >> std::get_time(tm, fmt);
        -:   46:  if (input.fail()) return nullptr;
        -:   47:  return const_cast<char*>(s) + input.tellg();
        -:   48:}
        -:   49:#endif
        -:   50:
function _ZN4cctz6detail12_GLOBAL__N_14ToTMERKNS_9time_zone15absolute_lookupE called 14 returned 100% blocks executed 60%
       14:   51:std::tm ToTM(const time_zone::absolute_lookup& al) {
       14:   52:  std::tm tm{};
       14:   53:  tm.tm_sec = al.cs.second();
       14:   54:  tm.tm_min = al.cs.minute();
       14:   55:  tm.tm_hour = al.cs.hour();
       14:   56:  tm.tm_mday = al.cs.day();
       14:   57:  tm.tm_mon = al.cs.month() - 1;
        -:   58:
        -:   59:  // Saturate tm.tm_year is cases of over/underflow.
       14:   60:  if (al.cs.year() < std::numeric_limits<int>::min() + 1900) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   61:    tm.tm_year = std::numeric_limits<int>::min();
        -:   62:  } else if (al.cs.year() - 1900 > std::numeric_limits<int>::max()) {
        -:   63:    tm.tm_year = std::numeric_limits<int>::max();
        -:   64:  } else {
       14:   65:    tm.tm_year = static_cast<int>(al.cs.year() - 1900);
        -:   66:  }
        -:   67:
       14:   68:  switch (get_weekday(civil_day(al.cs))) {
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 100%
branch  6 taken 0%
branch  7 taken 0%
        -:   69:    case weekday::sunday:
        -:   70:      tm.tm_wday = 0;
        -:   71:      break;
        -:   72:    case weekday::monday:
    #####:   73:      tm.tm_wday = 1;
    #####:   74:      break;
        -:   75:    case weekday::tuesday:
    #####:   76:      tm.tm_wday = 2;
    #####:   77:      break;
        -:   78:    case weekday::wednesday:
    #####:   79:      tm.tm_wday = 3;
    #####:   80:      break;
        -:   81:    case weekday::thursday:
    #####:   82:      tm.tm_wday = 4;
    #####:   83:      break;
        -:   84:    case weekday::friday:
       14:   85:      tm.tm_wday = 5;
       14:   86:      break;
        -:   87:    case weekday::saturday:
    #####:   88:      tm.tm_wday = 6;
    #####:   89:      break;
        -:   90:  }
       14:   91:  tm.tm_yday = get_yearday(civil_day(al.cs)) - 1;
call    0 returned 100%
       14:   92:  tm.tm_isdst = al.is_dst ? 1 : 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       14:   93:  return tm;
        -:   94:}
        -:   95:
        -:   96:const char kDigits[] = "0123456789";
        -:   97:
        -:   98:// Formats a 64-bit integer in the given field width.  Note that it is up
        -:   99:// to the caller of Format64() [and Format02d()/FormatOffset()] to ensure
        -:  100:// that there is sufficient space before ep to hold the conversion.
function _ZN4cctz6detail12_GLOBAL__N_18Format64EPcil called 14 returned 100% blocks executed 53%
       14:  101:char* Format64(char* ep, int width, int64_t v) {
        -:  102:  bool neg = false;
       14:  103:  if (v < 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  104:    --width;
        -:  105:    neg = true;
    #####:  106:    if (v == INT64_MIN) {
branch  0 never executed
branch  1 never executed
        -:  107:      // Avoid negating INT64_MIN.
    #####:  108:      int last_digit = -(v % 10);
    #####:  109:      v /= 10;
    #####:  110:      if (last_digit < 0) {
branch  0 never executed
branch  1 never executed
    #####:  111:        ++v;
    #####:  112:        last_digit += 10;
        -:  113:      }
    #####:  114:      --width;
    #####:  115:      *--ep = kDigits[last_digit];
        -:  116:    }
    #####:  117:    v = -v;
        -:  118:  }
       14:  119:  do {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       14:  120:    --width;
       14:  121:    *--ep = kDigits[v % 10];
        -:  122:  } while (v /= 10);
      112:  123:  while (--width >= 0) *--ep = '0';  // zero pad
branch  0 taken 89%
branch  1 taken 11% (fallthrough)
       14:  124:  if (neg) *--ep = '-';
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       14:  125:  return ep;
        -:  126:}
        -:  127:
        -:  128:// Formats [0 .. 99] as %02d.
function _ZN4cctz6detail12_GLOBAL__N_19Format02dEPci called 28 returned 100% blocks executed 100%
       28:  129:char* Format02d(char* ep, int v) {
       28:  130:  *--ep = kDigits[v % 10];
       28:  131:  *--ep = kDigits[(v / 10) % 10];
       28:  132:  return ep;
        -:  133:}
        -:  134:
        -:  135:// Formats a UTC offset, like +00:00.
function _ZN4cctz6detail12_GLOBAL__N_112FormatOffsetEPcic called 0 returned 0% blocks executed 0%
    #####:  136:char* FormatOffset(char* ep, int minutes, char sep) {
        -:  137:  char sign = '+';
    #####:  138:  if (minutes < 0) {
branch  0 never executed
branch  1 never executed
    #####:  139:    minutes = -minutes;
        -:  140:    sign = '-';
        -:  141:  }
    #####:  142:  ep = Format02d(ep, minutes % 60);
call    0 never executed
    #####:  143:  if (sep != '\0') *--ep = sep;
branch  0 never executed
branch  1 never executed
    #####:  144:  ep = Format02d(ep, minutes / 60);
call    0 never executed
    #####:  145:  *--ep = sign;
    #####:  146:  return ep;
        -:  147:}
        -:  148:
        -:  149:// Formats a std::tm using strftime(3).
function _ZN4cctz6detail12_GLOBAL__N_18FormatTMEPSsRKSsRK2tm called 0 returned 0% blocks executed 0%
    #####:  150:void FormatTM(std::string* out, const std::string& fmt, const std::tm& tm) {
        -:  151:  // strftime(3) returns the number of characters placed in the output
        -:  152:  // array (which may be 0 characters).  It also returns 0 to indicate
        -:  153:  // an error, like the array wasn't large enough.  To accomodate this,
        -:  154:  // the following code grows the buffer size from 2x the format string
        -:  155:  // length up to 32x.
    #####:  156:  for (int i = 2; i != 32; i *= 2) {
branch  0 never executed
branch  1 never executed
    #####:  157:    size_t buf_size = fmt.size() * i;
    #####:  158:    std::vector<char> buf(buf_size);
call    0 never executed
    #####:  159:    if (size_t len = strftime(&buf[0], buf_size, fmt.c_str(), &tm)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  160:      out->append(&buf[0], len);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  161:      return;
        -:  162:    }
        -:  163:  }
        -:  164:}
        -:  165:
        -:  166:// Used for %E#S/%E#f specifiers and for data values in parse().
        -:  167:template <typename T>
function _ZN4cctz6detail12_GLOBAL__N_18ParseIntIlEEPKcS4_iT_S5_PS5_ called 0 returned 0% blocks executed 0%
function _ZN4cctz6detail12_GLOBAL__N_18ParseIntIiEEPKcS4_iT_S5_PS5_ called 0 returned 0% blocks executed 0%
    #####:  168:const char* ParseInt(const char* dp, int width, T min, T max, T* vp) {
    #####:  169:  if (dp != nullptr) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  170:    const T kmin = std::numeric_limits<T>::min();
        -:  171:    bool erange = false;
        -:  172:    bool neg = false;
        -:  173:    T value = 0;
    #####:  174:    if (*dp == '-') {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  175:      neg = true;
    #####:  176:      if (width <= 0 || --width != 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
    #####:  177:        ++dp;
        -:  178:      } else {
        -:  179:        dp = nullptr;  // width was 1
        -:  180:      }
        -:  181:    }
    #####:  182:    if (const char* const bp = dp) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  183:      while (const char* cp = strchr(kDigits, *dp)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  184:        int d = static_cast<int>(cp - kDigits);
    #####:  185:        if (d >= 10) break;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  186:        if (value < kmin / 10) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  187:          erange = true;
        -:  188:          break;
        -:  189:        }
    #####:  190:        value *= 10;
    #####:  191:        if (value < kmin + d) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  192:          erange = true;
        -:  193:          break;
        -:  194:        }
    #####:  195:        value -= d;
    #####:  196:        dp += 1;
    #####:  197:        if (width > 0 && --width == 0) break;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
        -:  198:      }
    #####:  199:      if (dp != bp && !erange && (neg || value != kmin)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  200:        if (!neg || value != 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  201:          if (!neg) value = -value;  // make positive
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  202:          if (min <= value && value <= max) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  203:            *vp = value;
        -:  204:          } else {
        -:  205:            dp = nullptr;
        -:  206:          }
        -:  207:        } else {
        -:  208:          dp = nullptr;
        -:  209:        }
        -:  210:      } else {
        -:  211:        dp = nullptr;
        -:  212:      }
        -:  213:    }
        -:  214:  }
    #####:  215:  return dp;
        -:  216:}
        -:  217:
        -:  218:// The number of base-10 digits that can be represented by an int64_t.
        -:  219:const int kDigits10_64 = std::numeric_limits<int64_t>::digits10;
        -:  220:
        -:  221:// 10^n for everything that can be represented by an int64_t.
        -:  222:const int64_t kExp10[kDigits10_64 + 1] = {
        -:  223:    1,
        -:  224:    10,
        -:  225:    100,
        -:  226:    1000,
        -:  227:    10000,
        -:  228:    100000,
        -:  229:    1000000,
        -:  230:    10000000,
        -:  231:    100000000,
        -:  232:    1000000000,
        -:  233:    10000000000,
        -:  234:    100000000000,
        -:  235:    1000000000000,
        -:  236:    10000000000000,
        -:  237:    100000000000000,
        -:  238:    1000000000000000,
        -:  239:    10000000000000000,
        -:  240:    100000000000000000,
        -:  241:    1000000000000000000,
        -:  242:};
        -:  243:
        -:  244:}  // namespace
        -:  245:
        -:  246:// Uses strftime(3) to format the given Time.  The following extended format
        -:  247:// specifiers are also supported:
        -:  248://
        -:  249://   - %Ez  - RFC3339-compatible numeric timezone (+hh:mm or -hh:mm)
        -:  250://   - %E#S - Seconds with # digits of fractional precision
        -:  251://   - %E*S - Seconds with full fractional precision (a literal '*')
        -:  252://   - %E4Y - Four-character years (-999 ... -001, 0000, 0001 ... 9999)
        -:  253://
        -:  254:// The standard specifiers from RFC3339_* (%Y, %m, %d, %H, %M, and %S) are
        -:  255:// handled internally for performance reasons.  strftime(3) is slow due to
        -:  256:// a POSIX requirement to respect changes to ${TZ}.
        -:  257://
        -:  258:// The TZ/GNU %s extension is handled internally because strftime() has
        -:  259:// to use mktime() to generate it, and that assumes the local time zone.
        -:  260://
        -:  261:// We also handle the %z and %Z specifiers to accommodate platforms that do
        -:  262:// not support the tm_gmtoff and tm_zone extensions to std::tm.
function _ZN4cctz6detail6formatERKSsRKNSt6chrono10time_pointINS3_3_V212system_clockENS3_8durationIlSt5ratioILl1ELl1EEEEEERKNS7_IlS8_ILl1ELl1000000000EEEERKNS_9time_zoneE called 14 returned 100% blocks executed 35%
       14:  263:std::string format(const std::string& format, const time_point<sys_seconds>& tp,
        -:  264:                   const std::chrono::nanoseconds& ns, const time_zone& tz) {
        -:  265:  std::string result;
       14:  266:  const time_zone::absolute_lookup al = tz.lookup(tp);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       14:  267:  const std::tm tm = ToTM(al);
call    0 returned 100%
        -:  268:
        -:  269:  // Scratch buffer for internal conversions.
        -:  270:  char buf[3 + kDigits10_64];  // enough for longest conversion
        -:  271:  char* const ep = buf + sizeof(buf);
        -:  272:  char* bp;  // works back from ep
        -:  273:
        -:  274:  // Maintain three, disjoint subsequences that span format.
        -:  275:  //   [format.begin() ... pending) : already formatted into result
        -:  276:  //   [pending ... cur) : formatting pending, but no special cases
        -:  277:  //   [cur ... format.end()) : unexamined
        -:  278:  // Initially, everything is in the unexamined part.
        -:  279:  const char* pending = format.c_str();  // NUL terminated
        -:  280:  const char* cur = pending;
       14:  281:  const char* end = pending + format.length();
        -:  282:
       56:  283:  while (cur != end) {  // while something is unexamined
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        -:  284:    // Moves cur to the next percent sign.
        -:  285:    const char* start = cur;
       14:  286:    while (cur != end && *cur != '%') ++cur;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 33%
branch  3 taken 67% (fallthrough)
        -:  287:
        -:  288:    // If the new pending text is all ordinary, copy it out.
       28:  289:    if (cur != start && pending == start) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
       14:  290:      result.append(pending, cur - pending);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       14:  291:      pending = start = cur;
        -:  292:    }
        -:  293:
        -:  294:    // Span the sequential percent signs.
       28:  295:    const char* percent = cur;
       28:  296:    while (cur != end && *cur == '%') ++cur;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 50%
branch  3 taken 50% (fallthrough)
        -:  297:
        -:  298:    // If the new pending text is all percents, copy out one
        -:  299:    // percent for every matched pair, then skip those pairs.
       28:  300:    if (cur != start && pending == start) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       28:  301:      size_t escaped = (cur - pending) / 2;
       28:  302:      result.append(pending, escaped);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       28:  303:      pending += escaped * 2;
        -:  304:      // Also copy out a single trailing percent.
       28:  305:      if (pending != cur && cur == end) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  306:        result.push_back(*pending++);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  307:      }
        -:  308:    }
        -:  309:
        -:  310:    // Loop unless we have an unescaped percent.
       28:  311:    if (cur == end || (cur - percent) % 2 == 0) continue;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  312:
        -:  313:    // Simple specifiers that we handle ourselves.
       56:  314:    if (strchr("YmdeHMSzZs", *cur)) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
       14:  315:      if (cur - 1 != pending) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  316:        FormatTM(&result, std::string(pending, cur - 1), tm);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  317:      }
       14:  318:      switch (*cur) {
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 100%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 0%
        -:  319:        case 'Y':
        -:  320:          // This avoids the tm_year overflow problem for %Y, however
        -:  321:          // tm.tm_year will still be used by other specifiers like %D.
    #####:  322:          bp = Format64(ep, 0, al.cs.year());
call    0 never executed
    #####:  323:          result.append(bp, ep - bp);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  324:          break;
        -:  325:        case 'm':
    #####:  326:          bp = Format02d(ep, al.cs.month());
call    0 never executed
    #####:  327:          result.append(bp, ep - bp);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  328:          break;
        -:  329:        case 'd':
        -:  330:        case 'e':
    #####:  331:          bp = Format02d(ep, al.cs.day());
call    0 never executed
    #####:  332:          if (*cur == 'e' && *bp == '0') *bp = ' ';  // for Windows
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  333:          result.append(bp, ep - bp);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  334:          break;
        -:  335:        case 'H':
    #####:  336:          bp = Format02d(ep, al.cs.hour());
call    0 never executed
    #####:  337:          result.append(bp, ep - bp);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  338:          break;
        -:  339:        case 'M':
       14:  340:          bp = Format02d(ep, al.cs.minute());
call    0 returned 100%
       14:  341:          result.append(bp, ep - bp);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  342:          break;
        -:  343:        case 'S':
    #####:  344:          bp = Format02d(ep, al.cs.second());
call    0 never executed
    #####:  345:          result.append(bp, ep - bp);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  346:          break;
        -:  347:        case 'z':
    #####:  348:          bp = FormatOffset(ep, al.offset / 60, '\0');
call    0 never executed
    #####:  349:          result.append(bp, ep - bp);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  350:          break;
        -:  351:        case 'Z':
    #####:  352:          result.append(al.abbr);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  353:          break;
        -:  354:        case 's':
    #####:  355:          bp = Format64(ep, 0, ToUnixSeconds(tp));
call    0 never executed
    #####:  356:          result.append(bp, ep - bp);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  357:          break;
        -:  358:      }
       14:  359:      pending = ++cur;
       14:  360:      continue;
        -:  361:    }
        -:  362:
        -:  363:    // Loop if there is no E modifier.
       14:  364:    if (*cur != 'E' || ++cur == end) continue;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        -:  365:
        -:  366:    // Format our extensions.
       14:  367:    if (*cur == 'z') {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  368:      // Formats %Ez.
    #####:  369:      if (cur - 2 != pending) {
branch  0 never executed
branch  1 never executed
    #####:  370:        FormatTM(&result, std::string(pending, cur - 2), tm);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  371:      }
    #####:  372:      bp = FormatOffset(ep, al.offset / 60, ':');
call    0 never executed
    #####:  373:      result.append(bp, ep - bp);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  374:      pending = ++cur;
       28:  375:    } else if (*cur == '*' && cur + 1 != end &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
       14:  376:               (*(cur + 1) == 'S' || *(cur + 1) == 'f')) {
        -:  377:      // Formats %E*S or %E*F.
       14:  378:      if (cur - 2 != pending) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  379:        FormatTM(&result, std::string(pending, cur - 2), tm);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  380:      }
        -:  381:      char* cp = ep;
       14:  382:      bp = Format64(cp, 9, ns.count());
call    0 returned 100%
       14:  383:      while (cp != bp && cp[-1] == '0') --cp;
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
       14:  384:      switch (*(cur + 1)) {
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 0%
        -:  385:        case 'S':
       14:  386:          if (cp != bp) *--bp = '.';
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       14:  387:          bp = Format02d(bp, al.cs.second());
call    0 returned 100%
       14:  388:          break;
        -:  389:        case 'f':
    #####:  390:          if (cp == bp) *--bp = '0';
branch  0 never executed
branch  1 never executed
        -:  391:          break;
        -:  392:      }
       14:  393:      result.append(bp, cp - bp);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       14:  394:      pending = cur += 2;
    #####:  395:    } else if (*cur == '4' && cur + 1 != end && *(cur + 1) == 'Y') {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  396:      // Formats %E4Y.
    #####:  397:      if (cur - 2 != pending) {
branch  0 never executed
branch  1 never executed
    #####:  398:        FormatTM(&result, std::string(pending, cur - 2), tm);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  399:      }
    #####:  400:      bp = Format64(ep, 4, al.cs.year());
call    0 never executed
    #####:  401:      result.append(bp, ep - bp);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  402:      pending = cur += 2;
    #####:  403:    } else if (std::isdigit(*cur)) {
branch  0 never executed
branch  1 never executed
        -:  404:      // Possibly found %E#S or %E#f.
    #####:  405:      int n = 0;
    #####:  406:      if (const char* np = ParseInt(cur, 0, 0, 1024, &n)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  407:        if (*np == 'S' || *np == 'f') {
branch  0 never executed
branch  1 never executed
        -:  408:          // Formats %E#S or %E#f.
    #####:  409:          if (cur - 2 != pending) {
branch  0 never executed
branch  1 never executed
    #####:  410:            FormatTM(&result, std::string(pending, cur - 2), tm);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  411:          }
        -:  412:          bp = ep;
    #####:  413:          if (n > 0) {
branch  0 never executed
branch  1 never executed
    #####:  414:            if (n > kDigits10_64) n = kDigits10_64;
branch  0 never executed
branch  1 never executed
    #####:  415:            bp = Format64(bp, n, (n > 9) ? ns.count() * kExp10[n - 9]
    #####:  416:                                         : ns.count() / kExp10[9 - n]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  417:            if (*np == 'S') *--bp = '.';
branch  0 never executed
branch  1 never executed
        -:  418:          }
    #####:  419:          if (*np == 'S') bp = Format02d(bp, al.cs.second());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  420:          result.append(bp, ep - bp);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  421:          pending = cur = ++np;
        -:  422:        }
        -:  423:      }
        -:  424:    }
        -:  425:  }
        -:  426:
        -:  427:  // Formats any remaining data.
       14:  428:  if (end != pending) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  429:    FormatTM(&result, std::string(pending, end), tm);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  430:  }
        -:  431:
       14:  432:  return result;
        -:  433:}
        -:  434:
        -:  435:namespace {
        -:  436:
function _ZN4cctz6detail12_GLOBAL__N_111ParseOffsetEPKccPi called 0 returned 0% blocks executed 0%
    #####:  437:const char* ParseOffset(const char* dp, char sep, int* offset) {
    #####:  438:  if (dp != nullptr) {
branch  0 never executed
branch  1 never executed
    #####:  439:    const char sign = *dp++;
    #####:  440:    if (sign == '+' || sign == '-') {
branch  0 never executed
branch  1 never executed
    #####:  441:      int hours = 0;
    #####:  442:      const char* ap = ParseInt(dp, 2, 0, 23, &hours);
call    0 never executed
    #####:  443:      if (ap != nullptr && ap - dp == 2) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  444:        dp = ap;
    #####:  445:        if (sep != '\0' && *ap == sep) ++ap;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  446:        int minutes = 0;
    #####:  447:        const char* bp = ParseInt(ap, 2, 0, 59, &minutes);
call    0 never executed
    #####:  448:        if (bp != nullptr && bp - ap == 2) dp = bp;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  449:        *offset = (hours * 60 + minutes) * 60;
    #####:  450:        if (sign == '-') *offset = -*offset;
branch  0 never executed
branch  1 never executed
        -:  451:      } else {
        -:  452:        dp = nullptr;
        -:  453:      }
        -:  454:    } else {
        -:  455:      dp = nullptr;
        -:  456:    }
        -:  457:  }
    #####:  458:  return dp;
        -:  459:}
        -:  460:
function _ZN4cctz6detail12_GLOBAL__N_19ParseZoneEPKcPSs called 0 returned 0% blocks executed 0%
    #####:  461:const char* ParseZone(const char* dp, std::string* zone) {
        -:  462:  zone->clear();
    #####:  463:  if (dp != nullptr) {
branch  0 never executed
branch  1 never executed
    #####:  464:    while (*dp != '\0' && !std::isspace(*dp)) zone->push_back(*dp++);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  465:    if (zone->empty()) dp = nullptr;
branch  0 never executed
branch  1 never executed
        -:  466:  }
    #####:  467:  return dp;
        -:  468:}
        -:  469:
function _ZN4cctz6detail12_GLOBAL__N_115ParseSubSecondsEPKcPNSt6chrono8durationIlSt5ratioILl1ELl1000000000EEEE called 0 returned 0% blocks executed 0%
    #####:  470:const char* ParseSubSeconds(const char* dp,
        -:  471:                            std::chrono::nanoseconds* subseconds) {
    #####:  472:  if (dp != nullptr) {
branch  0 never executed
branch  1 never executed
        -:  473:    int64_t v = 0;
        -:  474:    int64_t exp = 0;
        -:  475:    const char* const bp = dp;
    #####:  476:    while (const char* cp = strchr(kDigits, *dp)) {
branch  0 never executed
branch  1 never executed
    #####:  477:      int d = static_cast<int>(cp - kDigits);
    #####:  478:      if (d >= 10) break;
branch  0 never executed
branch  1 never executed
    #####:  479:      if (exp < 9) {
branch  0 never executed
branch  1 never executed
    #####:  480:        exp += 1;
    #####:  481:        v *= 10;
    #####:  482:        v += d;
        -:  483:      }
    #####:  484:      ++dp;
        -:  485:    }
    #####:  486:    if (dp != bp) {
branch  0 never executed
branch  1 never executed
    #####:  487:      v *= kExp10[9 - exp];
    #####:  488:      *subseconds = std::chrono::nanoseconds(v);
        -:  489:    } else {
        -:  490:      dp = nullptr;
    #####:  491:    }
        -:  492:  }
    #####:  493:  return dp;
        -:  494:}
        -:  495:
        -:  496:// Parses a string into a std::tm using strptime(3).
function _ZN4cctz6detail12_GLOBAL__N_17ParseTMEPKcS3_P2tm called 0 returned 0% blocks executed 0%
    #####:  497:const char* ParseTM(const char* dp, const char* fmt, std::tm* tm) {
    #####:  498:  if (dp != nullptr) {
branch  0 never executed
branch  1 never executed
    #####:  499:    dp = strptime(dp, fmt, tm);
call    0 never executed
        -:  500:  }
    #####:  501:  return dp;
        -:  502:}
        -:  503:
        -:  504:}  // namespace
        -:  505:
        -:  506:// Uses strptime(3) to parse the given input.  Supports the same extended
        -:  507:// format specifiers as format(), although %E#S and %E*S are treated
        -:  508:// identically (and similarly for %E#f and %E*f).
        -:  509://
        -:  510:// The standard specifiers from RFC3339_* (%Y, %m, %d, %H, %M, and %S) are
        -:  511:// handled internally so that we can normally avoid strptime() altogether
        -:  512:// (which is particularly helpful when the native implementation is broken).
        -:  513://
        -:  514:// The TZ/GNU %s extension is handled internally because strptime() has to
        -:  515:// use localtime_r() to generate it, and that assumes the local time zone.
        -:  516://
        -:  517:// We also handle the %z specifier to accommodate platforms that do not
        -:  518:// support the tm_gmtoff extension to std::tm.  %Z is parsed but ignored.
function _ZN4cctz6detail5parseERKSsS2_RKNS_9time_zoneEPNSt6chrono10time_pointINS6_3_V212system_clockENS6_8durationIlSt5ratioILl1ELl1EEEEEEPNSA_IlSB_ILl1ELl1000000000EEEE called 0 returned 0% blocks executed 0%
    #####:  519:bool parse(const std::string& format, const std::string& input,
        -:  520:           const time_zone& tz, time_point<sys_seconds>* tpp,
        -:  521:           std::chrono::nanoseconds* ns) {
        -:  522:  // The unparsed input.
        -:  523:  const char* data = input.c_str();  // NUL terminated
        -:  524:
        -:  525:  // Skips leading whitespace.
    #####:  526:  while (std::isspace(*data)) ++data;
branch  0 never executed
branch  1 never executed
        -:  527:
        -:  528:  const int kintmax = std::numeric_limits<int>::max();
        -:  529:  const int kintmin = std::numeric_limits<int>::min();
        -:  530:
        -:  531:  // Sets default values for unspecified fields.
    #####:  532:  std::tm tm{};
    #####:  533:  tm.tm_year = 1970 - 1900;
        -:  534:  tm.tm_mon = 1 - 1;  // Jan
    #####:  535:  tm.tm_mday = 1;
        -:  536:  tm.tm_hour = 0;
        -:  537:  tm.tm_min = 0;
        -:  538:  tm.tm_sec = 0;
    #####:  539:  tm.tm_wday = 4;  // Thu
        -:  540:  tm.tm_yday = 0;
        -:  541:  tm.tm_isdst = 0;
        -:  542:  auto subseconds = std::chrono::nanoseconds(0);
    #####:  543:  int offset = kintmin;
    #####:  544:  std::string zone = "UTC";
call    0 never executed
        -:  545:
        -:  546:  const char* fmt = format.c_str();  // NUL terminated
        -:  547:  bool twelve_hour = false;
        -:  548:  bool afternoon = false;
        -:  549:
        -:  550:  bool saw_percent_s = false;
    #####:  551:  int64_t percent_s_time = 0;
        -:  552:
        -:  553:  // Steps through format, one specifier at a time.
    #####:  554:  while (data != nullptr && *fmt != '\0') {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  555:    if (std::isspace(*fmt)) {
branch  0 never executed
branch  1 never executed
    #####:  556:      while (std::isspace(*data)) ++data;
branch  0 never executed
branch  1 never executed
    #####:  557:      while (std::isspace(*++fmt)) continue;
branch  0 never executed
branch  1 never executed
    #####:  558:      continue;
        -:  559:    }
        -:  560:
    #####:  561:    if (*fmt != '%') {
branch  0 never executed
branch  1 never executed
    #####:  562:      if (*data == *fmt) {
branch  0 never executed
branch  1 never executed
    #####:  563:        ++data;
    #####:  564:        ++fmt;
        -:  565:      } else {
        -:  566:        data = nullptr;
        -:  567:      }
        -:  568:      continue;
        -:  569:    }
        -:  570:
        -:  571:    const char* percent = fmt;
    #####:  572:    if (*++fmt == '\0') {
branch  0 never executed
branch  1 never executed
        -:  573:      data = nullptr;
        -:  574:      continue;
        -:  575:    }
    #####:  576:    switch (*fmt++) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
        -:  577:      case 'Y':
        -:  578:        // We're more liberal than the 4-digit year typically handled by
        -:  579:        // strptime(), but we still need to store the result in an int,
        -:  580:        // and the intermediate value has a 1900 excess.
    #####:  581:        data = ParseInt(data, 0, kintmin + 1900, kintmax, &tm.tm_year);
call    0 never executed
    #####:  582:        if (data != nullptr) tm.tm_year -= 1900;
branch  0 never executed
branch  1 never executed
        -:  583:        continue;
        -:  584:      case 'm':
    #####:  585:        data = ParseInt(data, 2, 1, 12, &tm.tm_mon);
call    0 never executed
    #####:  586:        if (data != nullptr) tm.tm_mon -= 1;
branch  0 never executed
branch  1 never executed
        -:  587:        continue;
        -:  588:      case 'd':
    #####:  589:        data = ParseInt(data, 2, 1, 31, &tm.tm_mday);
call    0 never executed
    #####:  590:        continue;
        -:  591:      case 'H':
    #####:  592:        data = ParseInt(data, 2, 0, 23, &tm.tm_hour);
call    0 never executed
        -:  593:        twelve_hour = false;
    #####:  594:        continue;
        -:  595:      case 'M':
    #####:  596:        data = ParseInt(data, 2, 0, 59, &tm.tm_min);
call    0 never executed
    #####:  597:        continue;
        -:  598:      case 'S':
    #####:  599:        data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
call    0 never executed
    #####:  600:        continue;
        -:  601:      case 'I':
        -:  602:      case 'l':
        -:  603:      case 'r':  // probably uses %I
        -:  604:        twelve_hour = true;
    #####:  605:        break;
        -:  606:      case 'R':  // uses %H
        -:  607:      case 'T':  // uses %H
        -:  608:      case 'c':  // probably uses %H
        -:  609:      case 'X':  // probably uses %H
        -:  610:        twelve_hour = false;
    #####:  611:        break;
        -:  612:      case 'z':
    #####:  613:        data = ParseOffset(data, '\0', &offset);
call    0 never executed
    #####:  614:        continue;
        -:  615:      case 'Z':  // ignored; zone abbreviations are ambiguous
    #####:  616:        data = ParseZone(data, &zone);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  617:        continue;
        -:  618:      case 's':
    #####:  619:        data = ParseInt(data, 0, INT64_MIN, INT64_MAX, &percent_s_time);
call    0 never executed
    #####:  620:        if (data != nullptr) saw_percent_s = true;
branch  0 never executed
branch  1 never executed
        -:  621:        continue;
        -:  622:      case 'E':
    #####:  623:        if (*fmt == 'z') {
branch  0 never executed
branch  1 never executed
    #####:  624:          if (data != nullptr && *data == 'Z') {  // Zulu
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  625:            offset = 0;
    #####:  626:            data += 1;
        -:  627:          } else {
    #####:  628:            data = ParseOffset(data, ':', &offset);
call    0 never executed
        -:  629:          }
    #####:  630:          fmt += 1;
    #####:  631:          continue;
        -:  632:        }
    #####:  633:        if (*fmt == '*' && *(fmt + 1) == 'S') {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  634:          data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
call    0 never executed
    #####:  635:          if (data != NULL && *data == '.') {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  636:            data = ParseSubSeconds(data + 1, &subseconds);
call    0 never executed
        -:  637:          }
    #####:  638:          fmt += 2;
    #####:  639:          continue;
        -:  640:        }
    #####:  641:        if (*fmt == '*' && *(fmt + 1) == 'f') {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  642:          if (data != NULL && std::isdigit(*data)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  643:            data = ParseSubSeconds(data, &subseconds);
call    0 never executed
        -:  644:          }
    #####:  645:          fmt += 2;
    #####:  646:          continue;
        -:  647:        }
    #####:  648:        if (*fmt == '4' && *(fmt + 1) == 'Y') {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  649:          const char* bp = data;
    #####:  650:          data = ParseInt(data, 4, -999, 9999, &tm.tm_year);
call    0 never executed
    #####:  651:          if (data != nullptr) {
branch  0 never executed
branch  1 never executed
    #####:  652:            if (data - bp == 4) {
branch  0 never executed
branch  1 never executed
    #####:  653:              tm.tm_year -= 1900;
        -:  654:            } else {
        -:  655:              data = nullptr;  // stopped too soon
        -:  656:            }
        -:  657:          }
    #####:  658:          fmt += 2;
    #####:  659:          continue;
        -:  660:        }
    #####:  661:        if (std::isdigit(*fmt)) {
branch  0 never executed
branch  1 never executed
    #####:  662:          int n = 0;  // value ignored
    #####:  663:          if (const char* np = ParseInt(fmt, 0, 0, 1024, &n)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  664:            if (*np == 'S') {
branch  0 never executed
branch  1 never executed
    #####:  665:              data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
call    0 never executed
    #####:  666:              if (data != NULL && *data == '.') {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  667:                data = ParseSubSeconds(data + 1, &subseconds);
call    0 never executed
        -:  668:              }
    #####:  669:              fmt = ++np;
    #####:  670:              continue;
        -:  671:            }
    #####:  672:            if (*np == 'f') {
branch  0 never executed
branch  1 never executed
    #####:  673:              if (data != NULL && std::isdigit(*data)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  674:                data = ParseSubSeconds(data, &subseconds);
call    0 never executed
        -:  675:              }
    #####:  676:              fmt = ++np;
    #####:  677:              continue;
        -:  678:            }
        -:  679:          }
        -:  680:        }
    #####:  681:        if (*fmt == 'c') twelve_hour = false;  // probably uses %H
branch  0 never executed
branch  1 never executed
    #####:  682:        if (*fmt == 'X') twelve_hour = false;  // probably uses %H
branch  0 never executed
branch  1 never executed
    #####:  683:        if (*fmt != '\0') ++fmt;
branch  0 never executed
branch  1 never executed
        -:  684:        break;
        -:  685:      case 'O':
    #####:  686:        if (*fmt == 'H') twelve_hour = false;
branch  0 never executed
branch  1 never executed
    #####:  687:        if (*fmt == 'I') twelve_hour = true;
branch  0 never executed
branch  1 never executed
    #####:  688:        if (*fmt != '\0') ++fmt;
branch  0 never executed
branch  1 never executed
        -:  689:        break;
        -:  690:    }
        -:  691:
        -:  692:    // Parses the current specifier.
        -:  693:    const char* orig_data = data;
    #####:  694:    std::string spec(percent, fmt - percent);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  695:    data = ParseTM(data, spec.c_str(), &tm);
call    0 never executed
        -:  696:
        -:  697:    // If we successfully parsed %p we need to remember whether the result
        -:  698:    // was AM or PM so that we can adjust tm_hour before ConvertDateTime().
        -:  699:    // So reparse the input with a known AM hour, and check if it is shifted
        -:  700:    // to a PM hour.
    #####:  701:    if (spec == "%p" && data != nullptr) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  702:      std::string test_input = "1" + std::string(orig_data, data - orig_data);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  703:      const char* test_data = test_input.c_str();
    #####:  704:      std::tm tmp{};
    #####:  705:      ParseTM(test_data, "%I%p", &tmp);
call    0 never executed
    #####:  706:      afternoon = (tmp.tm_hour == 13);
        -:  707:    }
        -:  708:  }
        -:  709:
        -:  710:  // Adjust a 12-hour tm_hour value if it should be in the afternoon.
    #####:  711:  if (twelve_hour && afternoon && tm.tm_hour < 12) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  712:    tm.tm_hour += 12;
        -:  713:  }
        -:  714:
    #####:  715:  if (data == nullptr) return false;
branch  0 never executed
branch  1 never executed
        -:  716:
        -:  717:  // Skip any remaining whitespace.
    #####:  718:  while (std::isspace(*data)) ++data;
branch  0 never executed
branch  1 never executed
        -:  719:
        -:  720:  // parse() must consume the entire input string.
    #####:  721:  if (*data != '\0') return false;
branch  0 never executed
branch  1 never executed
        -:  722:
        -:  723:  // If we saw %s then we ignore anything else and return that time.
    #####:  724:  if (saw_percent_s) {
branch  0 never executed
branch  1 never executed
    #####:  725:    *tpp = FromUnixSeconds(percent_s_time);
    #####:  726:    *ns = std::chrono::nanoseconds::zero();
    #####:  727:    return true;
        -:  728:  }
        -:  729:
        -:  730:  // If we saw %z or %Ez then we want to interpret the parsed fields in
        -:  731:  // UTC and then shift by that offset.  Otherwise we want to interpret
        -:  732:  // the fields directly in the passed time_zone.
    #####:  733:  time_zone ptz = tz;
    #####:  734:  if (offset != kintmin) {
branch  0 never executed
branch  1 never executed
    #####:  735:    ptz = utc_time_zone();  // Override tz.  Offset applied later.
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  736:  } else {
    #####:  737:    offset = 0;  // No offset from passed tz.
        -:  738:  }
        -:  739:
        -:  740:  // Allows a leap second of 60 to normalize forward to the following ":00".
    #####:  741:  if (tm.tm_sec == 60) {
branch  0 never executed
branch  1 never executed
    #####:  742:    tm.tm_sec -= 1;
    #####:  743:    offset -= 1;
    #####:  744:    subseconds = std::chrono::nanoseconds::zero();
        -:  745:  }
        -:  746:
    #####:  747:  int64_t year = tm.tm_year;
    #####:  748:  if (year > INT64_MAX - 1900) {
branch  0 never executed
branch  1 never executed
        -:  749:    year = INT64_MAX;
        -:  750:  } else {
    #####:  751:    year += 1900;
        -:  752:  }
        -:  753:
        -:  754:  // TODO: Eliminate extra normalization.
        -:  755:  const civil_second cs(static_cast<int>(year), tm.tm_mon + 1, tm.tm_mday,
    #####:  756:                        tm.tm_hour, tm.tm_min, tm.tm_sec);
call    0 never executed
        -:  757:
        -:  758:  // parse() fails if any normalization was done.  That is,
        -:  759:  // parsing "Sep 31" will not produce the equivalent of "Oct 1".
    #####:  760:  if (cs.year() != year || cs.month() != tm.tm_mon + 1 ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  761:      cs.day() != tm.tm_mday || cs.hour() != tm.tm_hour ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  762:      cs.minute() != tm.tm_min || cs.second() != tm.tm_sec) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  763:    return false;
        -:  764:  }
        -:  765:
    #####:  766:  *tpp = ptz.lookup(cs).pre - sys_seconds(offset);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  767:  *ns = subseconds;
    #####:  768:  return true;
        -:  769:}
        -:  770:
        -:  771:}  // namespace detail
        -:  772:}  // namespace cctz
