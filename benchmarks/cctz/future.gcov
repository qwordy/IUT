        -:    0:Source:/usr/include/c++/4.9/future
        -:    0:Graph:/home/yfy/iut/benchmarks/cctz/time_zone_lookup_test.gcno
        -:    0:Data:/home/yfy/iut/benchmarks/cctz/time_zone_lookup_test.gcda
        -:    0:Runs:19
        -:    0:Programs:1
        -:    1:// <future> -*- C++ -*-
        -:    2:
        -:    3:// Copyright (C) 2009-2014 Free Software Foundation, Inc.
        -:    4://
        -:    5:// This file is part of the GNU ISO C++ Library.  This library is free
        -:    6:// software; you can redistribute it and/or modify it under the
        -:    7:// terms of the GNU General Public License as published by the
        -:    8:// Free Software Foundation; either version 3, or (at your option)
        -:    9:// any later version.
        -:   10:
        -:   11:// This library is distributed in the hope that it will be useful,
        -:   12:// but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   13:// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   14:// GNU General Public License for more details.
        -:   15:
        -:   16:// Under Section 7 of GPL version 3, you are granted additional
        -:   17:// permissions described in the GCC Runtime Library Exception, version
        -:   18:// 3.1, as published by the Free Software Foundation.
        -:   19:
        -:   20:// You should have received a copy of the GNU General Public License and
        -:   21:// a copy of the GCC Runtime Library Exception along with this program;
        -:   22:// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
        -:   23:// <http://www.gnu.org/licenses/>.
        -:   24:
        -:   25:/** @file include/future
        -:   26: *  This is a Standard C++ Library header.
        -:   27: */
        -:   28:
        -:   29:#ifndef _GLIBCXX_FUTURE
        -:   30:#define _GLIBCXX_FUTURE 1
        -:   31:
        -:   32:#pragma GCC system_header
        -:   33:
        -:   34:#if __cplusplus < 201103L
        -:   35:# include <bits/c++0x_warning.h>
        -:   36:#else
        -:   37:
        -:   38:#include <functional>
        -:   39:#include <mutex>
        -:   40:#include <thread>
        -:   41:#include <condition_variable>
        -:   42:#include <system_error>
        -:   43:#include <atomic>
        -:   44:#include <bits/functexcept.h>
        -:   45:#include <bits/unique_ptr.h>
        -:   46:#include <bits/shared_ptr.h>
        -:   47:#include <bits/uses_allocator.h>
        -:   48:#include <bits/alloc_traits.h>
        -:   49:#include <ext/aligned_buffer.h>
        -:   50:
        -:   51:namespace std _GLIBCXX_VISIBILITY(default)
        -:   52:{
        -:   53:_GLIBCXX_BEGIN_NAMESPACE_VERSION
        -:   54:
        -:   55:  /**
        -:   56:   * @defgroup futures Futures
        -:   57:   * @ingroup concurrency
        -:   58:   *
        -:   59:   * Classes for futures support.
        -:   60:   * @{
        -:   61:   */
        -:   62:
        -:   63:  /// Error code for futures
        -:   64:  enum class future_errc
        -:   65:  {
        -:   66:    future_already_retrieved = 1,
        -:   67:    promise_already_satisfied,
        -:   68:    no_state,
        -:   69:    broken_promise
        -:   70:  };
        -:   71:
        -:   72:  /// Specialization.
        -:   73:  template<>
        -:   74:    struct is_error_code_enum<future_errc> : public true_type { };
        -:   75:
        -:   76:  /// Points to a statically-allocated object derived from error_category.
        -:   77:  const error_category&
        -:   78:  future_category() noexcept;
        -:   79:
        -:   80:  /// Overload for make_error_code.
        -:   81:  inline error_code
        -:   82:  make_error_code(future_errc __errc) noexcept
    #####:   83:  { return error_code(static_cast<int>(__errc), future_category()); }
call    0 never executed
        -:   84:
        -:   85:  /// Overload for make_error_condition.
        -:   86:  inline error_condition
        -:   87:  make_error_condition(future_errc __errc) noexcept
        -:   88:  { return error_condition(static_cast<int>(__errc), future_category()); }
        -:   89:
        -:   90:  /**
        -:   91:   *  @brief Exception type thrown by futures.
        -:   92:   *  @ingroup exceptions
        -:   93:   */
    #####:   94:  class future_error : public logic_error
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   95:  {
        -:   96:    error_code 			_M_code;
        -:   97:
        -:   98:  public:
function _ZNSt12future_errorC2ESt10error_code called 0 returned 0% blocks executed 0%
    #####:   99:    explicit future_error(error_code __ec)
    #####:  100:    : logic_error("std::future_error"), _M_code(__ec)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  101:    { }
        -:  102:
        -:  103:    virtual ~future_error() noexcept;
        -:  104:
        -:  105:    virtual const char*
        -:  106:    what() const noexcept;
        -:  107:
        -:  108:    const error_code&
        -:  109:    code() const noexcept { return _M_code; }
        -:  110:  };
        -:  111:
        -:  112:  // Forward declarations.
        -:  113:  template<typename _Res>
        -:  114:    class future;
        -:  115:
        -:  116:  template<typename _Res>
        -:  117:    class shared_future;
        -:  118:
        -:  119:  template<typename _Signature>
        -:  120:    class packaged_task;
        -:  121:
        -:  122:  template<typename _Res>
        -:  123:    class promise;
        -:  124:
        -:  125:  /// Launch code for futures
        -:  126:  enum class launch
        -:  127:  {
        -:  128:    async = 1,
        -:  129:    deferred = 2
        -:  130:  };
        -:  131:
        -:  132:  constexpr launch operator&(launch __x, launch __y)
        -:  133:  {
        -:  134:    return static_cast<launch>(
        -:  135:	static_cast<int>(__x) & static_cast<int>(__y));
        -:  136:  }
        -:  137:
        -:  138:  constexpr launch operator|(launch __x, launch __y)
        -:  139:  {
        -:  140:    return static_cast<launch>(
        -:  141:	static_cast<int>(__x) | static_cast<int>(__y));
        -:  142:  }
        -:  143:
        -:  144:  constexpr launch operator^(launch __x, launch __y)
        -:  145:  {
        -:  146:    return static_cast<launch>(
        -:  147:	static_cast<int>(__x) ^ static_cast<int>(__y));
        -:  148:  }
        -:  149:
        -:  150:  constexpr launch operator~(launch __x)
        -:  151:  { return static_cast<launch>(~static_cast<int>(__x)); }
        -:  152:
        -:  153:  inline launch& operator&=(launch& __x, launch __y)
        -:  154:  { return __x = __x & __y; }
        -:  155:
        -:  156:  inline launch& operator|=(launch& __x, launch __y)
        -:  157:  { return __x = __x | __y; }
        -:  158:
        -:  159:  inline launch& operator^=(launch& __x, launch __y)
        -:  160:  { return __x = __x ^ __y; }
        -:  161:
        -:  162:  /// Status code for futures
        -:  163:  enum class future_status
        -:  164:  {
        -:  165:    ready,
        -:  166:    timeout,
        -:  167:    deferred
        -:  168:  };
        -:  169:
        -:  170:  template<typename _Fn, typename... _Args>
        -:  171:    future<typename result_of<_Fn(_Args...)>::type>
        -:  172:    async(launch __policy, _Fn&& __fn, _Args&&... __args);
        -:  173:
        -:  174:  template<typename _Fn, typename... _Args>
        -:  175:    future<typename result_of<_Fn(_Args...)>::type>
        -:  176:    async(_Fn&& __fn, _Args&&... __args);
        -:  177:
        -:  178:#if defined(_GLIBCXX_HAS_GTHREADS) && defined(_GLIBCXX_USE_C99_STDINT_TR1) \
        -:  179:  && (ATOMIC_INT_LOCK_FREE > 1)
        -:  180:
        -:  181:  /// Base class and enclosing scope.
        -:  182:  struct __future_base
        -:  183:  {
        -:  184:    /// Base class for results.
        -:  185:    struct _Result_base
        -:  186:    {
        -:  187:      exception_ptr		_M_error;
        -:  188:
        -:  189:      _Result_base(const _Result_base&) = delete;
        -:  190:      _Result_base& operator=(const _Result_base&) = delete;
        -:  191:
        -:  192:      // _M_destroy() allows derived classes to control deallocation
        -:  193:      virtual void _M_destroy() = 0;
        -:  194:
        -:  195:      struct _Deleter
        -:  196:      {
     4883:  197:	void operator()(_Result_base* __fr) const { __fr->_M_destroy(); }
call    0 returned 100%
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  198:      };
        -:  199:
        -:  200:    protected:
        -:  201:      _Result_base();
        -:  202:      virtual ~_Result_base();
        -:  203:    };
        -:  204:
        -:  205:    /// Result.
        -:  206:    template<typename _Res>
        -:  207:      struct _Result : _Result_base
        -:  208:      {
        -:  209:      private:
        -:  210:	__gnu_cxx::__aligned_buffer<_Res>	_M_storage;
        -:  211:	bool 					_M_initialized;
        -:  212:
        -:  213:      public:
        -:  214:	typedef _Res result_type;
        -:  215:
        -:  216:	_Result() noexcept : _M_initialized() { }
        -:  217:	
        -:  218:	~_Result()
        -:  219:	{
        -:  220:	  if (_M_initialized)
        -:  221:	    _M_value().~_Res();
        -:  222:	}
        -:  223:
        -:  224:	// Return lvalue, future will add const or rvalue-reference
        -:  225:	_Res&
        -:  226:	_M_value() noexcept { return *_M_storage._M_ptr(); }
        -:  227:
        -:  228:	void
        -:  229:	_M_set(const _Res& __res)
        -:  230:	{
        -:  231:	  ::new (_M_storage._M_addr()) _Res(__res);
        -:  232:	  _M_initialized = true;
        -:  233:	}
        -:  234:
        -:  235:	void
        -:  236:	_M_set(_Res&& __res)
        -:  237:	{
        -:  238:	  ::new (_M_storage._M_addr()) _Res(std::move(__res));
        -:  239:	  _M_initialized = true;
        -:  240:	}
        -:  241:
        -:  242:      private:
        -:  243:	void _M_destroy() { delete this; }
        -:  244:    };
        -:  245:
        -:  246:    /// A unique_ptr based on the instantiating type.
        -:  247:    template<typename _Res>
        -:  248:      using _Ptr = unique_ptr<_Res, _Result_base::_Deleter>;
        -:  249:
        -:  250:    /// Result_alloc.
        -:  251:    template<typename _Res, typename _Alloc>
        -:  252:      struct _Result_alloc final : _Result<_Res>, _Alloc
        -:  253:      {
        -:  254:        typedef typename allocator_traits<_Alloc>::template
        -:  255:          rebind_alloc<_Result_alloc> __allocator_type;
        -:  256:
        -:  257:        explicit
        -:  258:	_Result_alloc(const _Alloc& __a) : _Result<_Res>(), _Alloc(__a)
        -:  259:        { }
        -:  260:	
        -:  261:      private:
        -:  262:	void _M_destroy()
        -:  263:        {
        -:  264:	  typedef allocator_traits<__allocator_type> __traits;
        -:  265:          __allocator_type __a(*this);
        -:  266:	  __traits::destroy(__a, this);
        -:  267:	  __traits::deallocate(__a, this, 1);
        -:  268:        }
        -:  269:      };
        -:  270:
        -:  271:    template<typename _Res, typename _Allocator>
        -:  272:      static _Ptr<_Result_alloc<_Res, _Allocator>>
        -:  273:      _S_allocate_result(const _Allocator& __a)
        -:  274:      {
        -:  275:        typedef _Result_alloc<_Res, _Allocator>	__result_type;
        -:  276:	typedef allocator_traits<typename __result_type::__allocator_type>
        -:  277:	  __traits;
        -:  278:        typename __traits::allocator_type __a2(__a);
        -:  279:        __result_type* __p = __traits::allocate(__a2, 1);
        -:  280:        __try
        -:  281:	  {
        -:  282:	    __traits::construct(__a2, __p, __a);
        -:  283:	  }
        -:  284:        __catch(...)
        -:  285:	  {
        -:  286:	    __traits::deallocate(__a2, __p, 1);
        -:  287:	    __throw_exception_again;
        -:  288:	  }
        -:  289:        return _Ptr<__result_type>(__p);
        -:  290:      }
        -:  291:
        -:  292:    template<typename _Res, typename _Tp>
        -:  293:      static _Ptr<_Result<_Res>>
        -:  294:      _S_allocate_result(const std::allocator<_Tp>& __a)
        -:  295:      {
        -:  296:	return _Ptr<_Result<_Res>>(new _Result<_Res>);
        -:  297:      }
        -:  298:
        -:  299:    /// Base class for state between a promise and one or more
        -:  300:    /// associated futures.
        -:  301:    class _State_baseV2
        -:  302:    {
        -:  303:      typedef _Ptr<_Result_base> _Ptr_type;
        -:  304:
        -:  305:      _Ptr_type			_M_result;
        -:  306:      mutex               	_M_mutex;
        -:  307:      condition_variable  	_M_cond;
        -:  308:      atomic_flag         	_M_retrieved;
        -:  309:      once_flag			_M_once;
        -:  310:
        -:  311:    public:
function _ZNSt13__future_base13_State_baseV2C2Ev called 4883 returned 100% blocks executed 100%
     9766:  312:      _State_baseV2() noexcept : _M_result(), _M_retrieved(ATOMIC_FLAG_INIT)
call    0 returned 100%
     4883:  313:	{ }
        -:  314:      _State_baseV2(const _State_baseV2&) = delete;
        -:  315:      _State_baseV2& operator=(const _State_baseV2&) = delete;
function _ZNSt13__future_base13_State_baseV2D0Ev called 0 returned 0% blocks executed 0%
function _ZNSt13__future_base13_State_baseV2D2Ev called 4883 returned 100% blocks executed 100%
     9766:  316:      virtual ~_State_baseV2() = default;
call    0 never executed
call    1 never executed
call    2 returned 100%
        -:  317:
        -:  318:      _Result_base&
function _ZNSt13__future_base13_State_baseV24waitEv called 9728 returned 100% blocks executed 83%
     9728:  319:      wait()
        -:  320:      {
     9728:  321:	_M_complete_async();
call    0 returned 100%
     9728:  322:	unique_lock<mutex> __lock(_M_mutex);
     9728:  323:	_M_cond.wait(__lock, [&] { return _M_ready(); });
     9728:  324:	return *_M_result;
        -:  325:      }
        -:  326:
        -:  327:      template<typename _Rep, typename _Period>
        -:  328:        future_status
        -:  329:        wait_for(const chrono::duration<_Rep, _Period>& __rel)
        -:  330:        {
        -:  331:	  unique_lock<mutex> __lock(_M_mutex);
        -:  332:	  if (_M_ready())
        -:  333:	    return future_status::ready;
        -:  334:	  if (_M_has_deferred())
        -:  335:	    return future_status::deferred;
        -:  336:	  if (_M_cond.wait_for(__lock, __rel, [&] { return _M_ready(); }))
        -:  337:	    {
        -:  338:	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
        -:  339:	      // 2100.  timed waiting functions must also join
        -:  340:	      _M_complete_async();
        -:  341:	      return future_status::ready;
        -:  342:	    }
        -:  343:	  return future_status::timeout;
        -:  344:	}
        -:  345:
        -:  346:      template<typename _Clock, typename _Duration>
        -:  347:        future_status
        -:  348:        wait_until(const chrono::time_point<_Clock, _Duration>& __abs)
        -:  349:        {
        -:  350:	  unique_lock<mutex> __lock(_M_mutex);
        -:  351:	  if (_M_ready())
        -:  352:	    return future_status::ready;
        -:  353:	  if (_M_has_deferred())
        -:  354:	    return future_status::deferred;
        -:  355:	  if (_M_cond.wait_until(__lock, __abs, [&] { return _M_ready(); }))
        -:  356:	    {
        -:  357:	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
        -:  358:	      // 2100.  timed waiting functions must also join
        -:  359:	      _M_complete_async();
        -:  360:	      return future_status::ready;
        -:  361:	    }
        -:  362:	  return future_status::timeout;
        -:  363:	}
        -:  364:
        -:  365:      void
function _ZNSt13__future_base13_State_baseV213_M_set_resultESt8functionIFSt10unique_ptrINS_12_Result_baseENS3_8_DeleterEEvEEb called 4883 returned 100% blocks executed 67%
     4883:  366:      _M_set_result(function<_Ptr_type()> __res, bool __ignore_failure = false)
        -:  367:      {
     4883:  368:        bool __set = false;
        -:  369:        // all calls to this function are serialized,
        -:  370:        // side-effects of invoking __res only happen once
        -:  371:        call_once(_M_once, &_State_baseV2::_M_do_set, this, ref(__res),
     4883:  372:            ref(__set));
call    0 returned 100%
     4883:  373:	if (__set)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     4883:  374:	  _M_cond.notify_all();
call    0 returned 100%
    #####:  375:	else if (!__ignore_failure)
branch  0 never executed
branch  1 never executed
    #####:  376:          __throw_future_error(int(future_errc::promise_already_satisfied));
call    0 never executed
     4883:  377:      }
        -:  378:
        -:  379:      void
function _ZNSt13__future_base13_State_baseV216_M_break_promiseESt10unique_ptrINS_12_Result_baseENS2_8_DeleterEE called 19 returned 100% blocks executed 15%
       19:  380:      _M_break_promise(_Ptr_type __res)
        -:  381:      {
       19:  382:	if (static_cast<bool>(__res))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  383:	  {
    #####:  384:	    error_code __ec(make_error_code(future_errc::broken_promise));
    #####:  385:	    __res->_M_error = make_exception_ptr(future_error(__ec));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  386:	    {
    #####:  387:	      lock_guard<mutex> __lock(_M_mutex);
        -:  388:	      _M_result.swap(__res);
        -:  389:	    }
    #####:  390:	    _M_cond.notify_all();
call    0 never executed
        -:  391:	  }
       19:  392:      }
        -:  393:
        -:  394:      // Called when this object is passed to a future.
        -:  395:      void
function _ZNSt13__future_base13_State_baseV221_M_set_retrieved_flagEv called 4883 returned 100% blocks executed 67%
     4883:  396:      _M_set_retrieved_flag()
        -:  397:      {
     4883:  398:	if (_M_retrieved.test_and_set())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  399:	  __throw_future_error(int(future_errc::future_already_retrieved));
call    0 never executed
     4883:  400:      }
        -:  401:
        -:  402:      template<typename _Res, typename _Arg>
        -:  403:        struct _Setter;
        -:  404:
        -:  405:      // set lvalues
        -:  406:      template<typename _Res, typename _Arg>
        -:  407:        struct _Setter<_Res, _Arg&>
        -:  408:        {
        -:  409:          // check this is only used by promise<R>::set_value(const R&)
        -:  410:          // or promise<R>::set_value(R&)
        -:  411:          static_assert(is_same<_Res, _Arg&>::value  // promise<R&>
        -:  412:              || is_same<const _Res, _Arg>::value,  // promise<R>
        -:  413:              "Invalid specialisation");
        -:  414:
        -:  415:          typename promise<_Res>::_Ptr_type operator()()
        -:  416:          {
        -:  417:            _State_baseV2::_S_check(_M_promise->_M_future);
        -:  418:            _M_promise->_M_storage->_M_set(_M_arg);
        -:  419:            return std::move(_M_promise->_M_storage);
        -:  420:          }
        -:  421:          promise<_Res>*    _M_promise;
        -:  422:          _Arg&             _M_arg;
        -:  423:        };
        -:  424:
        -:  425:      // set rvalues
        -:  426:      template<typename _Res>
        -:  427:        struct _Setter<_Res, _Res&&>
        -:  428:        {
        -:  429:          typename promise<_Res>::_Ptr_type operator()()
        -:  430:          {
        -:  431:            _State_baseV2::_S_check(_M_promise->_M_future);
        -:  432:            _M_promise->_M_storage->_M_set(std::move(_M_arg));
        -:  433:            return std::move(_M_promise->_M_storage);
        -:  434:          }
        -:  435:          promise<_Res>*    _M_promise;
        -:  436:          _Res&             _M_arg;
        -:  437:        };
        -:  438:
        -:  439:      struct __exception_ptr_tag { };
        -:  440:
        -:  441:      // set exceptions
        -:  442:      template<typename _Res>
        -:  443:        struct _Setter<_Res, __exception_ptr_tag>
        -:  444:        {
        -:  445:          typename promise<_Res>::_Ptr_type operator()()
        -:  446:          {
        -:  447:            _State_baseV2::_S_check(_M_promise->_M_future);
        -:  448:            _M_promise->_M_storage->_M_error = _M_ex;
        -:  449:            return std::move(_M_promise->_M_storage);
        -:  450:          }
        -:  451:
        -:  452:          promise<_Res>*   _M_promise;
        -:  453:          exception_ptr&    _M_ex;
        -:  454:        };
        -:  455:
        -:  456:      template<typename _Res, typename _Arg>
        -:  457:        static _Setter<_Res, _Arg&&>
        -:  458:        __setter(promise<_Res>* __prom, _Arg&& __arg)
        -:  459:        {
        -:  460:          return _Setter<_Res, _Arg&&>{ __prom, __arg };
        -:  461:        }
        -:  462:
        -:  463:      template<typename _Res>
        -:  464:        static _Setter<_Res, __exception_ptr_tag>
        -:  465:        __setter(exception_ptr& __ex, promise<_Res>* __prom)
        -:  466:        {
        -:  467:          return _Setter<_Res, __exception_ptr_tag>{ __prom, __ex };
        -:  468:        }
        -:  469:
        -:  470:      static _Setter<void, void>
        -:  471:      __setter(promise<void>* __prom);
        -:  472:
        -:  473:      template<typename _Tp>
        -:  474:        static void
        -:  475:        _S_check(const shared_ptr<_Tp>& __p)
        -:  476:        {
    19494:  477:          if (!static_cast<bool>(__p))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####:  478:            __throw_future_error((int)future_errc::no_state);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  479:        }
        -:  480:
        -:  481:    private:
        -:  482:      void
function _ZNSt13__future_base13_State_baseV29_M_do_setERSt8functionIFSt10unique_ptrINS_12_Result_baseENS3_8_DeleterEEvEERb called 4883 returned 100% blocks executed 70%
     4883:  483:      _M_do_set(function<_Ptr_type()>& __f, bool& __set)
        -:  484:      {
     4883:  485:        _Ptr_type __res = __f();
call    0 returned 100%
        -:  486:        {
     4883:  487:          lock_guard<mutex> __lock(_M_mutex);
        -:  488:          _M_result.swap(__res);
        -:  489:        }
     4883:  490:        __set = true;
     4883:  491:      }
        -:  492:
        -:  493:      bool _M_ready() const noexcept { return static_cast<bool>(_M_result); }
        -:  494:
        -:  495:      // Wait for completion of async function.
function _ZNSt13__future_base13_State_baseV217_M_complete_asyncEv called 9728 returned 100% blocks executed 100%
     9728:  496:      virtual void _M_complete_async() { }
        -:  497:
        -:  498:      // Return true if state contains a deferred function.
        -:  499:      // Caller must own _M_mutex.
function _ZNKSt13__future_base13_State_baseV215_M_has_deferredEv called 0 returned 0% blocks executed 0%
    #####:  500:      virtual bool _M_has_deferred() const { return false; }
        -:  501:    };
        -:  502:
        -:  503:#ifdef _GLIBCXX_ASYNC_ABI_COMPAT
        -:  504:    class _State_base;
        -:  505:    class _Async_state_common;
        -:  506:#else
        -:  507:    using _State_base = _State_baseV2;
        -:  508:    class _Async_state_commonV2;
        -:  509:#endif
        -:  510:
        -:  511:    template<typename _BoundFn, typename = typename _BoundFn::result_type>
        -:  512:      class _Deferred_state;
        -:  513:
        -:  514:    template<typename _BoundFn, typename = typename _BoundFn::result_type>
        -:  515:      class _Async_state_impl;
        -:  516:
        -:  517:    template<typename _Signature>
        -:  518:      class _Task_state_base;
        -:  519:
        -:  520:    template<typename _Fn, typename _Alloc, typename _Signature>
        -:  521:      class _Task_state;
        -:  522:
        -:  523:    template<typename _BoundFn>
        -:  524:      static std::shared_ptr<_State_base>
        -:  525:      _S_make_deferred_state(_BoundFn&& __fn);
        -:  526:
        -:  527:    template<typename _BoundFn>
        -:  528:      static std::shared_ptr<_State_base>
        -:  529:      _S_make_async_state(_BoundFn&& __fn);
        -:  530:
        -:  531:    template<typename _Res_ptr,
        -:  532:	     typename _Res = typename _Res_ptr::element_type::result_type>
        -:  533:      struct _Task_setter;
        -:  534:
        -:  535:    template<typename _Res_ptr, typename _BoundFn>
        -:  536:      static _Task_setter<_Res_ptr>
        -:  537:      _S_task_setter(_Res_ptr& __ptr, _BoundFn&& __call)
        -:  538:      {
        -:  539:	return _Task_setter<_Res_ptr>{ __ptr, std::ref(__call) };
        -:  540:      }
        -:  541:  };
        -:  542:
        -:  543:  /// Partial specialization for reference types.
        -:  544:  template<typename _Res>
        -:  545:    struct __future_base::_Result<_Res&> : __future_base::_Result_base
        -:  546:    {
        -:  547:      typedef _Res& result_type;
        -:  548:
        -:  549:      _Result() noexcept : _M_value_ptr() { }
        -:  550:
        -:  551:      void _M_set(_Res& __res) noexcept { _M_value_ptr = &__res; }
        -:  552:
        -:  553:      _Res& _M_get() noexcept { return *_M_value_ptr; }
        -:  554:
        -:  555:    private:
        -:  556:      _Res* 			_M_value_ptr;
        -:  557:
        -:  558:      void _M_destroy() { delete this; }
        -:  559:    };
        -:  560:
        -:  561:  /// Explicit specialization for void.
        -:  562:  template<>
function _ZNSt13__future_base7_ResultIvED0Ev called 4883 returned 100% blocks executed 100%
function _ZNSt13__future_base7_ResultIvED2Ev called 0 returned 0% blocks executed 0%
     9766:  563:    struct __future_base::_Result<void> : __future_base::_Result_base
call    0 returned 100%
call    1 returned 100%
call    2 never executed
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        -:  564:    {
        -:  565:      typedef void result_type;
        -:  566:
        -:  567:    private:
function _ZNSt13__future_base7_ResultIvE10_M_destroyEv called 4883 returned 100% blocks executed 100%
     4883:  568:      void _M_destroy() { delete this; }
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:  569:    };
        -:  570:
        -:  571:#ifndef _GLIBCXX_ASYNC_ABI_COMPAT
        -:  572:
        -:  573:  /// Common implementation for future and shared_future.
        -:  574:  template<typename _Res>
    14629:  575:    class __basic_future : public __future_base
        -:  576:    {
        -:  577:    protected:
        -:  578:      typedef shared_ptr<_State_base>		__state_type;
        -:  579:      typedef __future_base::_Result<_Res>&	__result_type;
        -:  580:
        -:  581:    private:
        -:  582:      __state_type 		_M_state;
        -:  583:
        -:  584:    public:
        -:  585:      // Disable copying.
        -:  586:      __basic_future(const __basic_future&) = delete;
        -:  587:      __basic_future& operator=(const __basic_future&) = delete;
        -:  588:
        -:  589:      bool
        -:  590:      valid() const noexcept { return static_cast<bool>(_M_state); }
        -:  591:
        -:  592:      void
function _ZNKSt14__basic_futureIvE4waitEv called 9728 returned 100% blocks executed 75%
     9728:  593:      wait() const
        -:  594:      {
        -:  595:        _State_base::_S_check(_M_state);
     9728:  596:        _M_state->wait();
call    0 returned 100%
     9728:  597:      }
        -:  598:
        -:  599:      template<typename _Rep, typename _Period>
        -:  600:        future_status
        -:  601:        wait_for(const chrono::duration<_Rep, _Period>& __rel) const
        -:  602:        {
        -:  603:          _State_base::_S_check(_M_state);
        -:  604:          return _M_state->wait_for(__rel);
        -:  605:        }
        -:  606:
        -:  607:      template<typename _Clock, typename _Duration>
        -:  608:        future_status
        -:  609:        wait_until(const chrono::time_point<_Clock, _Duration>& __abs) const
        -:  610:        {
        -:  611:          _State_base::_S_check(_M_state);
        -:  612:          return _M_state->wait_until(__abs);
        -:  613:        }
        -:  614:
        -:  615:    protected:
        -:  616:      /// Wait for the state to be ready and rethrow any stored exception
        -:  617:      __result_type
        -:  618:      _M_get_result() const
        -:  619:      {
        -:  620:        _State_base::_S_check(_M_state);
        -:  621:        _Result_base& __res = _M_state->wait();
        -:  622:        if (!(__res._M_error == 0))
        -:  623:          rethrow_exception(__res._M_error);
        -:  624:        return static_cast<__result_type>(__res);
        -:  625:      }
        -:  626:
        -:  627:      void _M_swap(__basic_future& __that) noexcept
        -:  628:      {
        -:  629:        _M_state.swap(__that._M_state);
        -:  630:      }
        -:  631:
        -:  632:      // Construction of a future by promise::get_future()
        -:  633:      explicit
function _ZNSt14__basic_futureIvEC2ERKSt10shared_ptrINSt13__future_base13_State_baseV2EE called 4883 returned 100% blocks executed 67%
     4883:  634:      __basic_future(const __state_type& __state) : _M_state(__state)
        -:  635:      {
        -:  636:        _State_base::_S_check(_M_state);
     4883:  637:        _M_state->_M_set_retrieved_flag();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
     4883:  638:      }
        -:  639:
        -:  640:      // Copy construction from a shared_future
        -:  641:      explicit
        -:  642:      __basic_future(const shared_future<_Res>&) noexcept;
        -:  643:
        -:  644:      // Move construction from a shared_future
        -:  645:      explicit
        -:  646:      __basic_future(shared_future<_Res>&&) noexcept;
        -:  647:
        -:  648:      // Move construction from a future
        -:  649:      explicit
        -:  650:      __basic_future(future<_Res>&&) noexcept;
        -:  651:
        -:  652:      constexpr __basic_future() noexcept : _M_state() { }
        -:  653:
        -:  654:      struct _Reset
        -:  655:      {
        -:  656:        explicit _Reset(__basic_future& __fut) noexcept : _M_fut(__fut) { }
        -:  657:        ~_Reset() { _M_fut._M_state.reset(); }
        -:  658:        __basic_future& _M_fut;
        -:  659:      };
        -:  660:    };
        -:  661:
        -:  662:
        -:  663:  /// Primary template for future.
        -:  664:  template<typename _Res>
        -:  665:    class future : public __basic_future<_Res>
        -:  666:    {
        -:  667:      friend class promise<_Res>;
        -:  668:      template<typename> friend class packaged_task;
        -:  669:      template<typename _Fn, typename... _Args>
        -:  670:        friend future<typename result_of<_Fn(_Args...)>::type>
        -:  671:        async(launch, _Fn&&, _Args&&...);
        -:  672:
        -:  673:      typedef __basic_future<_Res> _Base_type;
        -:  674:      typedef typename _Base_type::__state_type __state_type;
        -:  675:
        -:  676:      explicit
        -:  677:      future(const __state_type& __state) : _Base_type(__state) { }
        -:  678:
        -:  679:    public:
        -:  680:      constexpr future() noexcept : _Base_type() { }
        -:  681:
        -:  682:      /// Move constructor
        -:  683:      future(future&& __uf) noexcept : _Base_type(std::move(__uf)) { }
        -:  684:
        -:  685:      // Disable copying
        -:  686:      future(const future&) = delete;
        -:  687:      future& operator=(const future&) = delete;
        -:  688:
        -:  689:      future& operator=(future&& __fut) noexcept
        -:  690:      {
        -:  691:        future(std::move(__fut))._M_swap(*this);
        -:  692:        return *this;
        -:  693:      }
        -:  694:
        -:  695:      /// Retrieving the value
        -:  696:      _Res
        -:  697:      get()
        -:  698:      {
        -:  699:        typename _Base_type::_Reset __reset(*this);
        -:  700:        return std::move(this->_M_get_result()._M_value());
        -:  701:      }
        -:  702:
        -:  703:      shared_future<_Res> share();
        -:  704:    };
        -:  705:
        -:  706:  /// Partial specialization for future<R&>
        -:  707:  template<typename _Res>
        -:  708:    class future<_Res&> : public __basic_future<_Res&>
        -:  709:    {
        -:  710:      friend class promise<_Res&>;
        -:  711:      template<typename> friend class packaged_task;
        -:  712:      template<typename _Fn, typename... _Args>
        -:  713:        friend future<typename result_of<_Fn(_Args...)>::type>
        -:  714:        async(launch, _Fn&&, _Args&&...);
        -:  715:
        -:  716:      typedef __basic_future<_Res&> _Base_type;
        -:  717:      typedef typename _Base_type::__state_type __state_type;
        -:  718:
        -:  719:      explicit
        -:  720:      future(const __state_type& __state) : _Base_type(__state) { }
        -:  721:
        -:  722:    public:
        -:  723:      constexpr future() noexcept : _Base_type() { }
        -:  724:
        -:  725:      /// Move constructor
        -:  726:      future(future&& __uf) noexcept : _Base_type(std::move(__uf)) { }
        -:  727:
        -:  728:      // Disable copying
        -:  729:      future(const future&) = delete;
        -:  730:      future& operator=(const future&) = delete;
        -:  731:
        -:  732:      future& operator=(future&& __fut) noexcept
        -:  733:      {
        -:  734:        future(std::move(__fut))._M_swap(*this);
        -:  735:        return *this;
        -:  736:      }
        -:  737:
        -:  738:      /// Retrieving the value
        -:  739:      _Res&
        -:  740:      get()
        -:  741:      {
        -:  742:        typename _Base_type::_Reset __reset(*this);
        -:  743:        return this->_M_get_result()._M_get();
        -:  744:      }
        -:  745:
        -:  746:      shared_future<_Res&> share();
        -:  747:    };
        -:  748:
        -:  749:  /// Explicit specialization for future<void>
        -:  750:  template<>
     4883:  751:    class future<void> : public __basic_future<void>
        -:  752:    {
        -:  753:      friend class promise<void>;
        -:  754:      template<typename> friend class packaged_task;
        -:  755:      template<typename _Fn, typename... _Args>
        -:  756:        friend future<typename result_of<_Fn(_Args...)>::type>
        -:  757:        async(launch, _Fn&&, _Args&&...);
        -:  758:
        -:  759:      typedef __basic_future<void> _Base_type;
        -:  760:      typedef typename _Base_type::__state_type __state_type;
        -:  761:
        -:  762:      explicit
     4883:  763:      future(const __state_type& __state) : _Base_type(__state) { }
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        -:  764:
        -:  765:    public:
        -:  766:      constexpr future() noexcept : _Base_type() { }
        -:  767:
        -:  768:      /// Move constructor
        -:  769:      future(future&& __uf) noexcept : _Base_type(std::move(__uf)) { }
        -:  770:
        -:  771:      // Disable copying
        -:  772:      future(const future&) = delete;
        -:  773:      future& operator=(const future&) = delete;
        -:  774:
        -:  775:      future& operator=(future&& __fut) noexcept
        -:  776:      {
        -:  777:        future(std::move(__fut))._M_swap(*this);
        -:  778:        return *this;
        -:  779:      }
        -:  780:
        -:  781:      /// Retrieving the value
        -:  782:      void
        -:  783:      get()
        -:  784:      {
        -:  785:        typename _Base_type::_Reset __reset(*this);
        -:  786:        this->_M_get_result();
        -:  787:      }
        -:  788:
        -:  789:      shared_future<void> share();
        -:  790:    };
        -:  791:
        -:  792:
        -:  793:  /// Primary template for shared_future.
        -:  794:  template<typename _Res>
        -:  795:    class shared_future : public __basic_future<_Res>
        -:  796:    {
        -:  797:      typedef __basic_future<_Res> _Base_type;
        -:  798:
        -:  799:    public:
        -:  800:      constexpr shared_future() noexcept : _Base_type() { }
        -:  801:
        -:  802:      /// Copy constructor
        -:  803:      shared_future(const shared_future& __sf) : _Base_type(__sf) { }
        -:  804:
        -:  805:      /// Construct from a future rvalue
        -:  806:      shared_future(future<_Res>&& __uf) noexcept
        -:  807:      : _Base_type(std::move(__uf))
        -:  808:      { }
        -:  809:
        -:  810:      /// Construct from a shared_future rvalue
        -:  811:      shared_future(shared_future&& __sf) noexcept
        -:  812:      : _Base_type(std::move(__sf))
        -:  813:      { }
        -:  814:
        -:  815:      shared_future& operator=(const shared_future& __sf)
        -:  816:      {
        -:  817:        shared_future(__sf)._M_swap(*this);
        -:  818:        return *this;
        -:  819:      }
        -:  820:
        -:  821:      shared_future& operator=(shared_future&& __sf) noexcept
        -:  822:      {
        -:  823:        shared_future(std::move(__sf))._M_swap(*this);
        -:  824:        return *this;
        -:  825:      }
        -:  826:
        -:  827:      /// Retrieving the value
        -:  828:      const _Res&
        -:  829:      get() const { return this->_M_get_result()._M_value(); }
        -:  830:    };
        -:  831:
        -:  832:  /// Partial specialization for shared_future<R&>
        -:  833:  template<typename _Res>
        -:  834:    class shared_future<_Res&> : public __basic_future<_Res&>
        -:  835:    {
        -:  836:      typedef __basic_future<_Res&>           _Base_type;
        -:  837:
        -:  838:    public:
        -:  839:      constexpr shared_future() noexcept : _Base_type() { }
        -:  840:
        -:  841:      /// Copy constructor
        -:  842:      shared_future(const shared_future& __sf) : _Base_type(__sf) { }
        -:  843:
        -:  844:      /// Construct from a future rvalue
        -:  845:      shared_future(future<_Res&>&& __uf) noexcept
        -:  846:      : _Base_type(std::move(__uf))
        -:  847:      { }
        -:  848:
        -:  849:      /// Construct from a shared_future rvalue
        -:  850:      shared_future(shared_future&& __sf) noexcept
        -:  851:      : _Base_type(std::move(__sf))
        -:  852:      { }
        -:  853:
        -:  854:      shared_future& operator=(const shared_future& __sf)
        -:  855:      {
        -:  856:        shared_future(__sf)._M_swap(*this);
        -:  857:        return *this;
        -:  858:      }
        -:  859:
        -:  860:      shared_future& operator=(shared_future&& __sf) noexcept
        -:  861:      {
        -:  862:        shared_future(std::move(__sf))._M_swap(*this);
        -:  863:        return *this;
        -:  864:      }
        -:  865:
        -:  866:      /// Retrieving the value
        -:  867:      _Res&
        -:  868:      get() const { return this->_M_get_result()._M_get(); }
        -:  869:    };
        -:  870:
        -:  871:  /// Explicit specialization for shared_future<void>
        -:  872:  template<>
     9746:  873:    class shared_future<void> : public __basic_future<void>
        -:  874:    {
        -:  875:      typedef __basic_future<void> _Base_type;
        -:  876:
        -:  877:    public:
        -:  878:      constexpr shared_future() noexcept : _Base_type() { }
        -:  879:
        -:  880:      /// Copy constructor
        -:  881:      shared_future(const shared_future& __sf) : _Base_type(__sf) { }
        -:  882:
        -:  883:      /// Construct from a future rvalue
        -:  884:      shared_future(future<void>&& __uf) noexcept
        -:  885:      : _Base_type(std::move(__uf))
        -:  886:      { }
        -:  887:
        -:  888:      /// Construct from a shared_future rvalue
        -:  889:      shared_future(shared_future&& __sf) noexcept
        -:  890:      : _Base_type(std::move(__sf))
        -:  891:      { }
        -:  892:
        -:  893:      shared_future& operator=(const shared_future& __sf)
        -:  894:      {
        -:  895:        shared_future(__sf)._M_swap(*this);
        -:  896:        return *this;
        -:  897:      }
        -:  898:
        -:  899:      shared_future& operator=(shared_future&& __sf) noexcept
        -:  900:      {
        -:  901:        shared_future(std::move(__sf))._M_swap(*this);
        -:  902:        return *this;
        -:  903:      }
        -:  904:
        -:  905:      // Retrieving the value
        -:  906:      void
        -:  907:      get() const { this->_M_get_result(); }
        -:  908:    };
        -:  909:
        -:  910:  // Now we can define the protected __basic_future constructors.
        -:  911:  template<typename _Res>
        -:  912:    inline __basic_future<_Res>::
        -:  913:    __basic_future(const shared_future<_Res>& __sf) noexcept
        -:  914:    : _M_state(__sf._M_state)
        -:  915:    { }
        -:  916:
        -:  917:  template<typename _Res>
        -:  918:    inline __basic_future<_Res>::
        -:  919:    __basic_future(shared_future<_Res>&& __sf) noexcept
        -:  920:    : _M_state(std::move(__sf._M_state))
        -:  921:    { }
        -:  922:
        -:  923:  template<typename _Res>
        -:  924:    inline __basic_future<_Res>::
        -:  925:    __basic_future(future<_Res>&& __uf) noexcept
        -:  926:    : _M_state(std::move(__uf._M_state))
        -:  927:    { }
        -:  928:
        -:  929:  template<typename _Res>
        -:  930:    inline shared_future<_Res>
        -:  931:    future<_Res>::share()
        -:  932:    { return shared_future<_Res>(std::move(*this)); }
        -:  933:
        -:  934:  template<typename _Res>
        -:  935:    inline shared_future<_Res&>
        -:  936:    future<_Res&>::share()
        -:  937:    { return shared_future<_Res&>(std::move(*this)); }
        -:  938:
        -:  939:  inline shared_future<void>
        -:  940:  future<void>::share()
        -:  941:  { return shared_future<void>(std::move(*this)); }
        -:  942:
        -:  943:  /// Primary template for promise
        -:  944:  template<typename _Res>
        -:  945:    class promise
        -:  946:    {
        -:  947:      typedef __future_base::_State_base 	_State;
        -:  948:      typedef __future_base::_Result<_Res>	_Res_type;
        -:  949:      typedef __future_base::_Ptr<_Res_type>	_Ptr_type;
        -:  950:      template<typename, typename> friend class _State::_Setter;
        -:  951:
        -:  952:      shared_ptr<_State>                        _M_future;
        -:  953:      _Ptr_type                                 _M_storage;
        -:  954:
        -:  955:    public:
        -:  956:      promise()
        -:  957:      : _M_future(std::make_shared<_State>()),
        -:  958:	_M_storage(new _Res_type())
        -:  959:      { }
        -:  960:
        -:  961:      promise(promise&& __rhs) noexcept
        -:  962:      : _M_future(std::move(__rhs._M_future)),
        -:  963:	_M_storage(std::move(__rhs._M_storage))
        -:  964:      { }
        -:  965:
        -:  966:      template<typename _Allocator>
        -:  967:        promise(allocator_arg_t, const _Allocator& __a)
        -:  968:        : _M_future(std::allocate_shared<_State>(__a)),
        -:  969:	  _M_storage(__future_base::_S_allocate_result<_Res>(__a))
        -:  970:        { }
        -:  971:
        -:  972:      template<typename _Allocator>
        -:  973:        promise(allocator_arg_t, const _Allocator&, promise&& __rhs)
        -:  974:        : _M_future(std::move(__rhs._M_future)),
        -:  975:	  _M_storage(std::move(__rhs._M_storage))
        -:  976:        { }
        -:  977:
        -:  978:      promise(const promise&) = delete;
        -:  979:
        -:  980:      ~promise()
        -:  981:      {
        -:  982:        if (static_cast<bool>(_M_future) && !_M_future.unique())
        -:  983:          _M_future->_M_break_promise(std::move(_M_storage));
        -:  984:      }
        -:  985:
        -:  986:      // Assignment
        -:  987:      promise&
        -:  988:      operator=(promise&& __rhs) noexcept
        -:  989:      {
        -:  990:        promise(std::move(__rhs)).swap(*this);
        -:  991:        return *this;
        -:  992:      }
        -:  993:
        -:  994:      promise& operator=(const promise&) = delete;
        -:  995:
        -:  996:      void
        -:  997:      swap(promise& __rhs) noexcept
        -:  998:      {
        -:  999:        _M_future.swap(__rhs._M_future);
        -: 1000:        _M_storage.swap(__rhs._M_storage);
        -: 1001:      }
        -: 1002:
        -: 1003:      // Retrieving the result
        -: 1004:      future<_Res>
        -: 1005:      get_future()
        -: 1006:      { return future<_Res>(_M_future); }
        -: 1007:
        -: 1008:      // Setting the result
        -: 1009:      void
        -: 1010:      set_value(const _Res& __r)
        -: 1011:      {
        -: 1012:	auto __future = _M_future;
        -: 1013:        auto __setter = _State::__setter(this, __r);
        -: 1014:        __future->_M_set_result(std::move(__setter));
        -: 1015:      }
        -: 1016:
        -: 1017:      void
        -: 1018:      set_value(_Res&& __r)
        -: 1019:      {
        -: 1020:	auto __future = _M_future;
        -: 1021:        auto __setter = _State::__setter(this, std::move(__r));
        -: 1022:        __future->_M_set_result(std::move(__setter));
        -: 1023:      }
        -: 1024:
        -: 1025:      void
        -: 1026:      set_exception(exception_ptr __p)
        -: 1027:      {
        -: 1028:	auto __future = _M_future;
        -: 1029:        auto __setter = _State::__setter(__p, this);
        -: 1030:        __future->_M_set_result(std::move(__setter));
        -: 1031:      }
        -: 1032:    };
        -: 1033:
        -: 1034:  template<typename _Res>
        -: 1035:    inline void
        -: 1036:    swap(promise<_Res>& __x, promise<_Res>& __y) noexcept
        -: 1037:    { __x.swap(__y); }
        -: 1038:
        -: 1039:  template<typename _Res, typename _Alloc>
        -: 1040:    struct uses_allocator<promise<_Res>, _Alloc>
        -: 1041:    : public true_type { };
        -: 1042:
        -: 1043:
        -: 1044:  /// Partial specialization for promise<R&>
        -: 1045:  template<typename _Res>
        -: 1046:    class promise<_Res&>
        -: 1047:    {
        -: 1048:      typedef __future_base::_State_base	_State;
        -: 1049:      typedef __future_base::_Result<_Res&>	_Res_type;
        -: 1050:      typedef __future_base::_Ptr<_Res_type> 	_Ptr_type;
        -: 1051:      template<typename, typename> friend class _State::_Setter;
        -: 1052:
        -: 1053:      shared_ptr<_State>                        _M_future;
        -: 1054:      _Ptr_type                                 _M_storage;
        -: 1055:
        -: 1056:    public:
        -: 1057:      promise()
        -: 1058:      : _M_future(std::make_shared<_State>()),
        -: 1059:	_M_storage(new _Res_type())
        -: 1060:      { }
        -: 1061:
        -: 1062:      promise(promise&& __rhs) noexcept
        -: 1063:      : _M_future(std::move(__rhs._M_future)),
        -: 1064:	_M_storage(std::move(__rhs._M_storage))
        -: 1065:      { }
        -: 1066:
        -: 1067:      template<typename _Allocator>
        -: 1068:        promise(allocator_arg_t, const _Allocator& __a)
        -: 1069:        : _M_future(std::allocate_shared<_State>(__a)),
        -: 1070:	  _M_storage(__future_base::_S_allocate_result<_Res&>(__a))
        -: 1071:        { }
        -: 1072:
        -: 1073:      template<typename _Allocator>
        -: 1074:        promise(allocator_arg_t, const _Allocator&, promise&& __rhs)
        -: 1075:        : _M_future(std::move(__rhs._M_future)),
        -: 1076:	  _M_storage(std::move(__rhs._M_storage))
        -: 1077:        { }
        -: 1078:
        -: 1079:      promise(const promise&) = delete;
        -: 1080:
        -: 1081:      ~promise()
        -: 1082:      {
        -: 1083:        if (static_cast<bool>(_M_future) && !_M_future.unique())
        -: 1084:          _M_future->_M_break_promise(std::move(_M_storage));
        -: 1085:      }
        -: 1086:
        -: 1087:      // Assignment
        -: 1088:      promise&
        -: 1089:      operator=(promise&& __rhs) noexcept
        -: 1090:      {
        -: 1091:        promise(std::move(__rhs)).swap(*this);
        -: 1092:        return *this;
        -: 1093:      }
        -: 1094:
        -: 1095:      promise& operator=(const promise&) = delete;
        -: 1096:
        -: 1097:      void
        -: 1098:      swap(promise& __rhs) noexcept
        -: 1099:      {
        -: 1100:        _M_future.swap(__rhs._M_future);
        -: 1101:        _M_storage.swap(__rhs._M_storage);
        -: 1102:      }
        -: 1103:
        -: 1104:      // Retrieving the result
        -: 1105:      future<_Res&>
        -: 1106:      get_future()
        -: 1107:      { return future<_Res&>(_M_future); }
        -: 1108:
        -: 1109:      // Setting the result
        -: 1110:      void
        -: 1111:      set_value(_Res& __r)
        -: 1112:      {
        -: 1113:	auto __future = _M_future;
        -: 1114:        auto __setter = _State::__setter(this, __r);
        -: 1115:        __future->_M_set_result(std::move(__setter));
        -: 1116:      }
        -: 1117:
        -: 1118:      void
        -: 1119:      set_exception(exception_ptr __p)
        -: 1120:      {
        -: 1121:	auto __future = _M_future;
        -: 1122:        auto __setter = _State::__setter(__p, this);
        -: 1123:        __future->_M_set_result(std::move(__setter));
        -: 1124:      }
        -: 1125:    };
        -: 1126:
        -: 1127:  /// Explicit specialization for promise<void>
        -: 1128:  template<>
        -: 1129:    class promise<void>
        -: 1130:    {
        -: 1131:      typedef __future_base::_State_base	_State;
        -: 1132:      typedef __future_base::_Result<void>	_Res_type;
        -: 1133:      typedef __future_base::_Ptr<_Res_type> 	_Ptr_type;
        -: 1134:      template<typename, typename> friend class _State::_Setter;
        -: 1135:
        -: 1136:      shared_ptr<_State>                        _M_future;
        -: 1137:      _Ptr_type                                 _M_storage;
        -: 1138:
        -: 1139:    public:
function _ZNSt7promiseIvEC2Ev called 4883 returned 100% blocks executed 56%
     4883: 1140:      promise()
        -: 1141:      : _M_future(std::make_shared<_State>()),
     4883: 1142:	_M_storage(new _Res_type())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 never executed
     4883: 1143:      { }
        -: 1144:
        -: 1145:      promise(promise&& __rhs) noexcept
        -: 1146:      : _M_future(std::move(__rhs._M_future)),
        -: 1147:	_M_storage(std::move(__rhs._M_storage))
        -: 1148:      { }
        -: 1149:
        -: 1150:      template<typename _Allocator>
        -: 1151:        promise(allocator_arg_t, const _Allocator& __a)
        -: 1152:        : _M_future(std::allocate_shared<_State>(__a)),
        -: 1153:	  _M_storage(__future_base::_S_allocate_result<void>(__a))
        -: 1154:        { }
        -: 1155:
        -: 1156:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
        -: 1157:      // 2095.  missing constructors needed for uses-allocator construction
        -: 1158:      template<typename _Allocator>
        -: 1159:        promise(allocator_arg_t, const _Allocator&, promise&& __rhs)
        -: 1160:        : _M_future(std::move(__rhs._M_future)),
        -: 1161:	  _M_storage(std::move(__rhs._M_storage))
        -: 1162:        { }
        -: 1163:
        -: 1164:      promise(const promise&) = delete;
        -: 1165:
function _ZNSt7promiseIvED2Ev called 4883 returned 100% blocks executed 87%
     4883: 1166:      ~promise()
        -: 1167:      {
     9766: 1168:        if (static_cast<bool>(_M_future) && !_M_future.unique())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 99% (fallthrough)
branch  3 taken 1%
branch  4 taken 1% (fallthrough)
branch  5 taken 99%
       38: 1169:          _M_future->_M_break_promise(std::move(_M_storage));
call    0 returned 100%
     4883: 1170:      }
        -: 1171:
        -: 1172:      // Assignment
        -: 1173:      promise&
        -: 1174:      operator=(promise&& __rhs) noexcept
        -: 1175:      {
        -: 1176:        promise(std::move(__rhs)).swap(*this);
        -: 1177:        return *this;
        -: 1178:      }
        -: 1179:
        -: 1180:      promise& operator=(const promise&) = delete;
        -: 1181:
        -: 1182:      void
        -: 1183:      swap(promise& __rhs) noexcept
        -: 1184:      {
        -: 1185:        _M_future.swap(__rhs._M_future);
        -: 1186:        _M_storage.swap(__rhs._M_storage);
        -: 1187:      }
        -: 1188:
        -: 1189:      // Retrieving the result
        -: 1190:      future<void>
        -: 1191:      get_future()
        -: 1192:      { return future<void>(_M_future); }
        -: 1193:
        -: 1194:      // Setting the result
        -: 1195:      void set_value();
        -: 1196:
        -: 1197:      void
        -: 1198:      set_exception(exception_ptr __p)
        -: 1199:      {
        -: 1200:	auto __future = _M_future;
        -: 1201:        auto __setter = _State::__setter(__p, this);
        -: 1202:        __future->_M_set_result(std::move(__setter));
        -: 1203:      }
        -: 1204:    };
        -: 1205:
        -: 1206:  // set void
        -: 1207:  template<>
        -: 1208:    struct __future_base::_State_base::_Setter<void, void>
        -: 1209:    {
        -: 1210:      promise<void>::_Ptr_type operator()()
        -: 1211:      {
     4883: 1212:        _State_base::_S_check(_M_promise->_M_future);
        -: 1213:        return std::move(_M_promise->_M_storage);
        -: 1214:      }
        -: 1215:
        -: 1216:      promise<void>*    _M_promise;
        -: 1217:    };
        -: 1218:
        -: 1219:  inline __future_base::_State_base::_Setter<void, void>
        -: 1220:  __future_base::_State_base::__setter(promise<void>* __prom)
        -: 1221:  {
        -: 1222:    return _Setter<void, void>{ __prom };
        -: 1223:  }
        -: 1224:
        -: 1225:  inline void
function _ZNSt7promiseIvE9set_valueEv called 4883 returned 100% blocks executed 67%
     4883: 1226:  promise<void>::set_value()
        -: 1227:  {
        -: 1228:    auto __future = _M_future;
     4883: 1229:    auto __setter = _State::__setter(this);
     9766: 1230:    __future->_M_set_result(std::move(__setter));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
     4883: 1231:  }
        -: 1232:
        -: 1233:
        -: 1234:  template<typename _Ptr_type, typename _Res>
        -: 1235:    struct __future_base::_Task_setter
        -: 1236:    {
        -: 1237:      _Ptr_type operator()()
        -: 1238:      {
        -: 1239:	__try
        -: 1240:	  {
        -: 1241:	    _M_result->_M_set(_M_fn());
        -: 1242:	  }
        -: 1243:	__catch(const __cxxabiv1::__forced_unwind&)
        -: 1244:	  {
        -: 1245:	    __throw_exception_again; // will cause broken_promise
        -: 1246:	  }
        -: 1247:	__catch(...)
        -: 1248:	  {
        -: 1249:	    _M_result->_M_error = current_exception();
        -: 1250:	  }
        -: 1251:	return std::move(_M_result);
        -: 1252:      }
        -: 1253:      _Ptr_type&                _M_result;
        -: 1254:      std::function<_Res()>     _M_fn;
        -: 1255:    };
        -: 1256:
        -: 1257:  template<typename _Ptr_type>
        -: 1258:    struct __future_base::_Task_setter<_Ptr_type, void>
        -: 1259:    {
        -: 1260:      _Ptr_type operator()()
        -: 1261:      {
        -: 1262:	__try
        -: 1263:	  {
        -: 1264:	    _M_fn();
        -: 1265:	  }
        -: 1266:	__catch(const __cxxabiv1::__forced_unwind&)
        -: 1267:	  {
        -: 1268:	    __throw_exception_again; // will cause broken_promise
        -: 1269:	  }
        -: 1270:	__catch(...)
        -: 1271:	  {
        -: 1272:	    _M_result->_M_error = current_exception();
        -: 1273:	  }
        -: 1274:	return std::move(_M_result);
        -: 1275:      }
        -: 1276:      _Ptr_type&                _M_result;
        -: 1277:      std::function<void()>     _M_fn;
        -: 1278:    };
        -: 1279:
        -: 1280:  template<typename _Res, typename... _Args>
        -: 1281:    struct __future_base::_Task_state_base<_Res(_Args...)>
        -: 1282:    : __future_base::_State_base
        -: 1283:    {
        -: 1284:      typedef _Res _Res_type;
        -: 1285:
        -: 1286:      template<typename _Alloc>
        -: 1287:	_Task_state_base(const _Alloc& __a)
        -: 1288:	: _M_result(_S_allocate_result<_Res>(__a))
        -: 1289:	{ }
        -: 1290:
        -: 1291:      virtual void
        -: 1292:      _M_run(_Args... __args) = 0;
        -: 1293:
        -: 1294:      virtual shared_ptr<_Task_state_base>
        -: 1295:      _M_reset() = 0;
        -: 1296:
        -: 1297:      typedef __future_base::_Ptr<_Result<_Res>> _Ptr_type;
        -: 1298:      _Ptr_type _M_result;
        -: 1299:    };
        -: 1300:
        -: 1301:  template<typename _Fn, typename _Alloc, typename _Res, typename... _Args>
        -: 1302:    struct __future_base::_Task_state<_Fn, _Alloc, _Res(_Args...)> final
        -: 1303:    : __future_base::_Task_state_base<_Res(_Args...)>
        -: 1304:    {
        -: 1305:      template<typename _Fn2>
        -: 1306:	_Task_state(_Fn2&& __fn, const _Alloc& __a)
        -: 1307:	: _Task_state_base<_Res(_Args...)>(__a),
        -: 1308:	  _M_impl(std::forward<_Fn2>(__fn), __a)
        -: 1309:	{ }
        -: 1310:
        -: 1311:    private:
        -: 1312:      virtual void
        -: 1313:      _M_run(_Args... __args)
        -: 1314:      {
        -: 1315:	// bound arguments decay so wrap lvalue references
        -: 1316:	auto __boundfn = std::__bind_simple(std::ref(_M_impl._M_fn),
        -: 1317:	    _S_maybe_wrap_ref(std::forward<_Args>(__args))...);
        -: 1318:	auto __setter = _S_task_setter(this->_M_result, std::move(__boundfn));
        -: 1319:	this->_M_set_result(std::move(__setter));
        -: 1320:      }
        -: 1321:
        -: 1322:      virtual shared_ptr<_Task_state_base<_Res(_Args...)>>
        -: 1323:      _M_reset();
        -: 1324:
        -: 1325:      template<typename _Tp>
        -: 1326:	static reference_wrapper<_Tp>
        -: 1327:	_S_maybe_wrap_ref(_Tp& __t)
        -: 1328:	{ return std::ref(__t); }
        -: 1329:
        -: 1330:      template<typename _Tp>
        -: 1331:	static
        -: 1332:	typename enable_if<!is_lvalue_reference<_Tp>::value, _Tp>::type&&
        -: 1333:	_S_maybe_wrap_ref(_Tp&& __t)
        -: 1334:	{ return std::forward<_Tp>(__t); }
        -: 1335:
        -: 1336:      struct _Impl : _Alloc
        -: 1337:      {
        -: 1338:	template<typename _Fn2>
        -: 1339:	  _Impl(_Fn2&& __fn, const _Alloc& __a)
        -: 1340:	  : _Alloc(__a), _M_fn(std::forward<_Fn2>(__fn)) { }
        -: 1341:	_Fn _M_fn;
        -: 1342:      } _M_impl;
        -: 1343:    };
        -: 1344:
        -: 1345:  template<typename _Signature, typename _Fn, typename _Alloc>
        -: 1346:    static shared_ptr<__future_base::_Task_state_base<_Signature>>
        -: 1347:    __create_task_state(_Fn&& __fn, const _Alloc& __a)
        -: 1348:    {
        -: 1349:      typedef typename decay<_Fn>::type _Fn2;
        -: 1350:      typedef __future_base::_Task_state<_Fn2, _Alloc, _Signature> _State;
        -: 1351:      return std::allocate_shared<_State>(__a, std::forward<_Fn>(__fn), __a);
        -: 1352:    }
        -: 1353:
        -: 1354:  template<typename _Fn, typename _Alloc, typename _Res, typename... _Args>
        -: 1355:    shared_ptr<__future_base::_Task_state_base<_Res(_Args...)>>
        -: 1356:    __future_base::_Task_state<_Fn, _Alloc, _Res(_Args...)>::_M_reset()
        -: 1357:    {
        -: 1358:      return __create_task_state<_Res(_Args...)>(std::move(_M_impl._M_fn),
        -: 1359:						 static_cast<_Alloc&>(_M_impl));
        -: 1360:    }
        -: 1361:
        -: 1362:  template<typename _Task, typename _Fn, bool
        -: 1363:	   = is_same<_Task, typename decay<_Fn>::type>::value>
        -: 1364:    struct __constrain_pkgdtask
        -: 1365:    { typedef void __type; };
        -: 1366:
        -: 1367:  template<typename _Task, typename _Fn>
        -: 1368:    struct __constrain_pkgdtask<_Task, _Fn, true>
        -: 1369:    { };
        -: 1370:
        -: 1371:  /// packaged_task
        -: 1372:  template<typename _Res, typename... _ArgTypes>
        -: 1373:    class packaged_task<_Res(_ArgTypes...)>
        -: 1374:    {
        -: 1375:      typedef __future_base::_Task_state_base<_Res(_ArgTypes...)> _State_type;
        -: 1376:      shared_ptr<_State_type>                   _M_state;
        -: 1377:
        -: 1378:    public:
        -: 1379:      // Construction and destruction
        -: 1380:      packaged_task() noexcept { }
        -: 1381:
        -: 1382:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
        -: 1383:      // 2095.  missing constructors needed for uses-allocator construction
        -: 1384:      template<typename _Allocator>
        -: 1385:	packaged_task(allocator_arg_t, const _Allocator& __a) noexcept
        -: 1386:	{ }
        -: 1387:
        -: 1388:      template<typename _Fn, typename = typename
        -: 1389:	       __constrain_pkgdtask<packaged_task, _Fn>::__type>
        -: 1390:	explicit
        -: 1391:	packaged_task(_Fn&& __fn)
        -: 1392:	: packaged_task(allocator_arg, std::allocator<int>(),
        -: 1393:			std::forward<_Fn>(__fn))
        -: 1394:	{ }
        -: 1395:
        -: 1396:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
        -: 1397:      // 2097.  packaged_task constructors should be constrained
        -: 1398:      template<typename _Fn, typename _Alloc, typename = typename
        -: 1399:	       __constrain_pkgdtask<packaged_task, _Fn>::__type>
        -: 1400:	explicit
        -: 1401:	packaged_task(allocator_arg_t, const _Alloc& __a, _Fn&& __fn)
        -: 1402:	: _M_state(__create_task_state<_Res(_ArgTypes...)>(
        -: 1403:		    std::forward<_Fn>(__fn), __a))
        -: 1404:	{ }
        -: 1405:
        -: 1406:      ~packaged_task()
        -: 1407:      {
        -: 1408:        if (static_cast<bool>(_M_state) && !_M_state.unique())
        -: 1409:	  _M_state->_M_break_promise(std::move(_M_state->_M_result));
        -: 1410:      }
        -: 1411:
        -: 1412:      // No copy
        -: 1413:      packaged_task(const packaged_task&) = delete;
        -: 1414:      packaged_task& operator=(const packaged_task&) = delete;
        -: 1415:
        -: 1416:      template<typename _Allocator>
        -: 1417:	packaged_task(allocator_arg_t, const _Allocator&,
        -: 1418:		      const packaged_task&) = delete;
        -: 1419:
        -: 1420:      // Move support
        -: 1421:      packaged_task(packaged_task&& __other) noexcept
        -: 1422:      { this->swap(__other); }
        -: 1423:
        -: 1424:      template<typename _Allocator>
        -: 1425:	packaged_task(allocator_arg_t, const _Allocator&,
        -: 1426:		      packaged_task&& __other) noexcept
        -: 1427:	{ this->swap(__other); }
        -: 1428:
        -: 1429:      packaged_task& operator=(packaged_task&& __other) noexcept
        -: 1430:      {
        -: 1431:	packaged_task(std::move(__other)).swap(*this);
        -: 1432:	return *this;
        -: 1433:      }
        -: 1434:
        -: 1435:      void
        -: 1436:      swap(packaged_task& __other) noexcept
        -: 1437:      { _M_state.swap(__other._M_state); }
        -: 1438:
        -: 1439:      bool
        -: 1440:      valid() const noexcept
        -: 1441:      { return static_cast<bool>(_M_state); }
        -: 1442:
        -: 1443:      // Result retrieval
        -: 1444:      future<_Res>
        -: 1445:      get_future()
        -: 1446:      { return future<_Res>(_M_state); }
        -: 1447:
        -: 1448:      // Execution
        -: 1449:      void
        -: 1450:      operator()(_ArgTypes... __args)
        -: 1451:      {
        -: 1452:	__future_base::_State_base::_S_check(_M_state);
        -: 1453:	_M_state->_M_run(std::forward<_ArgTypes>(__args)...);
        -: 1454:      }
        -: 1455:
        -: 1456:      void
        -: 1457:      reset()
        -: 1458:      {
        -: 1459:	__future_base::_State_base::_S_check(_M_state);
        -: 1460:	packaged_task __tmp;
        -: 1461:	__tmp._M_state = _M_state;
        -: 1462:	_M_state = _M_state->_M_reset();
        -: 1463:      }
        -: 1464:    };
        -: 1465:
        -: 1466:  /// swap
        -: 1467:  template<typename _Res, typename... _ArgTypes>
        -: 1468:    inline void
        -: 1469:    swap(packaged_task<_Res(_ArgTypes...)>& __x,
        -: 1470:	 packaged_task<_Res(_ArgTypes...)>& __y) noexcept
        -: 1471:    { __x.swap(__y); }
        -: 1472:
        -: 1473:  template<typename _Res, typename _Alloc>
        -: 1474:    struct uses_allocator<packaged_task<_Res>, _Alloc>
        -: 1475:    : public true_type { };
        -: 1476:
        -: 1477:
        -: 1478:  template<typename _BoundFn, typename _Res>
        -: 1479:    class __future_base::_Deferred_state final
        -: 1480:    : public __future_base::_State_base
        -: 1481:    {
        -: 1482:    public:
        -: 1483:      explicit
        -: 1484:      _Deferred_state(_BoundFn&& __fn)
        -: 1485:      : _M_result(new _Result<_Res>()), _M_fn(std::move(__fn))
        -: 1486:      { }
        -: 1487:
        -: 1488:    private:
        -: 1489:      typedef __future_base::_Ptr<_Result<_Res>> _Ptr_type;
        -: 1490:      _Ptr_type _M_result;
        -: 1491:      _BoundFn _M_fn;
        -: 1492:
        -: 1493:      // Run the deferred function.
        -: 1494:      virtual void
        -: 1495:      _M_complete_async()
        -: 1496:      {
        -: 1497:        // safe to call multiple times so ignore failure
        -: 1498:        _M_set_result(_S_task_setter(_M_result, _M_fn), true);
        -: 1499:      }
        -: 1500:
        -: 1501:      virtual bool
        -: 1502:      _M_has_deferred() const { return static_cast<bool>(_M_result); }
        -: 1503:    };
        -: 1504:
        -: 1505:  class __future_base::_Async_state_commonV2
        -: 1506:    : public __future_base::_State_base
        -: 1507:  {
        -: 1508:  protected:
        -: 1509:    ~_Async_state_commonV2() = default;
        -: 1510:
        -: 1511:    // Make waiting functions block until the thread completes, as if joined.
        -: 1512:    virtual void _M_complete_async() { _M_join(); }
        -: 1513:
        -: 1514:    void _M_join() { std::call_once(_M_once, &thread::join, ref(_M_thread)); }
        -: 1515:
        -: 1516:    thread _M_thread;
        -: 1517:    once_flag _M_once;
        -: 1518:  };
        -: 1519:
        -: 1520:  template<typename _BoundFn, typename _Res>
        -: 1521:    class __future_base::_Async_state_impl final
        -: 1522:    : public __future_base::_Async_state_commonV2
        -: 1523:    {
        -: 1524:    public:
        -: 1525:      explicit
        -: 1526:      _Async_state_impl(_BoundFn&& __fn)
        -: 1527:      : _M_result(new _Result<_Res>()), _M_fn(std::move(__fn))
        -: 1528:      {
        -: 1529:	_M_thread = std::thread{ [this] {
        -: 1530:	    __try
        -: 1531:	      {
        -: 1532:		_M_set_result(_S_task_setter(_M_result, _M_fn));
        -: 1533:	      }
        -: 1534:	    __catch (const __cxxabiv1::__forced_unwind&)
        -: 1535:	      {
        -: 1536:		// make the shared state ready on thread cancellation
        -: 1537:		if (static_cast<bool>(_M_result))
        -: 1538:		  this->_M_break_promise(std::move(_M_result));
        -: 1539:		__throw_exception_again;
        -: 1540:	      }
        -: 1541:        } };
        -: 1542:      }
        -: 1543:
        -: 1544:      ~_Async_state_impl() { _M_join(); }
        -: 1545:
        -: 1546:    private:
        -: 1547:      typedef __future_base::_Ptr<_Result<_Res>> _Ptr_type;
        -: 1548:      _Ptr_type _M_result;
        -: 1549:      _BoundFn _M_fn;
        -: 1550:    };
        -: 1551:
        -: 1552:  template<typename _BoundFn>
        -: 1553:    inline std::shared_ptr<__future_base::_State_base>
        -: 1554:    __future_base::_S_make_deferred_state(_BoundFn&& __fn)
        -: 1555:    {
        -: 1556:      typedef typename remove_reference<_BoundFn>::type __fn_type;
        -: 1557:      typedef _Deferred_state<__fn_type> __state_type;
        -: 1558:      return std::make_shared<__state_type>(std::move(__fn));
        -: 1559:    }
        -: 1560:
        -: 1561:  template<typename _BoundFn>
        -: 1562:    inline std::shared_ptr<__future_base::_State_base>
        -: 1563:    __future_base::_S_make_async_state(_BoundFn&& __fn)
        -: 1564:    {
        -: 1565:      typedef typename remove_reference<_BoundFn>::type __fn_type;
        -: 1566:      typedef _Async_state_impl<__fn_type> __state_type;
        -: 1567:      return std::make_shared<__state_type>(std::move(__fn));
        -: 1568:    }
        -: 1569:
        -: 1570:
        -: 1571:  /// async
        -: 1572:  template<typename _Fn, typename... _Args>
        -: 1573:    future<typename result_of<_Fn(_Args...)>::type>
        -: 1574:    async(launch __policy, _Fn&& __fn, _Args&&... __args)
        -: 1575:    {
        -: 1576:      typedef typename result_of<_Fn(_Args...)>::type result_type;
        -: 1577:      std::shared_ptr<__future_base::_State_base> __state;
        -: 1578:      if ((__policy & (launch::async|launch::deferred)) == launch::async)
        -: 1579:	{
        -: 1580:	  __state = __future_base::_S_make_async_state(std::__bind_simple(
        -: 1581:              std::forward<_Fn>(__fn), std::forward<_Args>(__args)...));
        -: 1582:	}
        -: 1583:      else
        -: 1584:	{
        -: 1585:	  __state = __future_base::_S_make_deferred_state(std::__bind_simple(
        -: 1586:              std::forward<_Fn>(__fn), std::forward<_Args>(__args)...));
        -: 1587:	}
        -: 1588:      return future<result_type>(__state);
        -: 1589:    }
        -: 1590:
        -: 1591:  /// async, potential overload
        -: 1592:  template<typename _Fn, typename... _Args>
        -: 1593:    inline future<typename result_of<_Fn(_Args...)>::type>
        -: 1594:    async(_Fn&& __fn, _Args&&... __args)
        -: 1595:    {
        -: 1596:      return async(launch::async|launch::deferred, std::forward<_Fn>(__fn),
        -: 1597:		   std::forward<_Args>(__args)...);
        -: 1598:    }
        -: 1599:
        -: 1600:#endif // _GLIBCXX_ASYNC_ABI_COMPAT
        -: 1601:#endif // _GLIBCXX_HAS_GTHREADS && _GLIBCXX_USE_C99_STDINT_TR1
        -: 1602:       // && ATOMIC_INT_LOCK_FREE
        -: 1603:
        -: 1604:  // @} group futures
        -: 1605:_GLIBCXX_END_NAMESPACE_VERSION
        -: 1606:} // namespace
        -: 1607:
        -: 1608:#endif // C++11
        -: 1609:
        -: 1610:#endif // _GLIBCXX_FUTURE
