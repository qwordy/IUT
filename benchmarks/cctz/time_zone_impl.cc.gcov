        -:    0:Source:src/time_zone_impl.cc
        -:    0:Graph:/home/yfy/iut/benchmarks/cctz/time_zone_impl.gcno
        -:    0:Data:/home/yfy/iut/benchmarks/cctz/time_zone_impl.gcda
        -:    0:Runs:27
        -:    0:Programs:1
        -:    1:// Copyright 2016 Google Inc. All Rights Reserved.
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://   http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9://   Unless required by applicable law or agreed to in writing, software
        -:   10://   distributed under the License is distributed on an "AS IS" BASIS,
        -:   11://   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12://   See the License for the specific language governing permissions and
        -:   13://   limitations under the License.
        -:   14:
        -:   15:#include "time_zone_impl.h"
        -:   16:
        -:   17:#include <map>
        -:   18:#include <mutex>
        -:   19:
        -:   20:namespace cctz {
        -:   21:
        -:   22:namespace {
        -:   23:
        -:   24:// time_zone::Impls are linked into a map to support fast lookup by name.
        -:   25:typedef std::map<std::string, const time_zone::Impl*> TimeZoneImplByName;
        -:   26:TimeZoneImplByName* time_zone_map = nullptr;
        -:   27:
        -:   28:// Mutual exclusion for time_zone_map.
        -:   29:std::mutex time_zone_mutex;
        -:   30:
        -:   31:// The utc_time_zone(). Also used for time zones that fail to load.
        -:   32:const time_zone::Impl* utc_zone = nullptr;
        -:   33:
        -:   34:// utc_zone should only be referenced in a thread that has just done
        -:   35:// a LoadUTCTimeZone().
        -:   36:std::once_flag load_utc_once;
function _ZN4cctz12_GLOBAL__N_115LoadUTCTimeZoneEv called 607 returned 100% blocks executed 100%
      607:   37:void LoadUTCTimeZone() {
      625:   38:  std::call_once(load_utc_once, []() { utc_time_zone(); });
call    0 returned 100%
call    1 returned 100%
      607:   39:}
        -:   40:
        -:   41:}  // namespace
        -:   42:
function _ZN4cctz9time_zone4Impl12LoadTimeZoneERKSsPS0_ called 144423 returned 99% blocks executed 82%
   144423:   43:bool time_zone::Impl::LoadTimeZone(const std::string& name, time_zone* tz) {
   144423:   44:  const bool is_utc = (name.compare("UTC") == 0);
call    0 returned 99%
        -:   45:
        -:   46:  // First check, under a shared lock, whether the time zone has already
        -:   47:  // been loaded. This is the common path. TODO: Move to shared_mutex.
        -:   48:  {
        -:   49:    std::lock_guard<std::mutex> lock(time_zone_mutex);
   149045:   50:    if (time_zone_map != nullptr) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:   51:      TimeZoneImplByName::const_iterator itr = time_zone_map->find(name);
   298002:   52:      if (itr != time_zone_map->end()) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
   148413:   53:        *tz = time_zone(itr->second);
   148413:   54:        return is_utc || itr->second != utc_zone;
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
        -:   55:      }
        -:   56:    }
        -:   57:  }
        -:   58:
      632:   59:  if (!is_utc) {
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
        -:   60:    // Ensure that UTC is loaded before any other time zones.
      607:   61:    LoadUTCTimeZone();
call    0 returned 100%
        -:   62:  }
        -:   63:
        -:   64:  // Now check again, under an exclusive lock.
        -:   65:  std::lock_guard<std::mutex> lock(time_zone_mutex);
      657:   66:  if (time_zone_map == nullptr) time_zone_map = new TimeZoneImplByName;
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
      632:   67:  const time_zone::Impl*& impl = (*time_zone_map)[name];
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:   68:  bool fallback_utc = false;
      632:   69:  if (impl == nullptr) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:   70:    // The first thread in loads the new time zone.
      627:   71:    time_zone::Impl* new_impl = new time_zone::Impl(name);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 never executed
     1254:   72:    new_impl->zone_ = TimeZoneIf::Load(new_impl->name_);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
      627:   73:    if (new_impl->zone_ == nullptr) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        3:   74:      delete new_impl;  // free the nascent time_zone::Impl
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
        3:   75:      impl = utc_zone;  // and fallback to UTC
        -:   76:      fallback_utc = true;
        -:   77:    } else {
      624:   78:      if (is_utc) {
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        -:   79:        // Happens before any reference to utc_zone.
       25:   80:        utc_zone = new_impl;
        -:   81:      }
      624:   82:      impl = new_impl;  // install new time zone
        -:   83:    }
        -:   84:  }
      632:   85:  *tz = time_zone(impl);
      632:   86:  return !fallback_utc;
        -:   87:}
        -:   88:
function _ZN4cctz9time_zone4Impl3getERKS0_ called 128 returned 100% blocks executed 50%
      128:   89:const time_zone::Impl& time_zone::Impl::get(const time_zone& tz) {
      128:   90:  if (tz.impl_ == nullptr) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   91:    // Dereferencing an implicit-UTC time_zone is expected to be
        -:   92:    // rare, so we don't mind paying a small synchronization cost.
    #####:   93:    LoadUTCTimeZone();
call    0 never executed
    #####:   94:    return *utc_zone;
        -:   95:  }
        -:   96:  return *tz.impl_;
        -:   97:}
        -:   98:
function _ZN4cctz9time_zone4ImplC2ERKSs called 627 returned 100% blocks executed 100%
     1254:   99:time_zone::Impl::Impl(const std::string& name) : name_(name) {}
call    0 returned 100%
        -:  100:
function _ZNK4cctz9time_zone4Impl9BreakTimeERKNSt6chrono10time_pointINS2_3_V212system_clockENS2_8durationIlSt5ratioILl1ELl1EEEEEE called 85 returned 100% blocks executed 70%
       85:  101:time_zone::absolute_lookup time_zone::Impl::BreakTime(
        -:  102:    const time_point<sys_seconds>& tp) const {
        -:  103:  time_zone::absolute_lookup res;
       85:  104:  Breakdown bd = zone_->BreakTime(tp);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  105:  // TODO: Eliminate extra normalization.
        -:  106:  res.cs = civil_second(static_cast<int>(bd.year), bd.month, bd.day,
       85:  107:                        bd.hour, bd.minute, bd.second);
call    0 returned 100%
       85:  108:  res.offset = bd.offset;
       85:  109:  res.is_dst = bd.is_dst;
       85:  110:  res.abbr = bd.abbr;
       85:  111:  return res;
        -:  112:}
        -:  113:
function _ZNK4cctz9time_zone4Impl12MakeTimeInfoENS_6detail10civil_timeINS2_10second_tagEEE called 43 returned 100% blocks executed 100%
       43:  114:time_zone::civil_lookup time_zone::Impl::MakeTimeInfo(civil_second cs) const {
        -:  115:  time_zone::civil_lookup res;
        -:  116:  // TODO: Eliminate extra normalization.
        -:  117:  TimeInfo t = zone_->MakeTimeInfo(cs.year(), cs.month(), cs.day(),
       86:  118:                                   cs.hour(), cs.minute(), cs.second());
call    0 returned 100%
       43:  119:  res.kind = t.kind;
       43:  120:  res.pre = t.pre;
       43:  121:  res.trans = t.trans;
       43:  122:  res.post = t.post;
       43:  123:  return res;
        -:  124:}
        -:  125:
        -:  126:}  // namespace cctz
