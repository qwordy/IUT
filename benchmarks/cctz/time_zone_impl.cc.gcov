        -:    0:Source:src/time_zone_impl.cc
        -:    0:Graph:/home/yfy/iut/benchmarks/cctz/time_zone_impl.gcno
        -:    0:Data:/home/yfy/iut/benchmarks/cctz/time_zone_impl.gcda
        -:    0:Runs:3
        -:    0:Programs:1
        -:    1:// Copyright 2016 Google Inc. All Rights Reserved.
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://   http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9://   Unless required by applicable law or agreed to in writing, software
        -:   10://   distributed under the License is distributed on an "AS IS" BASIS,
        -:   11://   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12://   See the License for the specific language governing permissions and
        -:   13://   limitations under the License.
        -:   14:
        -:   15:#include "time_zone_impl.h"
        -:   16:
        -:   17:#include <map>
        -:   18:#include <mutex>
        -:   19:
        -:   20:namespace cctz {
        -:   21:
        -:   22:namespace {
        -:   23:
        -:   24:// time_zone::Impls are linked into a map to support fast lookup by name.
        -:   25:typedef std::map<std::string, const time_zone::Impl*> TimeZoneImplByName;
        -:   26:TimeZoneImplByName* time_zone_map = nullptr;
        -:   27:
        -:   28:// Mutual exclusion for time_zone_map.
        -:   29:std::mutex time_zone_mutex;
        -:   30:
        -:   31:// The utc_time_zone(). Also used for time zones that fail to load.
        -:   32:const time_zone::Impl* utc_zone = nullptr;
        -:   33:
        -:   34:// utc_zone should only be referenced in a thread that has just done
        -:   35:// a LoadUTCTimeZone().
        -:   36:std::once_flag load_utc_once;
function _ZN4cctz12_GLOBAL__N_115LoadUTCTimeZoneEv called 1176 returned 100% blocks executed 100%
     1176:   37:void LoadUTCTimeZone() {
     1178:   38:  std::call_once(load_utc_once, []() { utc_time_zone(); });
call    0 returned 100%
call    1 returned 100%
     1176:   39:}
        -:   40:
        -:   41:}  // namespace
        -:   42:
function _ZN4cctz9time_zone4Impl12LoadTimeZoneERKSsPS0_ called 288760 returned 99% blocks executed 82%
   288760:   43:bool time_zone::Impl::LoadTimeZone(const std::string& name, time_zone* tz) {
   288760:   44:  const bool is_utc = (name.compare("UTC") == 0);
call    0 returned 99%
        -:   45:
        -:   46:  // First check, under a shared lock, whether the time zone has already
        -:   47:  // been loaded. This is the common path. TODO: Move to shared_mutex.
        -:   48:  {
        -:   49:    std::lock_guard<std::mutex> lock(time_zone_mutex);
   298056:   50:    if (time_zone_map != nullptr) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:   51:      TimeZoneImplByName::const_iterator itr = time_zone_map->find(name);
   596102:   52:      if (itr != time_zone_map->end()) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
   296878:   53:        *tz = time_zone(itr->second);
   296878:   54:        return is_utc || itr->second != utc_zone;
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
        -:   55:      }
        -:   56:    }
        -:   57:  }
        -:   58:
     1178:   59:  if (!is_utc) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:   60:    // Ensure that UTC is loaded before any other time zones.
     1176:   61:    LoadUTCTimeZone();
call    0 returned 100%
        -:   62:  }
        -:   63:
        -:   64:  // Now check again, under an exclusive lock.
        -:   65:  std::lock_guard<std::mutex> lock(time_zone_mutex);
     1180:   66:  if (time_zone_map == nullptr) time_zone_map = new TimeZoneImplByName;
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
     1178:   67:  const time_zone::Impl*& impl = (*time_zone_map)[name];
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:   68:  bool fallback_utc = false;
     1178:   69:  if (impl == nullptr) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:   70:    // The first thread in loads the new time zone.
     1170:   71:    time_zone::Impl* new_impl = new time_zone::Impl(name);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 never executed
     2340:   72:    new_impl->zone_ = TimeZoneIf::Load(new_impl->name_);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
     1170:   73:    if (new_impl->zone_ == nullptr) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        6:   74:      delete new_impl;  // free the nascent time_zone::Impl
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
        6:   75:      impl = utc_zone;  // and fallback to UTC
        -:   76:      fallback_utc = true;
        -:   77:    } else {
     1164:   78:      if (is_utc) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:   79:        // Happens before any reference to utc_zone.
        2:   80:        utc_zone = new_impl;
        -:   81:      }
     1164:   82:      impl = new_impl;  // install new time zone
        -:   83:    }
        -:   84:  }
     1178:   85:  *tz = time_zone(impl);
     1178:   86:  return !fallback_utc;
        -:   87:}
        -:   88:
function _ZN4cctz9time_zone4Impl3getERKS0_ called 256 returned 100% blocks executed 50%
      256:   89:const time_zone::Impl& time_zone::Impl::get(const time_zone& tz) {
      256:   90:  if (tz.impl_ == nullptr) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   91:    // Dereferencing an implicit-UTC time_zone is expected to be
        -:   92:    // rare, so we don't mind paying a small synchronization cost.
    #####:   93:    LoadUTCTimeZone();
call    0 never executed
    #####:   94:    return *utc_zone;
        -:   95:  }
        -:   96:  return *tz.impl_;
        -:   97:}
        -:   98:
function _ZN4cctz9time_zone4ImplC2ERKSs called 1170 returned 100% blocks executed 100%
     2340:   99:time_zone::Impl::Impl(const std::string& name) : name_(name) {}
call    0 returned 100%
        -:  100:
function _ZNK4cctz9time_zone4Impl9BreakTimeERKNSt6chrono10time_pointINS2_3_V212system_clockENS2_8durationIlSt5ratioILl1ELl1EEEEEE called 170 returned 100% blocks executed 70%
      170:  101:time_zone::absolute_lookup time_zone::Impl::BreakTime(
        -:  102:    const time_point<sys_seconds>& tp) const {
        -:  103:  time_zone::absolute_lookup res;
      170:  104:  Breakdown bd = zone_->BreakTime(tp);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  105:  // TODO: Eliminate extra normalization.
        -:  106:  res.cs = civil_second(static_cast<int>(bd.year), bd.month, bd.day,
      170:  107:                        bd.hour, bd.minute, bd.second);
call    0 returned 100%
      170:  108:  res.offset = bd.offset;
      170:  109:  res.is_dst = bd.is_dst;
      170:  110:  res.abbr = bd.abbr;
      170:  111:  return res;
        -:  112:}
        -:  113:
function _ZNK4cctz9time_zone4Impl12MakeTimeInfoENS_6detail10civil_timeINS2_10second_tagEEE called 86 returned 100% blocks executed 100%
       86:  114:time_zone::civil_lookup time_zone::Impl::MakeTimeInfo(civil_second cs) const {
        -:  115:  time_zone::civil_lookup res;
        -:  116:  // TODO: Eliminate extra normalization.
        -:  117:  TimeInfo t = zone_->MakeTimeInfo(cs.year(), cs.month(), cs.day(),
      172:  118:                                   cs.hour(), cs.minute(), cs.second());
call    0 returned 100%
       86:  119:  res.kind = t.kind;
       86:  120:  res.pre = t.pre;
       86:  121:  res.trans = t.trans;
       86:  122:  res.post = t.post;
       86:  123:  return res;
        -:  124:}
        -:  125:
        -:  126:}  // namespace cctz
