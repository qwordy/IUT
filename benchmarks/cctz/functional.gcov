        -:    0:Source:/usr/include/c++/4.9/functional
        -:    0:Graph:/home/yfy/iut/benchmarks/cctz/time_zone_impl.gcno
        -:    0:Data:/home/yfy/iut/benchmarks/cctz/time_zone_impl.gcda
        -:    0:Runs:19
        -:    0:Programs:1
        -:    1:// <functional> -*- C++ -*-
        -:    2:
        -:    3:// Copyright (C) 2001-2014 Free Software Foundation, Inc.
        -:    4://
        -:    5:// This file is part of the GNU ISO C++ Library.  This library is free
        -:    6:// software; you can redistribute it and/or modify it under the
        -:    7:// terms of the GNU General Public License as published by the
        -:    8:// Free Software Foundation; either version 3, or (at your option)
        -:    9:// any later version.
        -:   10:
        -:   11:// This library is distributed in the hope that it will be useful,
        -:   12:// but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   13:// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   14:// GNU General Public License for more details.
        -:   15:
        -:   16:// Under Section 7 of GPL version 3, you are granted additional
        -:   17:// permissions described in the GCC Runtime Library Exception, version
        -:   18:// 3.1, as published by the Free Software Foundation.
        -:   19:
        -:   20:// You should have received a copy of the GNU General Public License and
        -:   21:// a copy of the GCC Runtime Library Exception along with this program;
        -:   22:// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
        -:   23:// <http://www.gnu.org/licenses/>.
        -:   24:
        -:   25:/*
        -:   26: * Copyright (c) 1997
        -:   27: * Silicon Graphics Computer Systems, Inc.
        -:   28: *
        -:   29: * Permission to use, copy, modify, distribute and sell this software
        -:   30: * and its documentation for any purpose is hereby granted without fee,
        -:   31: * provided that the above copyright notice appear in all copies and
        -:   32: * that both that copyright notice and this permission notice appear
        -:   33: * in supporting documentation.  Silicon Graphics makes no
        -:   34: * representations about the suitability of this software for any
        -:   35: * purpose.  It is provided "as is" without express or implied warranty.
        -:   36: *
        -:   37: */
        -:   38:
        -:   39:/** @file include/functional
        -:   40: *  This is a Standard C++ Library header.
        -:   41: */
        -:   42:
        -:   43:#ifndef _GLIBCXX_FUNCTIONAL
        -:   44:#define _GLIBCXX_FUNCTIONAL 1
        -:   45:
        -:   46:#pragma GCC system_header
        -:   47:
        -:   48:#include <bits/c++config.h>
        -:   49:#include <bits/stl_function.h>
        -:   50:
        -:   51:#if __cplusplus >= 201103L
        -:   52:
        -:   53:#include <typeinfo>
        -:   54:#include <new>
        -:   55:#include <tuple>
        -:   56:#include <type_traits>
        -:   57:#include <bits/functexcept.h>
        -:   58:#include <bits/functional_hash.h>
        -:   59:
        -:   60:namespace std _GLIBCXX_VISIBILITY(default)
        -:   61:{
        -:   62:_GLIBCXX_BEGIN_NAMESPACE_VERSION
        -:   63:
        -:   64:  template<typename _MemberPointer>
        -:   65:    class _Mem_fn;
        -:   66:  template<typename _Tp, typename _Class>
        -:   67:    _Mem_fn<_Tp _Class::*>
        -:   68:    mem_fn(_Tp _Class::*) noexcept;
        -:   69:
        -:   70:_GLIBCXX_HAS_NESTED_TYPE(result_type)
        -:   71:
        -:   72:  /// If we have found a result_type, extract it.
        -:   73:  template<bool _Has_result_type, typename _Functor>
        -:   74:    struct _Maybe_get_result_type
        -:   75:    { };
        -:   76:
        -:   77:  template<typename _Functor>
        -:   78:    struct _Maybe_get_result_type<true, _Functor>
        -:   79:    { typedef typename _Functor::result_type result_type; };
        -:   80:
        -:   81:  /**
        -:   82:   *  Base class for any function object that has a weak result type, as
        -:   83:   *  defined in 3.3/3 of TR1.
        -:   84:  */
        -:   85:  template<typename _Functor>
        -:   86:    struct _Weak_result_type_impl
        -:   87:    : _Maybe_get_result_type<__has_result_type<_Functor>::value, _Functor>
        -:   88:    { };
        -:   89:
        -:   90:  /// Retrieve the result type for a function type.
        -:   91:  template<typename _Res, typename... _ArgTypes>
        -:   92:    struct _Weak_result_type_impl<_Res(_ArgTypes...)>
        -:   93:    { typedef _Res result_type; };
        -:   94:
        -:   95:  template<typename _Res, typename... _ArgTypes>
        -:   96:    struct _Weak_result_type_impl<_Res(_ArgTypes......)>
        -:   97:    { typedef _Res result_type; };
        -:   98:
        -:   99:  template<typename _Res, typename... _ArgTypes>
        -:  100:    struct _Weak_result_type_impl<_Res(_ArgTypes...) const>
        -:  101:    { typedef _Res result_type; };
        -:  102:
        -:  103:  template<typename _Res, typename... _ArgTypes>
        -:  104:    struct _Weak_result_type_impl<_Res(_ArgTypes......) const>
        -:  105:    { typedef _Res result_type; };
        -:  106:
        -:  107:  template<typename _Res, typename... _ArgTypes>
        -:  108:    struct _Weak_result_type_impl<_Res(_ArgTypes...) volatile>
        -:  109:    { typedef _Res result_type; };
        -:  110:
        -:  111:  template<typename _Res, typename... _ArgTypes>
        -:  112:    struct _Weak_result_type_impl<_Res(_ArgTypes......) volatile>
        -:  113:    { typedef _Res result_type; };
        -:  114:
        -:  115:  template<typename _Res, typename... _ArgTypes>
        -:  116:    struct _Weak_result_type_impl<_Res(_ArgTypes...) const volatile>
        -:  117:    { typedef _Res result_type; };
        -:  118:
        -:  119:  template<typename _Res, typename... _ArgTypes>
        -:  120:    struct _Weak_result_type_impl<_Res(_ArgTypes......) const volatile>
        -:  121:    { typedef _Res result_type; };
        -:  122:
        -:  123:  /// Retrieve the result type for a function reference.
        -:  124:  template<typename _Res, typename... _ArgTypes>
        -:  125:    struct _Weak_result_type_impl<_Res(&)(_ArgTypes...)>
        -:  126:    { typedef _Res result_type; };
        -:  127:
        -:  128:  template<typename _Res, typename... _ArgTypes>
        -:  129:    struct _Weak_result_type_impl<_Res(&)(_ArgTypes......)>
        -:  130:    { typedef _Res result_type; };
        -:  131:
        -:  132:  /// Retrieve the result type for a function pointer.
        -:  133:  template<typename _Res, typename... _ArgTypes>
        -:  134:    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...)>
        -:  135:    { typedef _Res result_type; };
        -:  136:
        -:  137:  template<typename _Res, typename... _ArgTypes>
        -:  138:    struct _Weak_result_type_impl<_Res(*)(_ArgTypes......)>
        -:  139:    { typedef _Res result_type; };
        -:  140:
        -:  141:  /// Retrieve result type for a member function pointer.
        -:  142:  template<typename _Res, typename _Class, typename... _ArgTypes>
        -:  143:    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)>
        -:  144:    { typedef _Res result_type; };
        -:  145:
        -:  146:  template<typename _Res, typename _Class, typename... _ArgTypes>
        -:  147:    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)>
        -:  148:    { typedef _Res result_type; };
        -:  149:
        -:  150:  /// Retrieve result type for a const member function pointer.
        -:  151:  template<typename _Res, typename _Class, typename... _ArgTypes>
        -:  152:    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) const>
        -:  153:    { typedef _Res result_type; };
        -:  154:
        -:  155:  template<typename _Res, typename _Class, typename... _ArgTypes>
        -:  156:    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) const>
        -:  157:    { typedef _Res result_type; };
        -:  158:
        -:  159:  /// Retrieve result type for a volatile member function pointer.
        -:  160:  template<typename _Res, typename _Class, typename... _ArgTypes>
        -:  161:    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) volatile>
        -:  162:    { typedef _Res result_type; };
        -:  163:
        -:  164:  template<typename _Res, typename _Class, typename... _ArgTypes>
        -:  165:    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) volatile>
        -:  166:    { typedef _Res result_type; };
        -:  167:
        -:  168:  /// Retrieve result type for a const volatile member function pointer.
        -:  169:  template<typename _Res, typename _Class, typename... _ArgTypes>
        -:  170:    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)
        -:  171:				  const volatile>
        -:  172:    { typedef _Res result_type; };
        -:  173:
        -:  174:  template<typename _Res, typename _Class, typename... _ArgTypes>
        -:  175:    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)
        -:  176:				  const volatile>
        -:  177:    { typedef _Res result_type; };
        -:  178:
        -:  179:  /**
        -:  180:   *  Strip top-level cv-qualifiers from the function object and let
        -:  181:   *  _Weak_result_type_impl perform the real work.
        -:  182:  */
        -:  183:  template<typename _Functor>
        -:  184:    struct _Weak_result_type
        -:  185:    : _Weak_result_type_impl<typename remove_cv<_Functor>::type>
        -:  186:    { };
        -:  187:
        -:  188:  /**
        -:  189:   * Invoke a function object, which may be either a member pointer or a
        -:  190:   * function object. The first parameter will tell which.
        -:  191:   */
        -:  192:  template<typename _Functor, typename... _Args>
        -:  193:    inline
        -:  194:    typename enable_if<
        -:  195:	     (!is_member_pointer<_Functor>::value
        -:  196:	      && !is_function<_Functor>::value
        -:  197:	      && !is_function<typename remove_pointer<_Functor>::type>::value),
        -:  198:	     typename result_of<_Functor&(_Args&&...)>::type
        -:  199:	   >::type
        -:  200:    __invoke(_Functor& __f, _Args&&... __args)
        -:  201:    {
        -:  202:      return __f(std::forward<_Args>(__args)...);
        -:  203:    }
        -:  204:
        -:  205:  template<typename _Functor, typename... _Args>
        -:  206:    inline
        -:  207:    typename enable_if<
        -:  208:             (is_member_pointer<_Functor>::value
        -:  209:              && !is_function<_Functor>::value
        -:  210:              && !is_function<typename remove_pointer<_Functor>::type>::value),
        -:  211:             typename result_of<_Functor(_Args&&...)>::type
        -:  212:           >::type
        -:  213:    __invoke(_Functor& __f, _Args&&... __args)
        -:  214:    {
        -:  215:      return std::mem_fn(__f)(std::forward<_Args>(__args)...);
        -:  216:    }
        -:  217:
        -:  218:  // To pick up function references (that will become function pointers)
        -:  219:  template<typename _Functor, typename... _Args>
        -:  220:    inline
        -:  221:    typename enable_if<
        -:  222:	     (is_pointer<_Functor>::value
        -:  223:	      && is_function<typename remove_pointer<_Functor>::type>::value),
        -:  224:	     typename result_of<_Functor(_Args&&...)>::type
        -:  225:	   >::type
        -:  226:    __invoke(_Functor __f, _Args&&... __args)
        -:  227:    {
        -:  228:      return __f(std::forward<_Args>(__args)...);
        -:  229:    }
        -:  230:
        -:  231:  /**
        -:  232:   *  Knowing which of unary_function and binary_function _Tp derives
        -:  233:   *  from, derives from the same and ensures that reference_wrapper
        -:  234:   *  will have a weak result type. See cases below.
        -:  235:   */
        -:  236:  template<bool _Unary, bool _Binary, typename _Tp>
        -:  237:    struct _Reference_wrapper_base_impl;
        -:  238:
        -:  239:  // None of the nested argument types.
        -:  240:  template<typename _Tp>
        -:  241:    struct _Reference_wrapper_base_impl<false, false, _Tp>
        -:  242:    : _Weak_result_type<_Tp>
        -:  243:    { };
        -:  244:
        -:  245:  // Nested argument_type only.
        -:  246:  template<typename _Tp>
        -:  247:    struct _Reference_wrapper_base_impl<true, false, _Tp>
        -:  248:    : _Weak_result_type<_Tp>
        -:  249:    {
        -:  250:      typedef typename _Tp::argument_type argument_type;
        -:  251:    };
        -:  252:
        -:  253:  // Nested first_argument_type and second_argument_type only.
        -:  254:  template<typename _Tp>
        -:  255:    struct _Reference_wrapper_base_impl<false, true, _Tp>
        -:  256:    : _Weak_result_type<_Tp>
        -:  257:    {
        -:  258:      typedef typename _Tp::first_argument_type first_argument_type;
        -:  259:      typedef typename _Tp::second_argument_type second_argument_type;
        -:  260:    };
        -:  261:
        -:  262:  // All the nested argument types.
        -:  263:   template<typename _Tp>
        -:  264:    struct _Reference_wrapper_base_impl<true, true, _Tp>
        -:  265:    : _Weak_result_type<_Tp>
        -:  266:    {
        -:  267:      typedef typename _Tp::argument_type argument_type;
        -:  268:      typedef typename _Tp::first_argument_type first_argument_type;
        -:  269:      typedef typename _Tp::second_argument_type second_argument_type;
        -:  270:    };
        -:  271:
        -:  272:  _GLIBCXX_HAS_NESTED_TYPE(argument_type)
        -:  273:  _GLIBCXX_HAS_NESTED_TYPE(first_argument_type)
        -:  274:  _GLIBCXX_HAS_NESTED_TYPE(second_argument_type)
        -:  275:
        -:  276:  /**
        -:  277:   *  Derives from unary_function or binary_function when it
        -:  278:   *  can. Specializations handle all of the easy cases. The primary
        -:  279:   *  template determines what to do with a class type, which may
        -:  280:   *  derive from both unary_function and binary_function.
        -:  281:  */
        -:  282:  template<typename _Tp>
        -:  283:    struct _Reference_wrapper_base
        -:  284:    : _Reference_wrapper_base_impl<
        -:  285:      __has_argument_type<_Tp>::value,
        -:  286:      __has_first_argument_type<_Tp>::value
        -:  287:      && __has_second_argument_type<_Tp>::value,
        -:  288:      _Tp>
        -:  289:    { };
        -:  290:
        -:  291:  // - a function type (unary)
        -:  292:  template<typename _Res, typename _T1>
        -:  293:    struct _Reference_wrapper_base<_Res(_T1)>
        -:  294:    : unary_function<_T1, _Res>
        -:  295:    { };
        -:  296:
        -:  297:  template<typename _Res, typename _T1>
        -:  298:    struct _Reference_wrapper_base<_Res(_T1) const>
        -:  299:    : unary_function<_T1, _Res>
        -:  300:    { };
        -:  301:
        -:  302:  template<typename _Res, typename _T1>
        -:  303:    struct _Reference_wrapper_base<_Res(_T1) volatile>
        -:  304:    : unary_function<_T1, _Res>
        -:  305:    { };
        -:  306:
        -:  307:  template<typename _Res, typename _T1>
        -:  308:    struct _Reference_wrapper_base<_Res(_T1) const volatile>
        -:  309:    : unary_function<_T1, _Res>
        -:  310:    { };
        -:  311:
        -:  312:  // - a function type (binary)
        -:  313:  template<typename _Res, typename _T1, typename _T2>
        -:  314:    struct _Reference_wrapper_base<_Res(_T1, _T2)>
        -:  315:    : binary_function<_T1, _T2, _Res>
        -:  316:    { };
        -:  317:
        -:  318:  template<typename _Res, typename _T1, typename _T2>
        -:  319:    struct _Reference_wrapper_base<_Res(_T1, _T2) const>
        -:  320:    : binary_function<_T1, _T2, _Res>
        -:  321:    { };
        -:  322:
        -:  323:  template<typename _Res, typename _T1, typename _T2>
        -:  324:    struct _Reference_wrapper_base<_Res(_T1, _T2) volatile>
        -:  325:    : binary_function<_T1, _T2, _Res>
        -:  326:    { };
        -:  327:
        -:  328:  template<typename _Res, typename _T1, typename _T2>
        -:  329:    struct _Reference_wrapper_base<_Res(_T1, _T2) const volatile>
        -:  330:    : binary_function<_T1, _T2, _Res>
        -:  331:    { };
        -:  332:
        -:  333:  // - a function pointer type (unary)
        -:  334:  template<typename _Res, typename _T1>
        -:  335:    struct _Reference_wrapper_base<_Res(*)(_T1)>
        -:  336:    : unary_function<_T1, _Res>
        -:  337:    { };
        -:  338:
        -:  339:  // - a function pointer type (binary)
        -:  340:  template<typename _Res, typename _T1, typename _T2>
        -:  341:    struct _Reference_wrapper_base<_Res(*)(_T1, _T2)>
        -:  342:    : binary_function<_T1, _T2, _Res>
        -:  343:    { };
        -:  344:
        -:  345:  // - a pointer to member function type (unary, no qualifiers)
        -:  346:  template<typename _Res, typename _T1>
        -:  347:    struct _Reference_wrapper_base<_Res (_T1::*)()>
        -:  348:    : unary_function<_T1*, _Res>
        -:  349:    { };
        -:  350:
        -:  351:  // - a pointer to member function type (binary, no qualifiers)
        -:  352:  template<typename _Res, typename _T1, typename _T2>
        -:  353:    struct _Reference_wrapper_base<_Res (_T1::*)(_T2)>
        -:  354:    : binary_function<_T1*, _T2, _Res>
        -:  355:    { };
        -:  356:
        -:  357:  // - a pointer to member function type (unary, const)
        -:  358:  template<typename _Res, typename _T1>
        -:  359:    struct _Reference_wrapper_base<_Res (_T1::*)() const>
        -:  360:    : unary_function<const _T1*, _Res>
        -:  361:    { };
        -:  362:
        -:  363:  // - a pointer to member function type (binary, const)
        -:  364:  template<typename _Res, typename _T1, typename _T2>
        -:  365:    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const>
        -:  366:    : binary_function<const _T1*, _T2, _Res>
        -:  367:    { };
        -:  368:
        -:  369:  // - a pointer to member function type (unary, volatile)
        -:  370:  template<typename _Res, typename _T1>
        -:  371:    struct _Reference_wrapper_base<_Res (_T1::*)() volatile>
        -:  372:    : unary_function<volatile _T1*, _Res>
        -:  373:    { };
        -:  374:
        -:  375:  // - a pointer to member function type (binary, volatile)
        -:  376:  template<typename _Res, typename _T1, typename _T2>
        -:  377:    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) volatile>
        -:  378:    : binary_function<volatile _T1*, _T2, _Res>
        -:  379:    { };
        -:  380:
        -:  381:  // - a pointer to member function type (unary, const volatile)
        -:  382:  template<typename _Res, typename _T1>
        -:  383:    struct _Reference_wrapper_base<_Res (_T1::*)() const volatile>
        -:  384:    : unary_function<const volatile _T1*, _Res>
        -:  385:    { };
        -:  386:
        -:  387:  // - a pointer to member function type (binary, const volatile)
        -:  388:  template<typename _Res, typename _T1, typename _T2>
        -:  389:    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const volatile>
        -:  390:    : binary_function<const volatile _T1*, _T2, _Res>
        -:  391:    { };
        -:  392:
        -:  393:  /**
        -:  394:   *  @brief Primary class template for reference_wrapper.
        -:  395:   *  @ingroup functors
        -:  396:   *  @{
        -:  397:   */
        -:  398:  template<typename _Tp>
        -:  399:    class reference_wrapper
        -:  400:    : public _Reference_wrapper_base<typename remove_cv<_Tp>::type>
        -:  401:    {
        -:  402:      _Tp* _M_data;
        -:  403:
        -:  404:    public:
        -:  405:      typedef _Tp type;
        -:  406:
        -:  407:      reference_wrapper(_Tp& __indata) noexcept
        -:  408:      : _M_data(std::__addressof(__indata))
        -:  409:      { }
        -:  410:
        -:  411:      reference_wrapper(_Tp&&) = delete;
        -:  412:
        -:  413:      reference_wrapper(const reference_wrapper<_Tp>& __inref) noexcept
        -:  414:      : _M_data(__inref._M_data)
        -:  415:      { }
        -:  416:
        -:  417:      reference_wrapper&
        -:  418:      operator=(const reference_wrapper<_Tp>& __inref) noexcept
        -:  419:      {
        -:  420:	_M_data = __inref._M_data;
        -:  421:	return *this;
        -:  422:      }
        -:  423:
        -:  424:      operator _Tp&() const noexcept
        -:  425:      { return this->get(); }
        -:  426:
        -:  427:      _Tp&
        -:  428:      get() const noexcept
        -:  429:      { return *_M_data; }
        -:  430:
        -:  431:      template<typename... _Args>
        -:  432:	typename result_of<_Tp&(_Args&&...)>::type
        -:  433:	operator()(_Args&&... __args) const
        -:  434:	{
        -:  435:	  return __invoke(get(), std::forward<_Args>(__args)...);
        -:  436:	}
        -:  437:    };
        -:  438:
        -:  439:
        -:  440:  /// Denotes a reference should be taken to a variable.
        -:  441:  template<typename _Tp>
        -:  442:    inline reference_wrapper<_Tp>
        -:  443:    ref(_Tp& __t) noexcept
        -:  444:    { return reference_wrapper<_Tp>(__t); }
        -:  445:
        -:  446:  /// Denotes a const reference should be taken to a variable.
        -:  447:  template<typename _Tp>
        -:  448:    inline reference_wrapper<const _Tp>
        -:  449:    cref(const _Tp& __t) noexcept
        -:  450:    { return reference_wrapper<const _Tp>(__t); }
        -:  451:
        -:  452:  template<typename _Tp>
        -:  453:    void ref(const _Tp&&) = delete;
        -:  454:
        -:  455:  template<typename _Tp>
        -:  456:    void cref(const _Tp&&) = delete;
        -:  457:
        -:  458:  /// Partial specialization.
        -:  459:  template<typename _Tp>
        -:  460:    inline reference_wrapper<_Tp>
        -:  461:    ref(reference_wrapper<_Tp> __t) noexcept
        -:  462:    { return ref(__t.get()); }
        -:  463:
        -:  464:  /// Partial specialization.
        -:  465:  template<typename _Tp>
        -:  466:    inline reference_wrapper<const _Tp>
        -:  467:    cref(reference_wrapper<_Tp> __t) noexcept
        -:  468:    { return cref(__t.get()); }
        -:  469:
        -:  470:  // @} group functors
        -:  471:
        -:  472:  template<typename... _Types>
        -:  473:    struct _Pack : integral_constant<size_t, sizeof...(_Types)>
        -:  474:    { };
        -:  475:
        -:  476:  template<typename _From, typename _To, bool = _From::value == _To::value>
        -:  477:    struct _AllConvertible : false_type
        -:  478:    { };
        -:  479:
        -:  480:  template<typename... _From, typename... _To>
        -:  481:    struct _AllConvertible<_Pack<_From...>, _Pack<_To...>, true>
        -:  482:    : __and_<is_convertible<_From, _To>...>
        -:  483:    { };
        -:  484:
        -:  485:  template<typename _Tp1, typename _Tp2>
        -:  486:    using _NotSame = __not_<is_same<typename std::decay<_Tp1>::type,
        -:  487:				    typename std::decay<_Tp2>::type>>;
        -:  488:
        -:  489:  /**
        -:  490:   * Derives from @c unary_function or @c binary_function, or perhaps
        -:  491:   * nothing, depending on the number of arguments provided. The
        -:  492:   * primary template is the basis case, which derives nothing.
        -:  493:   */
        -:  494:  template<typename _Res, typename... _ArgTypes>
        -:  495:    struct _Maybe_unary_or_binary_function { };
        -:  496:
        -:  497:  /// Derives from @c unary_function, as appropriate.
        -:  498:  template<typename _Res, typename _T1>
        -:  499:    struct _Maybe_unary_or_binary_function<_Res, _T1>
        -:  500:    : std::unary_function<_T1, _Res> { };
        -:  501:
        -:  502:  /// Derives from @c binary_function, as appropriate.
        -:  503:  template<typename _Res, typename _T1, typename _T2>
        -:  504:    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>
        -:  505:    : std::binary_function<_T1, _T2, _Res> { };
        -:  506:
        -:  507:  /// Implementation of @c mem_fn for member function pointers.
        -:  508:  template<typename _Res, typename _Class, typename... _ArgTypes>
        -:  509:    class _Mem_fn<_Res (_Class::*)(_ArgTypes...)>
        -:  510:    : public _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>
        -:  511:    {
        -:  512:      typedef _Res (_Class::*_Functor)(_ArgTypes...);
        -:  513:
        -:  514:      template<typename _Tp, typename... _Args>
        -:  515:	_Res
        -:  516:	_M_call(_Tp&& __object, const volatile _Class *,
        -:  517:		_Args&&... __args) const
        -:  518:	{
        -:  519:	  return (std::forward<_Tp>(__object).*__pmf)
        -:  520:	    (std::forward<_Args>(__args)...);
        -:  521:	}
        -:  522:
        -:  523:      template<typename _Tp, typename... _Args>
        -:  524:	_Res
        -:  525:	_M_call(_Tp&& __ptr, const volatile void *, _Args&&... __args) const
        -:  526:	{ return ((*__ptr).*__pmf)(std::forward<_Args>(__args)...); }
        -:  527:
        -:  528:      // Require each _Args to be convertible to corresponding _ArgTypes
        -:  529:      template<typename... _Args>
        -:  530:	using _RequireValidArgs
        -:  531:	  = _Require<_AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;
        -:  532:
        -:  533:      // Require each _Args to be convertible to corresponding _ArgTypes
        -:  534:      // and require _Tp is not _Class, _Class& or _Class*
        -:  535:      template<typename _Tp, typename... _Args>
        -:  536:	using _RequireValidArgs2
        -:  537:	  = _Require<_NotSame<_Class, _Tp>, _NotSame<_Class*, _Tp>,
        -:  538:		     _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;
        -:  539:
        -:  540:      // Require each _Args to be convertible to corresponding _ArgTypes
        -:  541:      // and require _Tp is _Class or derived from _Class
        -:  542:      template<typename _Tp, typename... _Args>
        -:  543:	using _RequireValidArgs3
        -:  544:	  = _Require<is_base_of<_Class, _Tp>,
        -:  545:		     _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;
        -:  546:
        -:  547:    public:
        -:  548:      typedef _Res result_type;
        -:  549:
        -:  550:      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }
        -:  551:
        -:  552:      // Handle objects
        -:  553:      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
        -:  554:	_Res
        -:  555:	operator()(_Class& __object, _Args&&... __args) const
        -:  556:	{ return (__object.*__pmf)(std::forward<_Args>(__args)...); }
        -:  557:
        -:  558:      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
        -:  559:	_Res
        -:  560:	operator()(_Class&& __object, _Args&&... __args) const
        -:  561:	{
        -:  562:	  return (std::move(__object).*__pmf)(std::forward<_Args>(__args)...);
        -:  563:	}
        -:  564:
        -:  565:      // Handle pointers
        -:  566:      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
        -:  567:	_Res
        -:  568:	operator()(_Class* __object, _Args&&... __args) const
        -:  569:	{ return (__object->*__pmf)(std::forward<_Args>(__args)...); }
        -:  570:
        -:  571:      // Handle smart pointers, references and pointers to derived
        -:  572:      template<typename _Tp, typename... _Args,
        -:  573:	       typename _Req = _RequireValidArgs2<_Tp, _Args...>>
        -:  574:	_Res
        -:  575:	operator()(_Tp&& __object, _Args&&... __args) const
        -:  576:	{
        -:  577:	  return _M_call(std::forward<_Tp>(__object), &__object,
        -:  578:	      std::forward<_Args>(__args)...);
        -:  579:	}
        -:  580:
        -:  581:      template<typename _Tp, typename... _Args,
        -:  582:	       typename _Req = _RequireValidArgs3<_Tp, _Args...>>
        -:  583:	_Res
        -:  584:	operator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const
        -:  585:	{ return operator()(__ref.get(), std::forward<_Args>(__args)...); }
        -:  586:
        -:  587:    private:
        -:  588:      _Functor __pmf;
        -:  589:    };
        -:  590:
        -:  591:  /// Implementation of @c mem_fn for const member function pointers.
        -:  592:  template<typename _Res, typename _Class, typename... _ArgTypes>
        -:  593:    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const>
        -:  594:    : public _Maybe_unary_or_binary_function<_Res, const _Class*,
        -:  595:					     _ArgTypes...>
        -:  596:    {
        -:  597:      typedef _Res (_Class::*_Functor)(_ArgTypes...) const;
        -:  598:
        -:  599:      template<typename _Tp, typename... _Args>
        -:  600:	_Res
        -:  601:	_M_call(_Tp&& __object, const volatile _Class *,
        -:  602:		_Args&&... __args) const
        -:  603:	{
        -:  604:	  return (std::forward<_Tp>(__object).*__pmf)
        -:  605:	    (std::forward<_Args>(__args)...);
        -:  606:	}
        -:  607:
        -:  608:      template<typename _Tp, typename... _Args>
        -:  609:	_Res
        -:  610:	_M_call(_Tp&& __ptr, const volatile void *, _Args&&... __args) const
        -:  611:	{ return ((*__ptr).*__pmf)(std::forward<_Args>(__args)...); }
        -:  612:
        -:  613:      template<typename... _Args>
        -:  614:	using _RequireValidArgs
        -:  615:	  = _Require<_AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;
        -:  616:
        -:  617:      template<typename _Tp, typename... _Args>
        -:  618:	using _RequireValidArgs2
        -:  619:	  = _Require<_NotSame<_Class, _Tp>, _NotSame<const _Class*, _Tp>,
        -:  620:		     _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;
        -:  621:
        -:  622:      template<typename _Tp, typename... _Args>
        -:  623:	using _RequireValidArgs3
        -:  624:	  = _Require<is_base_of<_Class, _Tp>,
        -:  625:		     _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;
        -:  626:
        -:  627:    public:
        -:  628:      typedef _Res result_type;
        -:  629:
        -:  630:      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }
        -:  631:
        -:  632:      // Handle objects
        -:  633:      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
        -:  634:	_Res
        -:  635:	operator()(const _Class& __object, _Args&&... __args) const
        -:  636:	{ return (__object.*__pmf)(std::forward<_Args>(__args)...); }
        -:  637:
        -:  638:      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
        -:  639:	_Res
        -:  640:	operator()(const _Class&& __object, _Args&&... __args) const
        -:  641:	{
        -:  642:	  return (std::move(__object).*__pmf)(std::forward<_Args>(__args)...);
        -:  643:	}
        -:  644:
        -:  645:      // Handle pointers
        -:  646:      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
        -:  647:	_Res
        -:  648:	operator()(const _Class* __object, _Args&&... __args) const
        -:  649:	{ return (__object->*__pmf)(std::forward<_Args>(__args)...); }
        -:  650:
        -:  651:      // Handle smart pointers, references and pointers to derived
        -:  652:      template<typename _Tp, typename... _Args,
        -:  653:	       typename _Req = _RequireValidArgs2<_Tp, _Args...>>
        -:  654:	_Res operator()(_Tp&& __object, _Args&&... __args) const
        -:  655:	{
        -:  656:	  return _M_call(std::forward<_Tp>(__object), &__object,
        -:  657:	      std::forward<_Args>(__args)...);
        -:  658:	}
        -:  659:
        -:  660:      template<typename _Tp, typename... _Args,
        -:  661:	       typename _Req = _RequireValidArgs3<_Tp, _Args...>>
        -:  662:	_Res
        -:  663:	operator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const
        -:  664:	{ return operator()(__ref.get(), std::forward<_Args>(__args)...); }
        -:  665:
        -:  666:    private:
        -:  667:      _Functor __pmf;
        -:  668:    };
        -:  669:
        -:  670:  /// Implementation of @c mem_fn for volatile member function pointers.
        -:  671:  template<typename _Res, typename _Class, typename... _ArgTypes>
        -:  672:    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) volatile>
        -:  673:    : public _Maybe_unary_or_binary_function<_Res, volatile _Class*,
        -:  674:					     _ArgTypes...>
        -:  675:    {
        -:  676:      typedef _Res (_Class::*_Functor)(_ArgTypes...) volatile;
        -:  677:
        -:  678:      template<typename _Tp, typename... _Args>
        -:  679:	_Res
        -:  680:	_M_call(_Tp&& __object, const volatile _Class *,
        -:  681:		_Args&&... __args) const
        -:  682:	{
        -:  683:	  return (std::forward<_Tp>(__object).*__pmf)
        -:  684:	    (std::forward<_Args>(__args)...);
        -:  685:	}
        -:  686:
        -:  687:      template<typename _Tp, typename... _Args>
        -:  688:	_Res
        -:  689:	_M_call(_Tp&& __ptr, const volatile void *, _Args&&... __args) const
        -:  690:	{ return ((*__ptr).*__pmf)(std::forward<_Args>(__args)...); }
        -:  691:
        -:  692:      template<typename... _Args>
        -:  693:	using _RequireValidArgs
        -:  694:	  = _Require<_AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;
        -:  695:
        -:  696:      template<typename _Tp, typename... _Args>
        -:  697:	using _RequireValidArgs2
        -:  698:	  = _Require<_NotSame<_Class, _Tp>, _NotSame<volatile _Class*, _Tp>,
        -:  699:		     _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;
        -:  700:
        -:  701:      template<typename _Tp, typename... _Args>
        -:  702:	using _RequireValidArgs3
        -:  703:	  = _Require<is_base_of<_Class, _Tp>,
        -:  704:		     _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;
        -:  705:
        -:  706:    public:
        -:  707:      typedef _Res result_type;
        -:  708:
        -:  709:      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }
        -:  710:
        -:  711:      // Handle objects
        -:  712:      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
        -:  713:	_Res
        -:  714:	operator()(volatile _Class& __object, _Args&&... __args) const
        -:  715:	{ return (__object.*__pmf)(std::forward<_Args>(__args)...); }
        -:  716:
        -:  717:      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
        -:  718:	_Res
        -:  719:	operator()(volatile _Class&& __object, _Args&&... __args) const
        -:  720:	{
        -:  721:	  return (std::move(__object).*__pmf)(std::forward<_Args>(__args)...);
        -:  722:	}
        -:  723:
        -:  724:      // Handle pointers
        -:  725:      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
        -:  726:	_Res
        -:  727:	operator()(volatile _Class* __object, _Args&&... __args) const
        -:  728:	{ return (__object->*__pmf)(std::forward<_Args>(__args)...); }
        -:  729:
        -:  730:      // Handle smart pointers, references and pointers to derived
        -:  731:      template<typename _Tp, typename... _Args,
        -:  732:	       typename _Req = _RequireValidArgs2<_Tp, _Args...>>
        -:  733:	_Res
        -:  734:	operator()(_Tp&& __object, _Args&&... __args) const
        -:  735:	{
        -:  736:	  return _M_call(std::forward<_Tp>(__object), &__object,
        -:  737:	      std::forward<_Args>(__args)...);
        -:  738:	}
        -:  739:
        -:  740:      template<typename _Tp, typename... _Args,
        -:  741:	       typename _Req = _RequireValidArgs3<_Tp, _Args...>>
        -:  742:	_Res
        -:  743:	operator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const
        -:  744:	{ return operator()(__ref.get(), std::forward<_Args>(__args)...); }
        -:  745:
        -:  746:    private:
        -:  747:      _Functor __pmf;
        -:  748:    };
        -:  749:
        -:  750:  /// Implementation of @c mem_fn for const volatile member function pointers.
        -:  751:  template<typename _Res, typename _Class, typename... _ArgTypes>
        -:  752:    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const volatile>
        -:  753:    : public _Maybe_unary_or_binary_function<_Res, const volatile _Class*,
        -:  754:					     _ArgTypes...>
        -:  755:    {
        -:  756:      typedef _Res (_Class::*_Functor)(_ArgTypes...) const volatile;
        -:  757:
        -:  758:      template<typename _Tp, typename... _Args>
        -:  759:	_Res
        -:  760:	_M_call(_Tp&& __object, const volatile _Class *,
        -:  761:		_Args&&... __args) const
        -:  762:	{
        -:  763:	  return (std::forward<_Tp>(__object).*__pmf)
        -:  764:	    (std::forward<_Args>(__args)...);
        -:  765:	}
        -:  766:
        -:  767:      template<typename _Tp, typename... _Args>
        -:  768:	_Res
        -:  769:	_M_call(_Tp&& __ptr, const volatile void *, _Args&&... __args) const
        -:  770:	{ return ((*__ptr).*__pmf)(std::forward<_Args>(__args)...); }
        -:  771:
        -:  772:      template<typename... _Args>
        -:  773:	using _RequireValidArgs
        -:  774:	  = _Require<_AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;
        -:  775:
        -:  776:      template<typename _Tp, typename... _Args>
        -:  777:	using _RequireValidArgs2
        -:  778:	  = _Require<_NotSame<_Class, _Tp>,
        -:  779:		     _NotSame<const volatile _Class*, _Tp>,
        -:  780:		     _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;
        -:  781:
        -:  782:      template<typename _Tp, typename... _Args>
        -:  783:	using _RequireValidArgs3
        -:  784:	  = _Require<is_base_of<_Class, _Tp>,
        -:  785:		     _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;
        -:  786:
        -:  787:    public:
        -:  788:      typedef _Res result_type;
        -:  789:
        -:  790:      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }
        -:  791:
        -:  792:      // Handle objects
        -:  793:      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
        -:  794:	_Res
        -:  795:	operator()(const volatile _Class& __object, _Args&&... __args) const
        -:  796:	{ return (__object.*__pmf)(std::forward<_Args>(__args)...); }
        -:  797:
        -:  798:      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
        -:  799:	_Res
        -:  800:	operator()(const volatile _Class&& __object, _Args&&... __args) const
        -:  801:	{
        -:  802:	  return (std::move(__object).*__pmf)(std::forward<_Args>(__args)...);
        -:  803:	}
        -:  804:
        -:  805:      // Handle pointers
        -:  806:      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
        -:  807:	_Res
        -:  808:	operator()(const volatile _Class* __object, _Args&&... __args) const
        -:  809:	{ return (__object->*__pmf)(std::forward<_Args>(__args)...); }
        -:  810:
        -:  811:      // Handle smart pointers, references and pointers to derived
        -:  812:      template<typename _Tp, typename... _Args,
        -:  813:	       typename _Req = _RequireValidArgs2<_Tp, _Args...>>
        -:  814:	_Res operator()(_Tp&& __object, _Args&&... __args) const
        -:  815:	{
        -:  816:	  return _M_call(std::forward<_Tp>(__object), &__object,
        -:  817:	      std::forward<_Args>(__args)...);
        -:  818:	}
        -:  819:
        -:  820:      template<typename _Tp, typename... _Args,
        -:  821:	       typename _Req = _RequireValidArgs3<_Tp, _Args...>>
        -:  822:	_Res
        -:  823:	operator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const
        -:  824:	{ return operator()(__ref.get(), std::forward<_Args>(__args)...); }
        -:  825:
        -:  826:    private:
        -:  827:      _Functor __pmf;
        -:  828:    };
        -:  829:
        -:  830:
        -:  831:  template<typename _Tp, bool>
        -:  832:    struct _Mem_fn_const_or_non
        -:  833:    {
        -:  834:      typedef const _Tp& type;
        -:  835:    };
        -:  836:
        -:  837:  template<typename _Tp>
        -:  838:    struct _Mem_fn_const_or_non<_Tp, false>
        -:  839:    {
        -:  840:      typedef _Tp& type;
        -:  841:    };
        -:  842:
        -:  843:  template<typename _Res, typename _Class>
        -:  844:    class _Mem_fn<_Res _Class::*>
        -:  845:    {
        -:  846:      using __pm_type = _Res _Class::*;
        -:  847:
        -:  848:      // This bit of genius is due to Peter Dimov, improved slightly by
        -:  849:      // Douglas Gregor.
        -:  850:      // Made less elegant to support perfect forwarding and noexcept.
        -:  851:      template<typename _Tp>
        -:  852:	auto
        -:  853:	_M_call(_Tp&& __object, const _Class *) const noexcept
        -:  854:	-> decltype(std::forward<_Tp>(__object).*std::declval<__pm_type&>())
        -:  855:	{ return std::forward<_Tp>(__object).*__pm; }
        -:  856:
        -:  857:      template<typename _Tp, typename _Up>
        -:  858:	auto
        -:  859:	_M_call(_Tp&& __object, _Up * const *) const noexcept
        -:  860:	-> decltype((*std::forward<_Tp>(__object)).*std::declval<__pm_type&>())
        -:  861:	{ return (*std::forward<_Tp>(__object)).*__pm; }
        -:  862:
        -:  863:      template<typename _Tp>
        -:  864:	auto
        -:  865:	_M_call(_Tp&& __ptr, const volatile void*) const
        -:  866:	noexcept(noexcept((*__ptr).*std::declval<__pm_type&>()))
        -:  867:	-> decltype((*__ptr).*std::declval<__pm_type&>())
        -:  868:	{ return (*__ptr).*__pm; }
        -:  869:
        -:  870:    public:
        -:  871:      explicit
        -:  872:      _Mem_fn(_Res _Class::*__pm) noexcept : __pm(__pm) { }
        -:  873:
        -:  874:      // Handle objects
        -:  875:      _Res&
        -:  876:      operator()(_Class& __object) const noexcept
        -:  877:      { return __object.*__pm; }
        -:  878:
        -:  879:      const _Res&
        -:  880:      operator()(const _Class& __object) const noexcept
        -:  881:      { return __object.*__pm; }
        -:  882:
        -:  883:      _Res&&
        -:  884:      operator()(_Class&& __object) const noexcept
        -:  885:      { return std::forward<_Class>(__object).*__pm; }
        -:  886:
        -:  887:      const _Res&&
        -:  888:      operator()(const _Class&& __object) const noexcept
        -:  889:      { return std::forward<const _Class>(__object).*__pm; }
        -:  890:
        -:  891:      // Handle pointers
        -:  892:      _Res&
        -:  893:      operator()(_Class* __object) const noexcept
        -:  894:      { return __object->*__pm; }
        -:  895:
        -:  896:      const _Res&
        -:  897:      operator()(const _Class* __object) const noexcept
        -:  898:      { return __object->*__pm; }
        -:  899:
        -:  900:      // Handle smart pointers and derived
        -:  901:      template<typename _Tp, typename _Req = _Require<_NotSame<_Class*, _Tp>>>
        -:  902:	auto
        -:  903:	operator()(_Tp&& __unknown) const
        -:  904:	noexcept(noexcept(std::declval<_Mem_fn*>()->_M_call
        -:  905:			  (std::forward<_Tp>(__unknown), &__unknown)))
        -:  906:	-> decltype(this->_M_call(std::forward<_Tp>(__unknown), &__unknown))
        -:  907:	{ return _M_call(std::forward<_Tp>(__unknown), &__unknown); }
        -:  908:
        -:  909:      template<typename _Tp, typename _Req = _Require<is_base_of<_Class, _Tp>>>
        -:  910:	auto
        -:  911:	operator()(reference_wrapper<_Tp> __ref) const
        -:  912:	noexcept(noexcept(std::declval<_Mem_fn&>()(__ref.get())))
        -:  913:	-> decltype((*this)(__ref.get()))
        -:  914:	{ return (*this)(__ref.get()); }
        -:  915:
        -:  916:    private:
        -:  917:      _Res _Class::*__pm;
        -:  918:    };
        -:  919:
        -:  920:  // _GLIBCXX_RESOLVE_LIB_DEFECTS
        -:  921:  // 2048.  Unnecessary mem_fn overloads
        -:  922:  /**
        -:  923:   *  @brief Returns a function object that forwards to the member
        -:  924:   *  pointer @a pm.
        -:  925:   *  @ingroup functors
        -:  926:   */
        -:  927:  template<typename _Tp, typename _Class>
        -:  928:    inline _Mem_fn<_Tp _Class::*>
        -:  929:    mem_fn(_Tp _Class::* __pm) noexcept
        -:  930:    {
        -:  931:      return _Mem_fn<_Tp _Class::*>(__pm);
        -:  932:    }
        -:  933:
        -:  934:  /**
        -:  935:   *  @brief Determines if the given type _Tp is a function object
        -:  936:   *  should be treated as a subexpression when evaluating calls to
        -:  937:   *  function objects returned by bind(). [TR1 3.6.1]
        -:  938:   *  @ingroup binders
        -:  939:   */
        -:  940:  template<typename _Tp>
        -:  941:    struct is_bind_expression
        -:  942:    : public false_type { };
        -:  943:
        -:  944:  /**
        -:  945:   *  @brief Determines if the given type _Tp is a placeholder in a
        -:  946:   *  bind() expression and, if so, which placeholder it is. [TR1 3.6.2]
        -:  947:   *  @ingroup binders
        -:  948:   */
        -:  949:  template<typename _Tp>
        -:  950:    struct is_placeholder
        -:  951:    : public integral_constant<int, 0>
        -:  952:    { };
        -:  953:
        -:  954:  /** @brief The type of placeholder objects defined by libstdc++.
        -:  955:   *  @ingroup binders
        -:  956:   */
        -:  957:  template<int _Num> struct _Placeholder { };
        -:  958:
        -:  959:  _GLIBCXX_END_NAMESPACE_VERSION
        -:  960:
        -:  961:  /** @namespace std::placeholders
        -:  962:   *  @brief ISO C++11 entities sub-namespace for functional.
        -:  963:   *  @ingroup binders
        -:  964:   */
        -:  965:  namespace placeholders
        -:  966:  {
        -:  967:  _GLIBCXX_BEGIN_NAMESPACE_VERSION
        -:  968:  /* Define a large number of placeholders. There is no way to
        -:  969:   * simplify this with variadic templates, because we're introducing
        -:  970:   * unique names for each.
        -:  971:   */
        -:  972:    extern const _Placeholder<1> _1;
        -:  973:    extern const _Placeholder<2> _2;
        -:  974:    extern const _Placeholder<3> _3;
        -:  975:    extern const _Placeholder<4> _4;
        -:  976:    extern const _Placeholder<5> _5;
        -:  977:    extern const _Placeholder<6> _6;
        -:  978:    extern const _Placeholder<7> _7;
        -:  979:    extern const _Placeholder<8> _8;
        -:  980:    extern const _Placeholder<9> _9;
        -:  981:    extern const _Placeholder<10> _10;
        -:  982:    extern const _Placeholder<11> _11;
        -:  983:    extern const _Placeholder<12> _12;
        -:  984:    extern const _Placeholder<13> _13;
        -:  985:    extern const _Placeholder<14> _14;
        -:  986:    extern const _Placeholder<15> _15;
        -:  987:    extern const _Placeholder<16> _16;
        -:  988:    extern const _Placeholder<17> _17;
        -:  989:    extern const _Placeholder<18> _18;
        -:  990:    extern const _Placeholder<19> _19;
        -:  991:    extern const _Placeholder<20> _20;
        -:  992:    extern const _Placeholder<21> _21;
        -:  993:    extern const _Placeholder<22> _22;
        -:  994:    extern const _Placeholder<23> _23;
        -:  995:    extern const _Placeholder<24> _24;
        -:  996:    extern const _Placeholder<25> _25;
        -:  997:    extern const _Placeholder<26> _26;
        -:  998:    extern const _Placeholder<27> _27;
        -:  999:    extern const _Placeholder<28> _28;
        -: 1000:    extern const _Placeholder<29> _29;
        -: 1001:  _GLIBCXX_END_NAMESPACE_VERSION
        -: 1002:  }
        -: 1003:
        -: 1004:  _GLIBCXX_BEGIN_NAMESPACE_VERSION
        -: 1005:
        -: 1006:  /**
        -: 1007:   *  Partial specialization of is_placeholder that provides the placeholder
        -: 1008:   *  number for the placeholder objects defined by libstdc++.
        -: 1009:   *  @ingroup binders
        -: 1010:   */
        -: 1011:  template<int _Num>
        -: 1012:    struct is_placeholder<_Placeholder<_Num> >
        -: 1013:    : public integral_constant<int, _Num>
        -: 1014:    { };
        -: 1015:
        -: 1016:  template<int _Num>
        -: 1017:    struct is_placeholder<const _Placeholder<_Num> >
        -: 1018:    : public integral_constant<int, _Num>
        -: 1019:    { };
        -: 1020:
        -: 1021:  /**
        -: 1022:   * Used by _Safe_tuple_element to indicate that there is no tuple
        -: 1023:   * element at this position.
        -: 1024:   */
        -: 1025:  struct _No_tuple_element;
        -: 1026:
        -: 1027:  /**
        -: 1028:   * Implementation helper for _Safe_tuple_element. This primary
        -: 1029:   * template handles the case where it is safe to use @c
        -: 1030:   * tuple_element.
        -: 1031:   */
        -: 1032:  template<std::size_t __i, typename _Tuple, bool _IsSafe>
        -: 1033:    struct _Safe_tuple_element_impl
        -: 1034:    : tuple_element<__i, _Tuple> { };
        -: 1035:
        -: 1036:  /**
        -: 1037:   * Implementation helper for _Safe_tuple_element. This partial
        -: 1038:   * specialization handles the case where it is not safe to use @c
        -: 1039:   * tuple_element. We just return @c _No_tuple_element.
        -: 1040:   */
        -: 1041:  template<std::size_t __i, typename _Tuple>
        -: 1042:    struct _Safe_tuple_element_impl<__i, _Tuple, false>
        -: 1043:    {
        -: 1044:      typedef _No_tuple_element type;
        -: 1045:    };
        -: 1046:
        -: 1047:  /**
        -: 1048:   * Like tuple_element, but returns @c _No_tuple_element when
        -: 1049:   * tuple_element would return an error.
        -: 1050:   */
        -: 1051: template<std::size_t __i, typename _Tuple>
        -: 1052:   struct _Safe_tuple_element
        -: 1053:   : _Safe_tuple_element_impl<__i, _Tuple,
        -: 1054:			      (__i < tuple_size<_Tuple>::value)>
        -: 1055:   { };
        -: 1056:
        -: 1057:  /**
        -: 1058:   *  Maps an argument to bind() into an actual argument to the bound
        -: 1059:   *  function object [TR1 3.6.3/5]. Only the first parameter should
        -: 1060:   *  be specified: the rest are used to determine among the various
        -: 1061:   *  implementations. Note that, although this class is a function
        -: 1062:   *  object, it isn't entirely normal because it takes only two
        -: 1063:   *  parameters regardless of the number of parameters passed to the
        -: 1064:   *  bind expression. The first parameter is the bound argument and
        -: 1065:   *  the second parameter is a tuple containing references to the
        -: 1066:   *  rest of the arguments.
        -: 1067:   */
        -: 1068:  template<typename _Arg,
        -: 1069:	   bool _IsBindExp = is_bind_expression<_Arg>::value,
        -: 1070:	   bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>
        -: 1071:    class _Mu;
        -: 1072:
        -: 1073:  /**
        -: 1074:   *  If the argument is reference_wrapper<_Tp>, returns the
        -: 1075:   *  underlying reference. [TR1 3.6.3/5 bullet 1]
        -: 1076:   */
        -: 1077:  template<typename _Tp>
        -: 1078:    class _Mu<reference_wrapper<_Tp>, false, false>
        -: 1079:    {
        -: 1080:    public:
        -: 1081:      typedef _Tp& result_type;
        -: 1082:
        -: 1083:      /* Note: This won't actually work for const volatile
        -: 1084:       * reference_wrappers, because reference_wrapper::get() is const
        -: 1085:       * but not volatile-qualified. This might be a defect in the TR.
        -: 1086:       */
        -: 1087:      template<typename _CVRef, typename _Tuple>
        -: 1088:	result_type
        -: 1089:	operator()(_CVRef& __arg, _Tuple&) const volatile
        -: 1090:	{ return __arg.get(); }
        -: 1091:    };
        -: 1092:
        -: 1093:  /**
        -: 1094:   *  If the argument is a bind expression, we invoke the underlying
        -: 1095:   *  function object with the same cv-qualifiers as we are given and
        -: 1096:   *  pass along all of our arguments (unwrapped). [TR1 3.6.3/5 bullet 2]
        -: 1097:   */
        -: 1098:  template<typename _Arg>
        -: 1099:    class _Mu<_Arg, true, false>
        -: 1100:    {
        -: 1101:    public:
        -: 1102:      template<typename _CVArg, typename... _Args>
        -: 1103:	auto
        -: 1104:	operator()(_CVArg& __arg,
        -: 1105:		   tuple<_Args...>& __tuple) const volatile
        -: 1106:	-> decltype(__arg(declval<_Args>()...))
        -: 1107:	{
        -: 1108:	  // Construct an index tuple and forward to __call
        -: 1109:	  typedef typename _Build_index_tuple<sizeof...(_Args)>::__type
        -: 1110:	    _Indexes;
        -: 1111:	  return this->__call(__arg, __tuple, _Indexes());
        -: 1112:	}
        -: 1113:
        -: 1114:    private:
        -: 1115:      // Invokes the underlying function object __arg by unpacking all
        -: 1116:      // of the arguments in the tuple.
        -: 1117:      template<typename _CVArg, typename... _Args, std::size_t... _Indexes>
        -: 1118:	auto
        -: 1119:	__call(_CVArg& __arg, tuple<_Args...>& __tuple,
        -: 1120:	       const _Index_tuple<_Indexes...>&) const volatile
        -: 1121:	-> decltype(__arg(declval<_Args>()...))
        -: 1122:	{
        -: 1123:	  return __arg(std::forward<_Args>(get<_Indexes>(__tuple))...);
        -: 1124:	}
        -: 1125:    };
        -: 1126:
        -: 1127:  /**
        -: 1128:   *  If the argument is a placeholder for the Nth argument, returns
        -: 1129:   *  a reference to the Nth argument to the bind function object.
        -: 1130:   *  [TR1 3.6.3/5 bullet 3]
        -: 1131:   */
        -: 1132:  template<typename _Arg>
        -: 1133:    class _Mu<_Arg, false, true>
        -: 1134:    {
        -: 1135:    public:
        -: 1136:      template<typename _Signature> class result;
        -: 1137:
        -: 1138:      template<typename _CVMu, typename _CVArg, typename _Tuple>
        -: 1139:	class result<_CVMu(_CVArg, _Tuple)>
        -: 1140:	{
        -: 1141:	  // Add a reference, if it hasn't already been done for us.
        -: 1142:	  // This allows us to be a little bit sloppy in constructing
        -: 1143:	  // the tuple that we pass to result_of<...>.
        -: 1144:	  typedef typename _Safe_tuple_element<(is_placeholder<_Arg>::value
        -: 1145:						- 1), _Tuple>::type
        -: 1146:	    __base_type;
        -: 1147:
        -: 1148:	public:
        -: 1149:	  typedef typename add_rvalue_reference<__base_type>::type type;
        -: 1150:	};
        -: 1151:
        -: 1152:      template<typename _Tuple>
        -: 1153:	typename result<_Mu(_Arg, _Tuple)>::type
        -: 1154:	operator()(const volatile _Arg&, _Tuple& __tuple) const volatile
        -: 1155:	{
        -: 1156:	  return std::forward<typename result<_Mu(_Arg, _Tuple)>::type>(
        -: 1157:	      ::std::get<(is_placeholder<_Arg>::value - 1)>(__tuple));
        -: 1158:	}
        -: 1159:    };
        -: 1160:
        -: 1161:  /**
        -: 1162:   *  If the argument is just a value, returns a reference to that
        -: 1163:   *  value. The cv-qualifiers on the reference are the same as the
        -: 1164:   *  cv-qualifiers on the _Mu object. [TR1 3.6.3/5 bullet 4]
        -: 1165:   */
        -: 1166:  template<typename _Arg>
        -: 1167:    class _Mu<_Arg, false, false>
        -: 1168:    {
        -: 1169:    public:
        -: 1170:      template<typename _Signature> struct result;
        -: 1171:
        -: 1172:      template<typename _CVMu, typename _CVArg, typename _Tuple>
        -: 1173:	struct result<_CVMu(_CVArg, _Tuple)>
        -: 1174:	{
        -: 1175:	  typedef typename add_lvalue_reference<_CVArg>::type type;
        -: 1176:	};
        -: 1177:
        -: 1178:      // Pick up the cv-qualifiers of the argument
        -: 1179:      template<typename _CVArg, typename _Tuple>
        -: 1180:	_CVArg&&
        -: 1181:	operator()(_CVArg&& __arg, _Tuple&) const volatile
        -: 1182:	{ return std::forward<_CVArg>(__arg); }
        -: 1183:    };
        -: 1184:
        -: 1185:  /**
        -: 1186:   *  Maps member pointers into instances of _Mem_fn but leaves all
        -: 1187:   *  other function objects untouched. Used by tr1::bind(). The
        -: 1188:   *  primary template handles the non--member-pointer case.
        -: 1189:   */
        -: 1190:  template<typename _Tp>
        -: 1191:    struct _Maybe_wrap_member_pointer
        -: 1192:    {
        -: 1193:      typedef _Tp type;
        -: 1194:
        -: 1195:      static const _Tp&
        -: 1196:      __do_wrap(const _Tp& __x)
        -: 1197:      { return __x; }
        -: 1198:
        -: 1199:      static _Tp&&
        -: 1200:      __do_wrap(_Tp&& __x)
        -: 1201:      { return static_cast<_Tp&&>(__x); }
        -: 1202:    };
        -: 1203:
        -: 1204:  /**
        -: 1205:   *  Maps member pointers into instances of _Mem_fn but leaves all
        -: 1206:   *  other function objects untouched. Used by tr1::bind(). This
        -: 1207:   *  partial specialization handles the member pointer case.
        -: 1208:   */
        -: 1209:  template<typename _Tp, typename _Class>
        -: 1210:    struct _Maybe_wrap_member_pointer<_Tp _Class::*>
        -: 1211:    {
        -: 1212:      typedef _Mem_fn<_Tp _Class::*> type;
        -: 1213:
        -: 1214:      static type
        -: 1215:      __do_wrap(_Tp _Class::* __pm)
        -: 1216:      { return type(__pm); }
        -: 1217:    };
        -: 1218:
        -: 1219:  // Specialization needed to prevent "forming reference to void" errors when
        -: 1220:  // bind<void>() is called, because argument deduction instantiates
        -: 1221:  // _Maybe_wrap_member_pointer<void> outside the immediate context where
        -: 1222:  // SFINAE applies.
        -: 1223:  template<>
        -: 1224:    struct _Maybe_wrap_member_pointer<void>
        -: 1225:    {
        -: 1226:      typedef void type;
        -: 1227:    };
        -: 1228:
        -: 1229:  // std::get<I> for volatile-qualified tuples
        -: 1230:  template<std::size_t _Ind, typename... _Tp>
        -: 1231:    inline auto
        -: 1232:    __volget(volatile tuple<_Tp...>& __tuple)
        -: 1233:    -> typename tuple_element<_Ind, tuple<_Tp...>>::type volatile&
        -: 1234:    { return std::get<_Ind>(const_cast<tuple<_Tp...>&>(__tuple)); }
        -: 1235:
        -: 1236:  // std::get<I> for const-volatile-qualified tuples
        -: 1237:  template<std::size_t _Ind, typename... _Tp>
        -: 1238:    inline auto
        -: 1239:    __volget(const volatile tuple<_Tp...>& __tuple)
        -: 1240:    -> typename tuple_element<_Ind, tuple<_Tp...>>::type const volatile&
        -: 1241:    { return std::get<_Ind>(const_cast<const tuple<_Tp...>&>(__tuple)); }
        -: 1242:
        -: 1243:  /// Type of the function object returned from bind().
        -: 1244:  template<typename _Signature>
        -: 1245:    struct _Bind;
        -: 1246:
        -: 1247:   template<typename _Functor, typename... _Bound_args>
        -: 1248:    class _Bind<_Functor(_Bound_args...)>
        -: 1249:    : public _Weak_result_type<_Functor>
        -: 1250:    {
        -: 1251:      typedef _Bind __self_type;
        -: 1252:      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
        -: 1253:	_Bound_indexes;
        -: 1254:
        -: 1255:      _Functor _M_f;
        -: 1256:      tuple<_Bound_args...> _M_bound_args;
        -: 1257:
        -: 1258:      // Call unqualified
        -: 1259:      template<typename _Result, typename... _Args, std::size_t... _Indexes>
        -: 1260:	_Result
        -: 1261:	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
        -: 1262:	{
        -: 1263:	  return _M_f(_Mu<_Bound_args>()
        -: 1264:		      (get<_Indexes>(_M_bound_args), __args)...);
        -: 1265:	}
        -: 1266:
        -: 1267:      // Call as const
        -: 1268:      template<typename _Result, typename... _Args, std::size_t... _Indexes>
        -: 1269:	_Result
        -: 1270:	__call_c(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
        -: 1271:	{
        -: 1272:	  return _M_f(_Mu<_Bound_args>()
        -: 1273:		      (get<_Indexes>(_M_bound_args), __args)...);
        -: 1274:	}
        -: 1275:
        -: 1276:      // Call as volatile
        -: 1277:      template<typename _Result, typename... _Args, std::size_t... _Indexes>
        -: 1278:	_Result
        -: 1279:	__call_v(tuple<_Args...>&& __args,
        -: 1280:		 _Index_tuple<_Indexes...>) volatile
        -: 1281:	{
        -: 1282:	  return _M_f(_Mu<_Bound_args>()
        -: 1283:		      (__volget<_Indexes>(_M_bound_args), __args)...);
        -: 1284:	}
        -: 1285:
        -: 1286:      // Call as const volatile
        -: 1287:      template<typename _Result, typename... _Args, std::size_t... _Indexes>
        -: 1288:	_Result
        -: 1289:	__call_c_v(tuple<_Args...>&& __args,
        -: 1290:		   _Index_tuple<_Indexes...>) const volatile
        -: 1291:	{
        -: 1292:	  return _M_f(_Mu<_Bound_args>()
        -: 1293:		      (__volget<_Indexes>(_M_bound_args), __args)...);
        -: 1294:	}
        -: 1295:
        -: 1296:     public:
        -: 1297:      template<typename... _Args>
        -: 1298:	explicit _Bind(const _Functor& __f, _Args&&... __args)
        -: 1299:	: _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
        -: 1300:	{ }
        -: 1301:
        -: 1302:      template<typename... _Args>
        -: 1303:	explicit _Bind(_Functor&& __f, _Args&&... __args)
        -: 1304:	: _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
        -: 1305:	{ }
        -: 1306:
        -: 1307:      _Bind(const _Bind&) = default;
        -: 1308:
        -: 1309:      _Bind(_Bind&& __b)
        -: 1310:      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
        -: 1311:      { }
        -: 1312:
        -: 1313:      // Call unqualified
        -: 1314:      template<typename... _Args, typename _Result
        -: 1315:	= decltype( std::declval<_Functor>()(
        -: 1316:	      _Mu<_Bound_args>()( std::declval<_Bound_args&>(),
        -: 1317:				  std::declval<tuple<_Args...>&>() )... ) )>
        -: 1318:	_Result
        -: 1319:	operator()(_Args&&... __args)
        -: 1320:	{
        -: 1321:	  return this->__call<_Result>(
        -: 1322:	      std::forward_as_tuple(std::forward<_Args>(__args)...),
        -: 1323:	      _Bound_indexes());
        -: 1324:	}
        -: 1325:
        -: 1326:      // Call as const
        -: 1327:      template<typename... _Args, typename _Result
        -: 1328:	= decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
        -: 1329:		       typename add_const<_Functor>::type>::type>()(
        -: 1330:	      _Mu<_Bound_args>()( std::declval<const _Bound_args&>(),
        -: 1331:				  std::declval<tuple<_Args...>&>() )... ) )>
        -: 1332:	_Result
        -: 1333:	operator()(_Args&&... __args) const
        -: 1334:	{
        -: 1335:	  return this->__call_c<_Result>(
        -: 1336:	      std::forward_as_tuple(std::forward<_Args>(__args)...),
        -: 1337:	      _Bound_indexes());
        -: 1338:	}
        -: 1339:
        -: 1340:      // Call as volatile
        -: 1341:      template<typename... _Args, typename _Result
        -: 1342:	= decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
        -: 1343:                       typename add_volatile<_Functor>::type>::type>()(
        -: 1344:	      _Mu<_Bound_args>()( std::declval<volatile _Bound_args&>(),
        -: 1345:				  std::declval<tuple<_Args...>&>() )... ) )>
        -: 1346:	_Result
        -: 1347:	operator()(_Args&&... __args) volatile
        -: 1348:	{
        -: 1349:	  return this->__call_v<_Result>(
        -: 1350:	      std::forward_as_tuple(std::forward<_Args>(__args)...),
        -: 1351:	      _Bound_indexes());
        -: 1352:	}
        -: 1353:
        -: 1354:      // Call as const volatile
        -: 1355:      template<typename... _Args, typename _Result
        -: 1356:	= decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
        -: 1357:                       typename add_cv<_Functor>::type>::type>()(
        -: 1358:	      _Mu<_Bound_args>()( std::declval<const volatile _Bound_args&>(),
        -: 1359:				  std::declval<tuple<_Args...>&>() )... ) )>
        -: 1360:	_Result
        -: 1361:	operator()(_Args&&... __args) const volatile
        -: 1362:	{
        -: 1363:	  return this->__call_c_v<_Result>(
        -: 1364:	      std::forward_as_tuple(std::forward<_Args>(__args)...),
        -: 1365:	      _Bound_indexes());
        -: 1366:	}
        -: 1367:    };
        -: 1368:
        -: 1369:  /// Type of the function object returned from bind<R>().
        -: 1370:  template<typename _Result, typename _Signature>
        -: 1371:    struct _Bind_result;
        -: 1372:
        -: 1373:  template<typename _Result, typename _Functor, typename... _Bound_args>
        -: 1374:    class _Bind_result<_Result, _Functor(_Bound_args...)>
        -: 1375:    {
        -: 1376:      typedef _Bind_result __self_type;
        -: 1377:      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
        -: 1378:	_Bound_indexes;
        -: 1379:
        -: 1380:      _Functor _M_f;
        -: 1381:      tuple<_Bound_args...> _M_bound_args;
        -: 1382:
        -: 1383:      // sfinae types
        -: 1384:      template<typename _Res>
        -: 1385:	struct __enable_if_void : enable_if<is_void<_Res>::value, int> { };
        -: 1386:      template<typename _Res>
        -: 1387:	struct __disable_if_void : enable_if<!is_void<_Res>::value, int> { };
        -: 1388:
        -: 1389:      // Call unqualified
        -: 1390:      template<typename _Res, typename... _Args, std::size_t... _Indexes>
        -: 1391:	_Result
        -: 1392:	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
        -: 1393:	    typename __disable_if_void<_Res>::type = 0)
        -: 1394:	{
        -: 1395:	  return _M_f(_Mu<_Bound_args>()
        -: 1396:		      (get<_Indexes>(_M_bound_args), __args)...);
        -: 1397:	}
        -: 1398:
        -: 1399:      // Call unqualified, return void
        -: 1400:      template<typename _Res, typename... _Args, std::size_t... _Indexes>
        -: 1401:	void
        -: 1402:	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
        -: 1403:	    typename __enable_if_void<_Res>::type = 0)
        -: 1404:	{
        -: 1405:	  _M_f(_Mu<_Bound_args>()
        -: 1406:	       (get<_Indexes>(_M_bound_args), __args)...);
        -: 1407:	}
        -: 1408:
        -: 1409:      // Call as const
        -: 1410:      template<typename _Res, typename... _Args, std::size_t... _Indexes>
        -: 1411:	_Result
        -: 1412:	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
        -: 1413:	    typename __disable_if_void<_Res>::type = 0) const
        -: 1414:	{
        -: 1415:	  return _M_f(_Mu<_Bound_args>()
        -: 1416:		      (get<_Indexes>(_M_bound_args), __args)...);
        -: 1417:	}
        -: 1418:
        -: 1419:      // Call as const, return void
        -: 1420:      template<typename _Res, typename... _Args, std::size_t... _Indexes>
        -: 1421:	void
        -: 1422:	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
        -: 1423:	    typename __enable_if_void<_Res>::type = 0) const
        -: 1424:	{
        -: 1425:	  _M_f(_Mu<_Bound_args>()
        -: 1426:	       (get<_Indexes>(_M_bound_args),  __args)...);
        -: 1427:	}
        -: 1428:
        -: 1429:      // Call as volatile
        -: 1430:      template<typename _Res, typename... _Args, std::size_t... _Indexes>
        -: 1431:	_Result
        -: 1432:	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
        -: 1433:	    typename __disable_if_void<_Res>::type = 0) volatile
        -: 1434:	{
        -: 1435:	  return _M_f(_Mu<_Bound_args>()
        -: 1436:		      (__volget<_Indexes>(_M_bound_args), __args)...);
        -: 1437:	}
        -: 1438:
        -: 1439:      // Call as volatile, return void
        -: 1440:      template<typename _Res, typename... _Args, std::size_t... _Indexes>
        -: 1441:	void
        -: 1442:	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
        -: 1443:	    typename __enable_if_void<_Res>::type = 0) volatile
        -: 1444:	{
        -: 1445:	  _M_f(_Mu<_Bound_args>()
        -: 1446:	       (__volget<_Indexes>(_M_bound_args), __args)...);
        -: 1447:	}
        -: 1448:
        -: 1449:      // Call as const volatile
        -: 1450:      template<typename _Res, typename... _Args, std::size_t... _Indexes>
        -: 1451:	_Result
        -: 1452:	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
        -: 1453:	    typename __disable_if_void<_Res>::type = 0) const volatile
        -: 1454:	{
        -: 1455:	  return _M_f(_Mu<_Bound_args>()
        -: 1456:		      (__volget<_Indexes>(_M_bound_args), __args)...);
        -: 1457:	}
        -: 1458:
        -: 1459:      // Call as const volatile, return void
        -: 1460:      template<typename _Res, typename... _Args, std::size_t... _Indexes>
        -: 1461:	void
        -: 1462:	__call(tuple<_Args...>&& __args,
        -: 1463:	       _Index_tuple<_Indexes...>,
        -: 1464:	    typename __enable_if_void<_Res>::type = 0) const volatile
        -: 1465:	{
        -: 1466:	  _M_f(_Mu<_Bound_args>()
        -: 1467:	       (__volget<_Indexes>(_M_bound_args), __args)...);
        -: 1468:	}
        -: 1469:
        -: 1470:    public:
        -: 1471:      typedef _Result result_type;
        -: 1472:
        -: 1473:      template<typename... _Args>
        -: 1474:	explicit _Bind_result(const _Functor& __f, _Args&&... __args)
        -: 1475:	: _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
        -: 1476:	{ }
        -: 1477:
        -: 1478:      template<typename... _Args>
        -: 1479:	explicit _Bind_result(_Functor&& __f, _Args&&... __args)
        -: 1480:	: _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
        -: 1481:	{ }
        -: 1482:
        -: 1483:      _Bind_result(const _Bind_result&) = default;
        -: 1484:
        -: 1485:      _Bind_result(_Bind_result&& __b)
        -: 1486:      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
        -: 1487:      { }
        -: 1488:
        -: 1489:      // Call unqualified
        -: 1490:      template<typename... _Args>
        -: 1491:	result_type
        -: 1492:	operator()(_Args&&... __args)
        -: 1493:	{
        -: 1494:	  return this->__call<_Result>(
        -: 1495:	      std::forward_as_tuple(std::forward<_Args>(__args)...),
        -: 1496:	      _Bound_indexes());
        -: 1497:	}
        -: 1498:
        -: 1499:      // Call as const
        -: 1500:      template<typename... _Args>
        -: 1501:	result_type
        -: 1502:	operator()(_Args&&... __args) const
        -: 1503:	{
        -: 1504:	  return this->__call<_Result>(
        -: 1505:	      std::forward_as_tuple(std::forward<_Args>(__args)...),
        -: 1506:	      _Bound_indexes());
        -: 1507:	}
        -: 1508:
        -: 1509:      // Call as volatile
        -: 1510:      template<typename... _Args>
        -: 1511:	result_type
        -: 1512:	operator()(_Args&&... __args) volatile
        -: 1513:	{
        -: 1514:	  return this->__call<_Result>(
        -: 1515:	      std::forward_as_tuple(std::forward<_Args>(__args)...),
        -: 1516:	      _Bound_indexes());
        -: 1517:	}
        -: 1518:
        -: 1519:      // Call as const volatile
        -: 1520:      template<typename... _Args>
        -: 1521:	result_type
        -: 1522:	operator()(_Args&&... __args) const volatile
        -: 1523:	{
        -: 1524:	  return this->__call<_Result>(
        -: 1525:	      std::forward_as_tuple(std::forward<_Args>(__args)...),
        -: 1526:	      _Bound_indexes());
        -: 1527:	}
        -: 1528:    };
        -: 1529:
        -: 1530:  /**
        -: 1531:   *  @brief Class template _Bind is always a bind expression.
        -: 1532:   *  @ingroup binders
        -: 1533:   */
        -: 1534:  template<typename _Signature>
        -: 1535:    struct is_bind_expression<_Bind<_Signature> >
        -: 1536:    : public true_type { };
        -: 1537:
        -: 1538:  /**
        -: 1539:   *  @brief Class template _Bind is always a bind expression.
        -: 1540:   *  @ingroup binders
        -: 1541:   */
        -: 1542:  template<typename _Signature>
        -: 1543:    struct is_bind_expression<const _Bind<_Signature> >
        -: 1544:    : public true_type { };
        -: 1545:
        -: 1546:  /**
        -: 1547:   *  @brief Class template _Bind is always a bind expression.
        -: 1548:   *  @ingroup binders
        -: 1549:   */
        -: 1550:  template<typename _Signature>
        -: 1551:    struct is_bind_expression<volatile _Bind<_Signature> >
        -: 1552:    : public true_type { };
        -: 1553:
        -: 1554:  /**
        -: 1555:   *  @brief Class template _Bind is always a bind expression.
        -: 1556:   *  @ingroup binders
        -: 1557:   */
        -: 1558:  template<typename _Signature>
        -: 1559:    struct is_bind_expression<const volatile _Bind<_Signature>>
        -: 1560:    : public true_type { };
        -: 1561:
        -: 1562:  /**
        -: 1563:   *  @brief Class template _Bind_result is always a bind expression.
        -: 1564:   *  @ingroup binders
        -: 1565:   */
        -: 1566:  template<typename _Result, typename _Signature>
        -: 1567:    struct is_bind_expression<_Bind_result<_Result, _Signature>>
        -: 1568:    : public true_type { };
        -: 1569:
        -: 1570:  /**
        -: 1571:   *  @brief Class template _Bind_result is always a bind expression.
        -: 1572:   *  @ingroup binders
        -: 1573:   */
        -: 1574:  template<typename _Result, typename _Signature>
        -: 1575:    struct is_bind_expression<const _Bind_result<_Result, _Signature>>
        -: 1576:    : public true_type { };
        -: 1577:
        -: 1578:  /**
        -: 1579:   *  @brief Class template _Bind_result is always a bind expression.
        -: 1580:   *  @ingroup binders
        -: 1581:   */
        -: 1582:  template<typename _Result, typename _Signature>
        -: 1583:    struct is_bind_expression<volatile _Bind_result<_Result, _Signature>>
        -: 1584:    : public true_type { };
        -: 1585:
        -: 1586:  /**
        -: 1587:   *  @brief Class template _Bind_result is always a bind expression.
        -: 1588:   *  @ingroup binders
        -: 1589:   */
        -: 1590:  template<typename _Result, typename _Signature>
        -: 1591:    struct is_bind_expression<const volatile _Bind_result<_Result, _Signature>>
        -: 1592:    : public true_type { };
        -: 1593:
        -: 1594:  // Trait type used to remove std::bind() from overload set via SFINAE
        -: 1595:  // when first argument has integer type, so that std::bind() will
        -: 1596:  // not be a better match than ::bind() from the BSD Sockets API.
        -: 1597:  template<typename _Tp, typename _Tp2 = typename decay<_Tp>::type>
        -: 1598:    using __is_socketlike = __or_<is_integral<_Tp2>, is_enum<_Tp2>>;
        -: 1599:
        -: 1600:  template<bool _SocketLike, typename _Func, typename... _BoundArgs>
        -: 1601:    struct _Bind_helper
        -: 1602:    {
        -: 1603:      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
        -: 1604:	__maybe_type;
        -: 1605:      typedef typename __maybe_type::type __func_type;
        -: 1606:      typedef _Bind<__func_type(typename decay<_BoundArgs>::type...)> type;
        -: 1607:    };
        -: 1608:
        -: 1609:  // Partial specialization for is_socketlike == true, does not define
        -: 1610:  // nested type so std::bind() will not participate in overload resolution
        -: 1611:  // when the first argument might be a socket file descriptor.
        -: 1612:  template<typename _Func, typename... _BoundArgs>
        -: 1613:    struct _Bind_helper<true, _Func, _BoundArgs...>
        -: 1614:    { };
        -: 1615:
        -: 1616:  /**
        -: 1617:   *  @brief Function template for std::bind.
        -: 1618:   *  @ingroup binders
        -: 1619:   */
        -: 1620:  template<typename _Func, typename... _BoundArgs>
        -: 1621:    inline typename
        -: 1622:    _Bind_helper<__is_socketlike<_Func>::value, _Func, _BoundArgs...>::type
        -: 1623:    bind(_Func&& __f, _BoundArgs&&... __args)
        -: 1624:    {
        -: 1625:      typedef _Bind_helper<false, _Func, _BoundArgs...> __helper_type;
        -: 1626:      typedef typename __helper_type::__maybe_type __maybe_type;
        -: 1627:      typedef typename __helper_type::type __result_type;
        -: 1628:      return __result_type(__maybe_type::__do_wrap(std::forward<_Func>(__f)),
        -: 1629:			   std::forward<_BoundArgs>(__args)...);
        -: 1630:    }
        -: 1631:
        -: 1632:  template<typename _Result, typename _Func, typename... _BoundArgs>
        -: 1633:    struct _Bindres_helper
        -: 1634:    {
        -: 1635:      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
        -: 1636:	__maybe_type;
        -: 1637:      typedef typename __maybe_type::type __functor_type;
        -: 1638:      typedef _Bind_result<_Result,
        -: 1639:			   __functor_type(typename decay<_BoundArgs>::type...)>
        -: 1640:	type;
        -: 1641:    };
        -: 1642:
        -: 1643:  /**
        -: 1644:   *  @brief Function template for std::bind<R>.
        -: 1645:   *  @ingroup binders
        -: 1646:   */
        -: 1647:  template<typename _Result, typename _Func, typename... _BoundArgs>
        -: 1648:    inline
        -: 1649:    typename _Bindres_helper<_Result, _Func, _BoundArgs...>::type
        -: 1650:    bind(_Func&& __f, _BoundArgs&&... __args)
        -: 1651:    {
        -: 1652:      typedef _Bindres_helper<_Result, _Func, _BoundArgs...> __helper_type;
        -: 1653:      typedef typename __helper_type::__maybe_type __maybe_type;
        -: 1654:      typedef typename __helper_type::type __result_type;
        -: 1655:      return __result_type(__maybe_type::__do_wrap(std::forward<_Func>(__f)),
        -: 1656:			   std::forward<_BoundArgs>(__args)...);
        -: 1657:    }
        -: 1658:
        -: 1659:  template<typename _Signature>
        -: 1660:    struct _Bind_simple;
        -: 1661:
        -: 1662:  template<typename _Callable, typename... _Args>
        -: 1663:    struct _Bind_simple<_Callable(_Args...)>
        -: 1664:    {
        -: 1665:      typedef typename result_of<_Callable(_Args...)>::type result_type;
        -: 1666:
        -: 1667:      template<typename... _Args2, typename = typename
        -: 1668:               enable_if< sizeof...(_Args) == sizeof...(_Args2)>::type>
        -: 1669:        explicit
        -: 1670:        _Bind_simple(const _Callable& __callable, _Args2&&... __args)
        -: 1671:        : _M_bound(__callable, std::forward<_Args2>(__args)...)
        -: 1672:        { }
        -: 1673:
        -: 1674:      template<typename... _Args2, typename = typename
        -: 1675:               enable_if< sizeof...(_Args) == sizeof...(_Args2)>::type>
        -: 1676:        explicit
        -: 1677:        _Bind_simple(_Callable&& __callable, _Args2&&... __args)
        -: 1678:        : _M_bound(std::move(__callable), std::forward<_Args2>(__args)...)
        -: 1679:        { }
        -: 1680:
        -: 1681:      _Bind_simple(const _Bind_simple&) = default;
        -: 1682:      _Bind_simple(_Bind_simple&&) = default;
        -: 1683:
        -: 1684:      result_type
        -: 1685:      operator()()
        -: 1686:      {
        -: 1687:        typedef typename _Build_index_tuple<sizeof...(_Args)>::__type _Indices;
        -: 1688:        return _M_invoke(_Indices());
        -: 1689:      }
        -: 1690:
        -: 1691:    private:
        -: 1692:
        -: 1693:      template<std::size_t... _Indices>
        -: 1694:        typename result_of<_Callable(_Args...)>::type
        -: 1695:        _M_invoke(_Index_tuple<_Indices...>)
        -: 1696:        {
        -: 1697:	  // std::bind always forwards bound arguments as lvalues,
        -: 1698:	  // but this type can call functions which only accept rvalues.
        -: 1699:          return std::forward<_Callable>(std::get<0>(_M_bound))(
        -: 1700:              std::forward<_Args>(std::get<_Indices+1>(_M_bound))...);
        -: 1701:        }
        -: 1702:
        -: 1703:      std::tuple<_Callable, _Args...> _M_bound;
        -: 1704:    };
        -: 1705:
        -: 1706:  template<typename _Func, typename... _BoundArgs>
        -: 1707:    struct _Bind_simple_helper
        -: 1708:    {
        -: 1709:      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
        -: 1710:        __maybe_type;
        -: 1711:      typedef typename __maybe_type::type __func_type;
        -: 1712:      typedef _Bind_simple<__func_type(typename decay<_BoundArgs>::type...)>
        -: 1713:       	__type;
        -: 1714:    };
        -: 1715:
        -: 1716:  // Simplified version of std::bind for internal use, without support for
        -: 1717:  // unbound arguments, placeholders or nested bind expressions.
        -: 1718:  template<typename _Callable, typename... _Args>
        -: 1719:    typename _Bind_simple_helper<_Callable, _Args...>::__type
function _ZSt13__bind_simpleIZN4cctz12_GLOBAL__N_115LoadUTCTimeZoneEvEUlvE_IEENSt19_Bind_simple_helperIT_IDpT0_EE6__typeEOS4_DpOS5_ called 11366 returned 100% blocks executed 100%
    11366: 1720:    __bind_simple(_Callable&& __callable, _Args&&... __args)
        -: 1721:    {
        -: 1722:      typedef _Bind_simple_helper<_Callable, _Args...> __helper_type;
        -: 1723:      typedef typename __helper_type::__maybe_type __maybe_type;
        -: 1724:      typedef typename __helper_type::__type __result_type;
        -: 1725:      return __result_type(
        -: 1726:          __maybe_type::__do_wrap( std::forward<_Callable>(__callable)),
    11366: 1727:          std::forward<_Args>(__args)...);
        -: 1728:    }
        -: 1729:
        -: 1730:  /**
        -: 1731:   *  @brief Exception class thrown when class template function's
        -: 1732:   *  operator() is called with an empty target.
        -: 1733:   *  @ingroup exceptions
        -: 1734:   */
        -: 1735:  class bad_function_call : public std::exception
        -: 1736:  {
        -: 1737:  public:
        -: 1738:    virtual ~bad_function_call() noexcept;
        -: 1739:
        -: 1740:    const char* what() const noexcept;
        -: 1741:  };
        -: 1742:
        -: 1743:  /**
        -: 1744:   *  Trait identifying "location-invariant" types, meaning that the
        -: 1745:   *  address of the object (or any of its members) will not escape.
        -: 1746:   *  Also implies a trivial copy constructor and assignment operator.
        -: 1747:   */
        -: 1748:  template<typename _Tp>
        -: 1749:    struct __is_location_invariant
        -: 1750:    : integral_constant<bool, (is_pointer<_Tp>::value
        -: 1751:			       || is_member_pointer<_Tp>::value)>
        -: 1752:    { };
        -: 1753:
        -: 1754:  class _Undefined_class;
        -: 1755:
        -: 1756:  union _Nocopy_types
        -: 1757:  {
        -: 1758:    void*       _M_object;
        -: 1759:    const void* _M_const_object;
        -: 1760:    void (*_M_function_pointer)();
        -: 1761:    void (_Undefined_class::*_M_member_pointer)();
        -: 1762:  };
        -: 1763:
        -: 1764:  union _Any_data
        -: 1765:  {
        -: 1766:    void*       _M_access()       { return &_M_pod_data[0]; }
        -: 1767:    const void* _M_access() const { return &_M_pod_data[0]; }
        -: 1768:
        -: 1769:    template<typename _Tp>
        -: 1770:      _Tp&
        -: 1771:      _M_access()
        -: 1772:      { return *static_cast<_Tp*>(_M_access()); }
        -: 1773:
        -: 1774:    template<typename _Tp>
        -: 1775:      const _Tp&
        -: 1776:      _M_access() const
        -: 1777:      { return *static_cast<const _Tp*>(_M_access()); }
        -: 1778:
        -: 1779:    _Nocopy_types _M_unused;
        -: 1780:    char _M_pod_data[sizeof(_Nocopy_types)];
        -: 1781:  };
        -: 1782:
        -: 1783:  enum _Manager_operation
        -: 1784:  {
        -: 1785:    __get_type_info,
        -: 1786:    __get_functor_ptr,
        -: 1787:    __clone_functor,
        -: 1788:    __destroy_functor
        -: 1789:  };
        -: 1790:
        -: 1791:  // Simple type wrapper that helps avoid annoying const problems
        -: 1792:  // when casting between void pointers and pointers-to-pointers.
        -: 1793:  template<typename _Tp>
        -: 1794:    struct _Simple_type_wrapper
        -: 1795:    {
        -: 1796:      _Simple_type_wrapper(_Tp __value) : __value(__value) { }
        -: 1797:
        -: 1798:      _Tp __value;
        -: 1799:    };
        -: 1800:
        -: 1801:  template<typename _Tp>
        -: 1802:    struct __is_location_invariant<_Simple_type_wrapper<_Tp> >
        -: 1803:    : __is_location_invariant<_Tp>
        -: 1804:    { };
        -: 1805:
        -: 1806:  // Converts a reference to a function object into a callable
        -: 1807:  // function object.
        -: 1808:  template<typename _Functor>
        -: 1809:    inline _Functor&
        -: 1810:    __callable_functor(_Functor& __f)
        -: 1811:    { return __f; }
        -: 1812:
        -: 1813:  template<typename _Member, typename _Class>
        -: 1814:    inline _Mem_fn<_Member _Class::*>
        -: 1815:    __callable_functor(_Member _Class::* &__p)
        -: 1816:    { return std::mem_fn(__p); }
        -: 1817:
        -: 1818:  template<typename _Member, typename _Class>
        -: 1819:    inline _Mem_fn<_Member _Class::*>
        -: 1820:    __callable_functor(_Member _Class::* const &__p)
        -: 1821:    { return std::mem_fn(__p); }
        -: 1822:
        -: 1823:  template<typename _Member, typename _Class>
        -: 1824:    inline _Mem_fn<_Member _Class::*>
        -: 1825:    __callable_functor(_Member _Class::* volatile &__p)
        -: 1826:    { return std::mem_fn(__p); }
        -: 1827:
        -: 1828:  template<typename _Member, typename _Class>
        -: 1829:    inline _Mem_fn<_Member _Class::*>
        -: 1830:    __callable_functor(_Member _Class::* const volatile &__p)
        -: 1831:    { return std::mem_fn(__p); }
        -: 1832:
        -: 1833:  template<typename _Signature>
        -: 1834:    class function;
        -: 1835:
        -: 1836:  /// Base class of all polymorphic function object wrappers.
        -: 1837:  class _Function_base
        -: 1838:  {
        -: 1839:  public:
        -: 1840:    static const std::size_t _M_max_size = sizeof(_Nocopy_types);
        -: 1841:    static const std::size_t _M_max_align = __alignof__(_Nocopy_types);
        -: 1842:
        -: 1843:    template<typename _Functor>
        -: 1844:      class _Base_manager
        -: 1845:      {
        -: 1846:      protected:
        -: 1847:	static const bool __stored_locally =
        -: 1848:	(__is_location_invariant<_Functor>::value
        -: 1849:	 && sizeof(_Functor) <= _M_max_size
        -: 1850:	 && __alignof__(_Functor) <= _M_max_align
        -: 1851:	 && (_M_max_align % __alignof__(_Functor) == 0));
        -: 1852:
        -: 1853:	typedef integral_constant<bool, __stored_locally> _Local_storage;
        -: 1854:
        -: 1855:	// Retrieve a pointer to the function object
        -: 1856:	static _Functor*
        -: 1857:	_M_get_pointer(const _Any_data& __source)
        -: 1858:	{
        -: 1859:	  const _Functor* __ptr =
        -: 1860:	    __stored_locally? std::__addressof(__source._M_access<_Functor>())
        -: 1861:	    /* have stored a pointer */ : __source._M_access<_Functor*>();
        -: 1862:	  return const_cast<_Functor*>(__ptr);
        -: 1863:	}
        -: 1864:
        -: 1865:	// Clone a location-invariant function object that fits within
        -: 1866:	// an _Any_data structure.
        -: 1867:	static void
        -: 1868:	_M_clone(_Any_data& __dest, const _Any_data& __source, true_type)
        -: 1869:	{
        -: 1870:	  new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
        -: 1871:	}
        -: 1872:
        -: 1873:	// Clone a function object that is not location-invariant or
        -: 1874:	// that cannot fit into an _Any_data structure.
        -: 1875:	static void
        -: 1876:	_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
        -: 1877:	{
        -: 1878:	  __dest._M_access<_Functor*>() =
        -: 1879:	    new _Functor(*__source._M_access<_Functor*>());
        -: 1880:	}
        -: 1881:
        -: 1882:	// Destroying a location-invariant object may still require
        -: 1883:	// destruction.
        -: 1884:	static void
        -: 1885:	_M_destroy(_Any_data& __victim, true_type)
        -: 1886:	{
        -: 1887:	  __victim._M_access<_Functor>().~_Functor();
        -: 1888:	}
        -: 1889:
        -: 1890:	// Destroying an object located on the heap.
        -: 1891:	static void
        -: 1892:	_M_destroy(_Any_data& __victim, false_type)
        -: 1893:	{
        -: 1894:	  delete __victim._M_access<_Functor*>();
        -: 1895:	}
        -: 1896:
        -: 1897:      public:
        -: 1898:	static bool
        -: 1899:	_M_manager(_Any_data& __dest, const _Any_data& __source,
        -: 1900:		   _Manager_operation __op)
        -: 1901:	{
        -: 1902:	  switch (__op)
        -: 1903:	    {
        -: 1904:#ifdef __GXX_RTTI
        -: 1905:	    case __get_type_info:
        -: 1906:	      __dest._M_access<const type_info*>() = &typeid(_Functor);
        -: 1907:	      break;
        -: 1908:#endif
        -: 1909:	    case __get_functor_ptr:
        -: 1910:	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
        -: 1911:	      break;
        -: 1912:
        -: 1913:	    case __clone_functor:
        -: 1914:	      _M_clone(__dest, __source, _Local_storage());
        -: 1915:	      break;
        -: 1916:
        -: 1917:	    case __destroy_functor:
        -: 1918:	      _M_destroy(__dest, _Local_storage());
        -: 1919:	      break;
        -: 1920:	    }
        -: 1921:	  return false;
        -: 1922:	}
        -: 1923:
        -: 1924:	static void
        -: 1925:	_M_init_functor(_Any_data& __functor, _Functor&& __f)
        -: 1926:	{ _M_init_functor(__functor, std::move(__f), _Local_storage()); }
        -: 1927:
        -: 1928:	template<typename _Signature>
        -: 1929:	  static bool
        -: 1930:	  _M_not_empty_function(const function<_Signature>& __f)
        -: 1931:	  { return static_cast<bool>(__f); }
        -: 1932:
        -: 1933:	template<typename _Tp>
        -: 1934:	  static bool
        -: 1935:	  _M_not_empty_function(_Tp* const& __fp)
        -: 1936:	  { return __fp; }
        -: 1937:
        -: 1938:	template<typename _Class, typename _Tp>
        -: 1939:	  static bool
        -: 1940:	  _M_not_empty_function(_Tp _Class::* const& __mp)
        -: 1941:	  { return __mp; }
        -: 1942:
        -: 1943:	template<typename _Tp>
        -: 1944:	  static bool
        -: 1945:	  _M_not_empty_function(const _Tp&)
        -: 1946:	  { return true; }
        -: 1947:
        -: 1948:      private:
        -: 1949:	static void
        -: 1950:	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
        -: 1951:	{ new (__functor._M_access()) _Functor(std::move(__f)); }
        -: 1952:
        -: 1953:	static void
        -: 1954:	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
        -: 1955:	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
        -: 1956:      };
        -: 1957:
        -: 1958:    template<typename _Functor>
        -: 1959:      class _Ref_manager : public _Base_manager<_Functor*>
        -: 1960:      {
        -: 1961:	typedef _Function_base::_Base_manager<_Functor*> _Base;
        -: 1962:
        -: 1963:      public:
        -: 1964:	static bool
        -: 1965:	_M_manager(_Any_data& __dest, const _Any_data& __source,
        -: 1966:		   _Manager_operation __op)
        -: 1967:	{
        -: 1968:	  switch (__op)
        -: 1969:	    {
        -: 1970:#ifdef __GXX_RTTI
        -: 1971:	    case __get_type_info:
        -: 1972:	      __dest._M_access<const type_info*>() = &typeid(_Functor);
        -: 1973:	      break;
        -: 1974:#endif
        -: 1975:	    case __get_functor_ptr:
        -: 1976:	      __dest._M_access<_Functor*>() = *_Base::_M_get_pointer(__source);
        -: 1977:	      return is_const<_Functor>::value;
        -: 1978:	      break;
        -: 1979:
        -: 1980:	    default:
        -: 1981:	      _Base::_M_manager(__dest, __source, __op);
        -: 1982:	    }
        -: 1983:	  return false;
        -: 1984:	}
        -: 1985:
        -: 1986:	static void
        -: 1987:	_M_init_functor(_Any_data& __functor, reference_wrapper<_Functor> __f)
        -: 1988:	{
        -: 1989:	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
        -: 1990:	}
        -: 1991:      };
        -: 1992:
        -: 1993:    _Function_base() : _M_manager(0) { }
        -: 1994:
        -: 1995:    ~_Function_base()
        -: 1996:    {
        -: 1997:      if (_M_manager)
        -: 1998:	_M_manager(_M_functor, _M_functor, __destroy_functor);
        -: 1999:    }
        -: 2000:
        -: 2001:
        -: 2002:    bool _M_empty() const { return !_M_manager; }
        -: 2003:
        -: 2004:    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,
        -: 2005:				  _Manager_operation);
        -: 2006:
        -: 2007:    _Any_data     _M_functor;
        -: 2008:    _Manager_type _M_manager;
        -: 2009:  };
        -: 2010:
        -: 2011:  template<typename _Signature, typename _Functor>
        -: 2012:    class _Function_handler;
        -: 2013:
        -: 2014:  template<typename _Res, typename _Functor, typename... _ArgTypes>
        -: 2015:    class _Function_handler<_Res(_ArgTypes...), _Functor>
        -: 2016:    : public _Function_base::_Base_manager<_Functor>
        -: 2017:    {
        -: 2018:      typedef _Function_base::_Base_manager<_Functor> _Base;
        -: 2019:
        -: 2020:    public:
        -: 2021:      static _Res
        -: 2022:      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
        -: 2023:      {
        -: 2024:	return (*_Base::_M_get_pointer(__functor))(
        -: 2025:	    std::forward<_ArgTypes>(__args)...);
        -: 2026:      }
        -: 2027:    };
        -: 2028:
        -: 2029:  template<typename _Functor, typename... _ArgTypes>
        -: 2030:    class _Function_handler<void(_ArgTypes...), _Functor>
        -: 2031:    : public _Function_base::_Base_manager<_Functor>
        -: 2032:    {
        -: 2033:      typedef _Function_base::_Base_manager<_Functor> _Base;
        -: 2034:
        -: 2035:     public:
        -: 2036:      static void
        -: 2037:      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
        -: 2038:      {
        -: 2039:	(*_Base::_M_get_pointer(__functor))(
        -: 2040:	    std::forward<_ArgTypes>(__args)...);
        -: 2041:      }
        -: 2042:    };
        -: 2043:
        -: 2044:  template<typename _Res, typename _Functor, typename... _ArgTypes>
        -: 2045:    class _Function_handler<_Res(_ArgTypes...), reference_wrapper<_Functor> >
        -: 2046:    : public _Function_base::_Ref_manager<_Functor>
        -: 2047:    {
        -: 2048:      typedef _Function_base::_Ref_manager<_Functor> _Base;
        -: 2049:
        -: 2050:     public:
        -: 2051:      static _Res
        -: 2052:      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
        -: 2053:      {
        -: 2054:	return __callable_functor(**_Base::_M_get_pointer(__functor))(
        -: 2055:	      std::forward<_ArgTypes>(__args)...);
        -: 2056:      }
        -: 2057:    };
        -: 2058:
        -: 2059:  template<typename _Functor, typename... _ArgTypes>
        -: 2060:    class _Function_handler<void(_ArgTypes...), reference_wrapper<_Functor> >
        -: 2061:    : public _Function_base::_Ref_manager<_Functor>
        -: 2062:    {
        -: 2063:      typedef _Function_base::_Ref_manager<_Functor> _Base;
        -: 2064:
        -: 2065:     public:
        -: 2066:      static void
        -: 2067:      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
        -: 2068:      {
        -: 2069:	__callable_functor(**_Base::_M_get_pointer(__functor))(
        -: 2070:	    std::forward<_ArgTypes>(__args)...);
        -: 2071:      }
        -: 2072:    };
        -: 2073:
        -: 2074:  template<typename _Class, typename _Member, typename _Res,
        -: 2075:	   typename... _ArgTypes>
        -: 2076:    class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>
        -: 2077:    : public _Function_handler<void(_ArgTypes...), _Member _Class::*>
        -: 2078:    {
        -: 2079:      typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>
        -: 2080:	_Base;
        -: 2081:
        -: 2082:     public:
        -: 2083:      static _Res
        -: 2084:      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
        -: 2085:      {
        -: 2086:	return std::mem_fn(_Base::_M_get_pointer(__functor)->__value)(
        -: 2087:	    std::forward<_ArgTypes>(__args)...);
        -: 2088:      }
        -: 2089:    };
        -: 2090:
        -: 2091:  template<typename _Class, typename _Member, typename... _ArgTypes>
        -: 2092:    class _Function_handler<void(_ArgTypes...), _Member _Class::*>
        -: 2093:    : public _Function_base::_Base_manager<
        -: 2094:		 _Simple_type_wrapper< _Member _Class::* > >
        -: 2095:    {
        -: 2096:      typedef _Member _Class::* _Functor;
        -: 2097:      typedef _Simple_type_wrapper<_Functor> _Wrapper;
        -: 2098:      typedef _Function_base::_Base_manager<_Wrapper> _Base;
        -: 2099:
        -: 2100:    public:
        -: 2101:      static bool
        -: 2102:      _M_manager(_Any_data& __dest, const _Any_data& __source,
        -: 2103:		 _Manager_operation __op)
        -: 2104:      {
        -: 2105:	switch (__op)
        -: 2106:	  {
        -: 2107:#ifdef __GXX_RTTI
        -: 2108:	  case __get_type_info:
        -: 2109:	    __dest._M_access<const type_info*>() = &typeid(_Functor);
        -: 2110:	    break;
        -: 2111:#endif
        -: 2112:	  case __get_functor_ptr:
        -: 2113:	    __dest._M_access<_Functor*>() =
        -: 2114:	      &_Base::_M_get_pointer(__source)->__value;
        -: 2115:	    break;
        -: 2116:
        -: 2117:	  default:
        -: 2118:	    _Base::_M_manager(__dest, __source, __op);
        -: 2119:	  }
        -: 2120:	return false;
        -: 2121:      }
        -: 2122:
        -: 2123:      static void
        -: 2124:      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
        -: 2125:      {
        -: 2126:	std::mem_fn(_Base::_M_get_pointer(__functor)->__value)(
        -: 2127:	    std::forward<_ArgTypes>(__args)...);
        -: 2128:      }
        -: 2129:    };
        -: 2130:
        -: 2131:  template<typename _From, typename _To>
        -: 2132:    using __check_func_return_type
        -: 2133:      = __or_<is_void<_To>, is_convertible<_From, _To>>;
        -: 2134:
        -: 2135:  /**
        -: 2136:   *  @brief Primary class template for std::function.
        -: 2137:   *  @ingroup functors
        -: 2138:   *
        -: 2139:   *  Polymorphic function wrapper.
        -: 2140:   */
        -: 2141:  template<typename _Res, typename... _ArgTypes>
        -: 2142:    class function<_Res(_ArgTypes...)>
        -: 2143:    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
        -: 2144:      private _Function_base
        -: 2145:    {
        -: 2146:      typedef _Res _Signature_type(_ArgTypes...);
        -: 2147:
        -: 2148:      template<typename _Functor>
        -: 2149:	using _Invoke = decltype(__callable_functor(std::declval<_Functor&>())
        -: 2150:				 (std::declval<_ArgTypes>()...) );
        -: 2151:
        -: 2152:      // Used so the return type convertibility checks aren't done when
        -: 2153:      // performing overload resolution for copy construction/assignment.
        -: 2154:      template<typename _Tp>
        -: 2155:	using _NotSelf = __not_<is_same<_Tp, function>>;
        -: 2156:
        -: 2157:      template<typename _Functor>
        -: 2158:	using _Callable
        -: 2159:	  = __and_<_NotSelf<_Functor>,
        -: 2160:		   __check_func_return_type<_Invoke<_Functor>, _Res>>;
        -: 2161:
        -: 2162:      template<typename _Cond, typename _Tp>
        -: 2163:	using _Requires = typename enable_if<_Cond::value, _Tp>::type;
        -: 2164:
        -: 2165:    public:
        -: 2166:      typedef _Res result_type;
        -: 2167:
        -: 2168:      // [3.7.2.1] construct/copy/destroy
        -: 2169:
        -: 2170:      /**
        -: 2171:       *  @brief Default construct creates an empty function call wrapper.
        -: 2172:       *  @post @c !(bool)*this
        -: 2173:       */
        -: 2174:      function() noexcept
        -: 2175:      : _Function_base() { }
        -: 2176:
        -: 2177:      /**
        -: 2178:       *  @brief Creates an empty function call wrapper.
        -: 2179:       *  @post @c !(bool)*this
        -: 2180:       */
        -: 2181:      function(nullptr_t) noexcept
        -: 2182:      : _Function_base() { }
        -: 2183:
        -: 2184:      /**
        -: 2185:       *  @brief %Function copy constructor.
        -: 2186:       *  @param __x A %function object with identical call signature.
        -: 2187:       *  @post @c bool(*this) == bool(__x)
        -: 2188:       *
        -: 2189:       *  The newly-created %function contains a copy of the target of @a
        -: 2190:       *  __x (if it has one).
        -: 2191:       */
        -: 2192:      function(const function& __x);
        -: 2193:
        -: 2194:      /**
        -: 2195:       *  @brief %Function move constructor.
        -: 2196:       *  @param __x A %function object rvalue with identical call signature.
        -: 2197:       *
        -: 2198:       *  The newly-created %function contains the target of @a __x
        -: 2199:       *  (if it has one).
        -: 2200:       */
        -: 2201:      function(function&& __x) : _Function_base()
        -: 2202:      {
        -: 2203:	__x.swap(*this);
        -: 2204:      }
        -: 2205:
        -: 2206:      // TODO: needs allocator_arg_t
        -: 2207:
        -: 2208:      /**
        -: 2209:       *  @brief Builds a %function that targets a copy of the incoming
        -: 2210:       *  function object.
        -: 2211:       *  @param __f A %function object that is callable with parameters of
        -: 2212:       *  type @c T1, @c T2, ..., @c TN and returns a value convertible
        -: 2213:       *  to @c Res.
        -: 2214:       *
        -: 2215:       *  The newly-created %function object will target a copy of 
        -: 2216:       *  @a __f. If @a __f is @c reference_wrapper<F>, then this function
        -: 2217:       *  object will contain a reference to the function object @c
        -: 2218:       *  __f.get(). If @a __f is a NULL function pointer or NULL
        -: 2219:       *  pointer-to-member, the newly-created object will be empty.
        -: 2220:       *
        -: 2221:       *  If @a __f is a non-NULL function pointer or an object of type @c
        -: 2222:       *  reference_wrapper<F>, this function will not throw.
        -: 2223:       */
        -: 2224:      template<typename _Functor,
        -: 2225:	       typename = _Requires<_Callable<_Functor>, void>>
        -: 2226:	function(_Functor);
        -: 2227:
        -: 2228:      /**
        -: 2229:       *  @brief %Function assignment operator.
        -: 2230:       *  @param __x A %function with identical call signature.
        -: 2231:       *  @post @c (bool)*this == (bool)x
        -: 2232:       *  @returns @c *this
        -: 2233:       *
        -: 2234:       *  The target of @a __x is copied to @c *this. If @a __x has no
        -: 2235:       *  target, then @c *this will be empty.
        -: 2236:       *
        -: 2237:       *  If @a __x targets a function pointer or a reference to a function
        -: 2238:       *  object, then this operation will not throw an %exception.
        -: 2239:       */
        -: 2240:      function&
        -: 2241:      operator=(const function& __x)
        -: 2242:      {
        -: 2243:	function(__x).swap(*this);
        -: 2244:	return *this;
        -: 2245:      }
        -: 2246:
        -: 2247:      /**
        -: 2248:       *  @brief %Function move-assignment operator.
        -: 2249:       *  @param __x A %function rvalue with identical call signature.
        -: 2250:       *  @returns @c *this
        -: 2251:       *
        -: 2252:       *  The target of @a __x is moved to @c *this. If @a __x has no
        -: 2253:       *  target, then @c *this will be empty.
        -: 2254:       *
        -: 2255:       *  If @a __x targets a function pointer or a reference to a function
        -: 2256:       *  object, then this operation will not throw an %exception.
        -: 2257:       */
        -: 2258:      function&
        -: 2259:      operator=(function&& __x)
        -: 2260:      {
        -: 2261:	function(std::move(__x)).swap(*this);
        -: 2262:	return *this;
        -: 2263:      }
        -: 2264:
        -: 2265:      /**
        -: 2266:       *  @brief %Function assignment to zero.
        -: 2267:       *  @post @c !(bool)*this
        -: 2268:       *  @returns @c *this
        -: 2269:       *
        -: 2270:       *  The target of @c *this is deallocated, leaving it empty.
        -: 2271:       */
        -: 2272:      function&
        -: 2273:      operator=(nullptr_t)
        -: 2274:      {
        -: 2275:	if (_M_manager)
        -: 2276:	  {
        -: 2277:	    _M_manager(_M_functor, _M_functor, __destroy_functor);
        -: 2278:	    _M_manager = 0;
        -: 2279:	    _M_invoker = 0;
        -: 2280:	  }
        -: 2281:	return *this;
        -: 2282:      }
        -: 2283:
        -: 2284:      /**
        -: 2285:       *  @brief %Function assignment to a new target.
        -: 2286:       *  @param __f A %function object that is callable with parameters of
        -: 2287:       *  type @c T1, @c T2, ..., @c TN and returns a value convertible
        -: 2288:       *  to @c Res.
        -: 2289:       *  @return @c *this
        -: 2290:       *
        -: 2291:       *  This  %function object wrapper will target a copy of @a
        -: 2292:       *  __f. If @a __f is @c reference_wrapper<F>, then this function
        -: 2293:       *  object will contain a reference to the function object @c
        -: 2294:       *  __f.get(). If @a __f is a NULL function pointer or NULL
        -: 2295:       *  pointer-to-member, @c this object will be empty.
        -: 2296:       *
        -: 2297:       *  If @a __f is a non-NULL function pointer or an object of type @c
        -: 2298:       *  reference_wrapper<F>, this function will not throw.
        -: 2299:       */
        -: 2300:      template<typename _Functor>
        -: 2301:	_Requires<_Callable<typename decay<_Functor>::type>, function&>
        -: 2302:	operator=(_Functor&& __f)
        -: 2303:	{
        -: 2304:	  function(std::forward<_Functor>(__f)).swap(*this);
        -: 2305:	  return *this;
        -: 2306:	}
        -: 2307:
        -: 2308:      /// @overload
        -: 2309:      template<typename _Functor>
        -: 2310:	function&
        -: 2311:	operator=(reference_wrapper<_Functor> __f) noexcept
        -: 2312:	{
        -: 2313:	  function(__f).swap(*this);
        -: 2314:	  return *this;
        -: 2315:	}
        -: 2316:
        -: 2317:      // [3.7.2.2] function modifiers
        -: 2318:
        -: 2319:      /**
        -: 2320:       *  @brief Swap the targets of two %function objects.
        -: 2321:       *  @param __x A %function with identical call signature.
        -: 2322:       *
        -: 2323:       *  Swap the targets of @c this function object and @a __f. This
        -: 2324:       *  function will not throw an %exception.
        -: 2325:       */
        -: 2326:      void swap(function& __x)
        -: 2327:      {
        -: 2328:	std::swap(_M_functor, __x._M_functor);
        -: 2329:	std::swap(_M_manager, __x._M_manager);
        -: 2330:	std::swap(_M_invoker, __x._M_invoker);
        -: 2331:      }
        -: 2332:
        -: 2333:      // TODO: needs allocator_arg_t
        -: 2334:      /*
        -: 2335:      template<typename _Functor, typename _Alloc>
        -: 2336:	void
        -: 2337:	assign(_Functor&& __f, const _Alloc& __a)
        -: 2338:	{
        -: 2339:	  function(allocator_arg, __a,
        -: 2340:		   std::forward<_Functor>(__f)).swap(*this);
        -: 2341:	}
        -: 2342:      */
        -: 2343:
        -: 2344:      // [3.7.2.3] function capacity
        -: 2345:
        -: 2346:      /**
        -: 2347:       *  @brief Determine if the %function wrapper has a target.
        -: 2348:       *
        -: 2349:       *  @return @c true when this %function object contains a target,
        -: 2350:       *  or @c false when it is empty.
        -: 2351:       *
        -: 2352:       *  This function will not throw an %exception.
        -: 2353:       */
        -: 2354:      explicit operator bool() const noexcept
        -: 2355:      { return !_M_empty(); }
        -: 2356:
        -: 2357:      // [3.7.2.4] function invocation
        -: 2358:
        -: 2359:      /**
        -: 2360:       *  @brief Invokes the function targeted by @c *this.
        -: 2361:       *  @returns the result of the target.
        -: 2362:       *  @throws bad_function_call when @c !(bool)*this
        -: 2363:       *
        -: 2364:       *  The function call operator invokes the target function object
        -: 2365:       *  stored by @c this.
        -: 2366:       */
        -: 2367:      _Res operator()(_ArgTypes... __args) const;
        -: 2368:
        -: 2369:#ifdef __GXX_RTTI
        -: 2370:      // [3.7.2.5] function target access
        -: 2371:      /**
        -: 2372:       *  @brief Determine the type of the target of this function object
        -: 2373:       *  wrapper.
        -: 2374:       *
        -: 2375:       *  @returns the type identifier of the target function object, or
        -: 2376:       *  @c typeid(void) if @c !(bool)*this.
        -: 2377:       *
        -: 2378:       *  This function will not throw an %exception.
        -: 2379:       */
        -: 2380:      const type_info& target_type() const noexcept;
        -: 2381:
        -: 2382:      /**
        -: 2383:       *  @brief Access the stored target function object.
        -: 2384:       *
        -: 2385:       *  @return Returns a pointer to the stored target function object,
        -: 2386:       *  if @c typeid(Functor).equals(target_type()); otherwise, a NULL
        -: 2387:       *  pointer.
        -: 2388:       *
        -: 2389:       * This function will not throw an %exception.
        -: 2390:       */
        -: 2391:      template<typename _Functor>       _Functor* target() noexcept;
        -: 2392:
        -: 2393:      /// @overload
        -: 2394:      template<typename _Functor> const _Functor* target() const noexcept;
        -: 2395:#endif
        -: 2396:
        -: 2397:    private:
        -: 2398:      typedef _Res (*_Invoker_type)(const _Any_data&, _ArgTypes...);
        -: 2399:      _Invoker_type _M_invoker;
        -: 2400:  };
        -: 2401:
        -: 2402:  // Out-of-line member definitions.
        -: 2403:  template<typename _Res, typename... _ArgTypes>
        -: 2404:    function<_Res(_ArgTypes...)>::
        -: 2405:    function(const function& __x)
        -: 2406:    : _Function_base()
        -: 2407:    {
        -: 2408:      if (static_cast<bool>(__x))
        -: 2409:	{
        -: 2410:	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
        -: 2411:	  _M_invoker = __x._M_invoker;
        -: 2412:	  _M_manager = __x._M_manager;
        -: 2413:	}
        -: 2414:    }
        -: 2415:
        -: 2416:  template<typename _Res, typename... _ArgTypes>
        -: 2417:    template<typename _Functor, typename>
        -: 2418:      function<_Res(_ArgTypes...)>::
        -: 2419:      function(_Functor __f)
        -: 2420:      : _Function_base()
        -: 2421:      {
        -: 2422:	typedef _Function_handler<_Signature_type, _Functor> _My_handler;
        -: 2423:
        -: 2424:	if (_My_handler::_M_not_empty_function(__f))
        -: 2425:	  {
        -: 2426:	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
        -: 2427:	    _M_invoker = &_My_handler::_M_invoke;
        -: 2428:	    _M_manager = &_My_handler::_M_manager;
        -: 2429:	  }
        -: 2430:      }
        -: 2431:
        -: 2432:  template<typename _Res, typename... _ArgTypes>
        -: 2433:    _Res
        -: 2434:    function<_Res(_ArgTypes...)>::
        -: 2435:    operator()(_ArgTypes... __args) const
        -: 2436:    {
        -: 2437:      if (_M_empty())
        -: 2438:	__throw_bad_function_call();
        -: 2439:      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
        -: 2440:    }
        -: 2441:
        -: 2442:#ifdef __GXX_RTTI
        -: 2443:  template<typename _Res, typename... _ArgTypes>
        -: 2444:    const type_info&
        -: 2445:    function<_Res(_ArgTypes...)>::
        -: 2446:    target_type() const noexcept
        -: 2447:    {
        -: 2448:      if (_M_manager)
        -: 2449:	{
        -: 2450:	  _Any_data __typeinfo_result;
        -: 2451:	  _M_manager(__typeinfo_result, _M_functor, __get_type_info);
        -: 2452:	  return *__typeinfo_result._M_access<const type_info*>();
        -: 2453:	}
        -: 2454:      else
        -: 2455:	return typeid(void);
        -: 2456:    }
        -: 2457:
        -: 2458:  template<typename _Res, typename... _ArgTypes>
        -: 2459:    template<typename _Functor>
        -: 2460:      _Functor*
        -: 2461:      function<_Res(_ArgTypes...)>::
        -: 2462:      target() noexcept
        -: 2463:      {
        -: 2464:	if (typeid(_Functor) == target_type() && _M_manager)
        -: 2465:	  {
        -: 2466:	    _Any_data __ptr;
        -: 2467:	    if (_M_manager(__ptr, _M_functor, __get_functor_ptr)
        -: 2468:		&& !is_const<_Functor>::value)
        -: 2469:	      return 0;
        -: 2470:	    else
        -: 2471:	      return __ptr._M_access<_Functor*>();
        -: 2472:	  }
        -: 2473:	else
        -: 2474:	  return 0;
        -: 2475:      }
        -: 2476:
        -: 2477:  template<typename _Res, typename... _ArgTypes>
        -: 2478:    template<typename _Functor>
        -: 2479:      const _Functor*
        -: 2480:      function<_Res(_ArgTypes...)>::
        -: 2481:      target() const noexcept
        -: 2482:      {
        -: 2483:	if (typeid(_Functor) == target_type() && _M_manager)
        -: 2484:	  {
        -: 2485:	    _Any_data __ptr;
        -: 2486:	    _M_manager(__ptr, _M_functor, __get_functor_ptr);
        -: 2487:	    return __ptr._M_access<const _Functor*>();
        -: 2488:	  }
        -: 2489:	else
        -: 2490:	  return 0;
        -: 2491:      }
        -: 2492:#endif
        -: 2493:
        -: 2494:  // [20.7.15.2.6] null pointer comparisons
        -: 2495:
        -: 2496:  /**
        -: 2497:   *  @brief Compares a polymorphic function object wrapper against 0
        -: 2498:   *  (the NULL pointer).
        -: 2499:   *  @returns @c true if the wrapper has no target, @c false otherwise
        -: 2500:   *
        -: 2501:   *  This function will not throw an %exception.
        -: 2502:   */
        -: 2503:  template<typename _Res, typename... _Args>
        -: 2504:    inline bool
        -: 2505:    operator==(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
        -: 2506:    { return !static_cast<bool>(__f); }
        -: 2507:
        -: 2508:  /// @overload
        -: 2509:  template<typename _Res, typename... _Args>
        -: 2510:    inline bool
        -: 2511:    operator==(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
        -: 2512:    { return !static_cast<bool>(__f); }
        -: 2513:
        -: 2514:  /**
        -: 2515:   *  @brief Compares a polymorphic function object wrapper against 0
        -: 2516:   *  (the NULL pointer).
        -: 2517:   *  @returns @c false if the wrapper has no target, @c true otherwise
        -: 2518:   *
        -: 2519:   *  This function will not throw an %exception.
        -: 2520:   */
        -: 2521:  template<typename _Res, typename... _Args>
        -: 2522:    inline bool
        -: 2523:    operator!=(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
        -: 2524:    { return static_cast<bool>(__f); }
        -: 2525:
        -: 2526:  /// @overload
        -: 2527:  template<typename _Res, typename... _Args>
        -: 2528:    inline bool
        -: 2529:    operator!=(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
        -: 2530:    { return static_cast<bool>(__f); }
        -: 2531:
        -: 2532:  // [20.7.15.2.7] specialized algorithms
        -: 2533:
        -: 2534:  /**
        -: 2535:   *  @brief Swap the targets of two polymorphic function object wrappers.
        -: 2536:   *
        -: 2537:   *  This function will not throw an %exception.
        -: 2538:   */
        -: 2539:  template<typename _Res, typename... _Args>
        -: 2540:    inline void
        -: 2541:    swap(function<_Res(_Args...)>& __x, function<_Res(_Args...)>& __y)
        -: 2542:    { __x.swap(__y); }
        -: 2543:
        -: 2544:_GLIBCXX_END_NAMESPACE_VERSION
        -: 2545:} // namespace std
        -: 2546:
        -: 2547:#endif // C++11
        -: 2548:
        -: 2549:#endif // _GLIBCXX_FUNCTIONAL
