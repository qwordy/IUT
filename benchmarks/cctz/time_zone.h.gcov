        -:    0:Source:include/time_zone.h
        -:    0:Graph:/home/yfy/iut/benchmarks/cctz/time_zone_impl.gcno
        -:    0:Data:/home/yfy/iut/benchmarks/cctz/time_zone_impl.gcda
        -:    0:Runs:17
        -:    0:Programs:1
        -:    1:// Copyright 2016 Google Inc. All Rights Reserved.
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://   http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9://   Unless required by applicable law or agreed to in writing, software
        -:   10://   distributed under the License is distributed on an "AS IS" BASIS,
        -:   11://   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12://   See the License for the specific language governing permissions and
        -:   13://   limitations under the License.
        -:   14:
        -:   15:// A library for translating between absolute times (represented by
        -:   16:// std::chrono::time_points of the std::chrono::system_clock) and civil
        -:   17:// times (represented by cctz::civil_second) using the rules defined by
        -:   18:// a time zone (cctz::time_zone).
        -:   19:
        -:   20:#ifndef CCTZ_TIME_ZONE_H_
        -:   21:#define CCTZ_TIME_ZONE_H_
        -:   22:
        -:   23:#include <chrono>
        -:   24:#include <string>
        -:   25:
        -:   26:#include "civil_time.h"
        -:   27:
        -:   28:namespace cctz {
        -:   29:
        -:   30:// Convenience aliases. Not intended as public API points.
        -:   31:template <typename D>
        -:   32:using time_point = std::chrono::time_point<std::chrono::system_clock, D>;
        -:   33:using sys_seconds = std::chrono::duration<std::chrono::system_clock::rep,
        -:   34:                                          std::chrono::seconds::period>;
        -:   35:
        -:   36:// cctz::time_zone is an opaque, small, value-type class representing a
        -:   37:// geo-political region within which particular rules are used for mapping
        -:   38:// between absolute and civil times. Time zones are named using the TZ
        -:   39:// identifiers from the IANA Time Zone Database, such as "America/Los_Angeles"
        -:   40:// or "Australia/Sydney". Time zones are created from factory functions such
        -:   41:// as load_time_zone(). Note: strings like "PST" and "EDT" are not valid TZ
        -:   42:// identifiers.
        -:   43://
        -:   44:// Example:
        -:   45://   cctz::time_zone utc = cctz::utc_time_zone();
        -:   46://   cctz::time_zone loc = cctz::local_time_zone();
        -:   47://   cctz::time_zone lax;
        -:   48://   if (!cctz::load_time_zone("America/Los_Angeles", &lax)) { ... }
        -:   49://
        -:   50:// See also:
        -:   51:// - http://www.iana.org/time-zones
        -:   52:// - http://en.wikipedia.org/wiki/Zoneinfo
        -:   53:class time_zone {
        -:   54: public:
        -:   55:  time_zone() = default;  // Equivalent to UTC
        -:   56:  time_zone(const time_zone&) = default;
        -:   57:  time_zone& operator=(const time_zone&) = default;
        -:   58:
        -:   59:  // An absolute_lookup represents the civil time (cctz::civil_second) within
        -:   60:  // this time_zone at the given absolute time (time_point). There are
        -:   61:  // additionally a few other fields that may be useful when working with
        -:   62:  // older APIs, such as std::tm.
        -:   63:  //
        -:   64:  // Example:
        -:   65:  //   const cctz::time_zone tz = ...
        -:   66:  //   const auto tp = std::chrono::system_clock::now();
        -:   67:  //   const cctz::time_zone::absolute_lookup al = tz.lookup(tp);
     1445:   68:  struct absolute_lookup {
call    0 returned 100%
        -:   69:    civil_second cs;
        -:   70:    // Note: The following fields exist for backward compatibility with older
        -:   71:    // APIs. Accessing these fields directly is a sign of imprudent logic in
        -:   72:    // the calling code. Modern time-related code should only access this data
        -:   73:    // indirectly by way of cctz::format().
        -:   74:    int offset;        // civil seconds east of UTC
        -:   75:    bool is_dst;       // is offset non-standard?
        -:   76:    std::string abbr;  // time-zone abbreviation (e.g., "PST")
        -:   77:  };
        -:   78:  absolute_lookup lookup(const time_point<sys_seconds>& tp) const;
        -:   79:  template <typename D>
        -:   80:  absolute_lookup lookup(const time_point<D>& tp) const {
        -:   81:    return lookup(std::chrono::time_point_cast<sys_seconds>(tp));
        -:   82:  }
        -:   83:
        -:   84:  // A civil_lookup represents the absolute time(s) (time_point) that
        -:   85:  // correspond to the given civil time (cctz::civil_second) within this
        -:   86:  // time_zone. Usually the given civil time represents a unique instant in
        -:   87:  // time, in which case the conversion is unambiguous and correct. However,
        -:   88:  // within this time zone, the given civil time may be skipped (e.g., during
        -:   89:  // a positive UTC offset shift), or repeated (e.g., during a negative UTC
        -:   90:  // offset shift). To account for these possibilities, civil_lookup is richer
        -:   91:  // than just a single output time_point.
        -:   92:  //
        -:   93:  // In all cases the civil_lookup::kind enum will indicate the nature of the
        -:   94:  // given civil-time argument, and the pre, trans, and post, members will
        -:   95:  // give the absolute time answers using the pre-transition offset, the
        -:   96:  // transition point itself, and the post-transition offset, respectively
        -:   97:  // (these are all equal if kind == UNIQUE).
        -:   98:  //
        -:   99:  // Example:
        -:  100:  //   cctz::time_zone lax;
        -:  101:  //   if (!cctz::load_time_zone("America/Los_Angeles", &lax)) { ... }
        -:  102:  //
        -:  103:  //   // A unique civil time.
        -:  104:  //   auto jan01 = lax.lookup(cctz::civil_second(2011, 1, 1, 0, 0, 0));
        -:  105:  //   // jan01.kind == cctz::time_zone::civil_lookup::UNIQUE
        -:  106:  //   // jan01.pre    is 2011/01/01 00:00:00 -0800
        -:  107:  //   // jan01.trans  is 2011/01/01 00:00:00 -0800
        -:  108:  //   // jan01.post   is 2011/01/01 00:00:00 -0800
        -:  109:  //
        -:  110:  //   // A Spring DST transition, when there is a gap in civil time.
        -:  111:  //   auto mar13 = lax.lookup(cctz::civil_second(2011, 3, 13, 2, 15, 0));
        -:  112:  //   // mar13.kind == cctz::time_zone::civil_lookup::SKIPPED
        -:  113:  //   // mar13.pre   is 2011/03/13 03:15:00 -0700
        -:  114:  //   // mar13.trans is 2011/03/13 03:00:00 -0700
        -:  115:  //   // mar13.post  is 2011/03/13 01:15:00 -0800
        -:  116:  //
        -:  117:  //   // A Fall DST transition, when civil times are repeated.
        -:  118:  //   auto nov06 = lax.lookup(cctz::civil_second(2011, 11, 6, 1, 15, 0));
        -:  119:  //   // nov06.kind == cctz::time_zone::civil_lookup::REPEATED
        -:  120:  //   // nov06.pre   is 2011/11/06 01:15:00 -0700
        -:  121:  //   // nov06.trans is 2011/11/06 01:00:00 -0800
        -:  122:  //   // nov06.post  is 2011/11/06 01:15:00 -0800
        -:  123:  struct civil_lookup {
        -:  124:    enum civil_kind {
        -:  125:      UNIQUE,    // the civil time was singular (pre == trans == post)
        -:  126:      SKIPPED,   // the civil time did not exist
        -:  127:      REPEATED,  // the civil time was ambiguous
        -:  128:    } kind;
        -:  129:    time_point<sys_seconds> pre;    // Uses the pre-transition offset
        -:  130:    time_point<sys_seconds> trans;  // Instant of civil-offset change
        -:  131:    time_point<sys_seconds> post;   // Uses the post-transition offset
        -:  132:  };
        -:  133:  civil_lookup lookup(const civil_second& cs) const;
        -:  134:
        -:  135:  class Impl;
        -:  136:
        -:  137: private:
        -:  138:  explicit time_zone(const Impl* impl) : impl_(impl) {}
        -:  139:  const Impl* impl_ = nullptr;
        -:  140:};
        -:  141:
        -:  142:// Loads the named time zone. May perform I/O on the initial load.
        -:  143:// If the name is invalid, or some other kind of error occurs, returns
        -:  144:// false and "*tz" is set to the UTC time zone.
        -:  145:bool load_time_zone(const std::string& name, time_zone* tz);
        -:  146:
        -:  147:// Returns a time_zone representing UTC. Cannot fail.
        -:  148:time_zone utc_time_zone();
        -:  149:
        -:  150:// Returns a time zone representing the local time zone. Falls back to UTC.
        -:  151:time_zone local_time_zone();
        -:  152:
        -:  153:// Returns the civil time (cctz::civil_second) within the given time zone at
        -:  154:// the given absolute time (time_point). Since the additional fields provided
        -:  155:// by the time_zone::absolute_lookup struct should rarely be needed in modern
        -:  156:// code, this convert() function is simpler and should be preferred.
        -:  157:template <typename D>
        -:  158:inline civil_second convert(const time_point<D>& tp, const time_zone& tz) {
        -:  159:  return tz.lookup(tp).cs;
        -:  160:}
        -:  161:
        -:  162:// Returns the absolute time (time_point) that corresponds to the given civil
        -:  163:// time within the given time zone. If the civil time is not unique (i.e., if
        -:  164:// it was either repeated or non-existent), then the returned time_point is
        -:  165:// the best estimate that preserves relative order. That is, this function
        -:  166:// guarantees that if cs1 < cs2, then convert(cs1, tz) <= convert(cs2, tz).
        -:  167:inline time_point<sys_seconds> convert(const civil_second& cs,
        -:  168:                                       const time_zone& tz) {
        -:  169:  const time_zone::civil_lookup cl = tz.lookup(cs);
        -:  170:  if (cl.kind == time_zone::civil_lookup::SKIPPED) return cl.trans;
        -:  171:  return cl.pre;
        -:  172:}
        -:  173:
        -:  174:namespace detail {
        -:  175:template <typename D>
        -:  176:inline std::pair<time_point<sys_seconds>, D>
        -:  177:split_seconds(const time_point<D>& tp) {
        -:  178:  auto sec = std::chrono::time_point_cast<sys_seconds>(tp);
        -:  179:  auto sub = tp - sec;
        -:  180:  if (sub.count() < 0) {
        -:  181:    sec -= sys_seconds(1);
        -:  182:    sub += sys_seconds(1);
        -:  183:  }
        -:  184:  return {sec, std::chrono::duration_cast<D>(sub)};
        -:  185:}
        -:  186:inline std::pair<time_point<sys_seconds>, sys_seconds>
        -:  187:split_seconds(const time_point<sys_seconds>& tp) {
        -:  188:  return {tp, sys_seconds(0)};
        -:  189:}
        -:  190:std::string format(const std::string&, const time_point<sys_seconds>&,
        -:  191:                   const std::chrono::nanoseconds&, const time_zone&);
        -:  192:bool parse(const std::string&, const std::string&, const time_zone&,
        -:  193:           time_point<sys_seconds>*, std::chrono::nanoseconds*);
        -:  194:}  // namespace detail
        -:  195:
        -:  196:// Formats the given time_point in the given cctz::time_zone according to
        -:  197:// the provided format string. Uses strftime()-like formatting options,
        -:  198:// with the following extensions:
        -:  199://
        -:  200://   - %Ez  - RFC3339-compatible numeric time zone (+hh:mm or -hh:mm)
        -:  201://   - %E#S - Seconds with # digits of fractional precision
        -:  202://   - %E*S - Seconds with full fractional precision (a literal '*')
        -:  203://   - %E#f - Fractional seconds with # digits of precision
        -:  204://   - %E*f - Fractional seconds with full precision (a literal '*')
        -:  205://   - %E4Y - Four-character years (-999 ... -001, 0000, 0001 ... 9999)
        -:  206://
        -:  207:// Note that %E0S behaves like %S, and %E0f produces no characters.  In
        -:  208:// contrast %E*f always produces at least one digit, which may be '0'.
        -:  209://
        -:  210:// Note that %Y produces as many characters as it takes to fully render the
        -:  211:// year. A year outside of [-999:9999] when formatted with %E4Y will produce
        -:  212:// more than four characters, just like %Y.
        -:  213://
        -:  214:// Tip: Format strings should include the UTC offset (e.g., %z or %Ez) so that
        -:  215:// the resultng string uniquely identifies an absolute time.
        -:  216://
        -:  217:// Example:
        -:  218://   cctz::time_zone lax;
        -:  219://   if (!cctz::load_time_zone("America/Los_Angeles", &lax)) { ... }
        -:  220://   auto tp = cctz::convert(cctz::civil_second(2013, 1, 2, 3, 4, 5), lax);
        -:  221://   std::string f = cctz::format("%H:%M:%S", tp, lax);  // "03:04:05"
        -:  222://   f = cctz::format("%H:%M:%E3S", tp, lax);            // "03:04:05.000"
        -:  223:template <typename D>
        -:  224:inline std::string format(const std::string& fmt, const time_point<D>& tp,
        -:  225:                          const time_zone& tz) {
        -:  226:  const auto p = detail::split_seconds(tp);
        -:  227:  const auto n = std::chrono::duration_cast<std::chrono::nanoseconds>(p.second);
        -:  228:  return detail::format(fmt, p.first, n, tz);
        -:  229:}
        -:  230:
        -:  231:// Parses an input string according to the provided format string and
        -:  232:// returns the corresponding time_point. Uses strftime()-like formatting
        -:  233:// options, with the same extensions as cctz::format(), but with the
        -:  234:// exceptions that %E#S is interpreted as %E*S, and %E#f as %E*f.
        -:  235://
        -:  236:// %Y consumes as many numeric characters as it can, so the matching data
        -:  237:// should always be terminated with a non-numeric. %E4Y always consumes
        -:  238:// exactly four characters, including any sign.
        -:  239://
        -:  240:// Unspecified fields are taken from the default date and time of ...
        -:  241://
        -:  242://   "1970-01-01 00:00:00.0 +0000"
        -:  243://
        -:  244:// For example, parsing a string of "15:45" (%H:%M) will return a time_point
        -:  245:// that represents "1970-01-01 15:45:00.0 +0000".
        -:  246://
        -:  247:// Note that parse() returns time instants, so it makes most sense to parse
        -:  248:// fully-specified date/time strings that include a UTC offset (%z or %Ez).
        -:  249://
        -:  250:// Note also that parse() only heeds the fields year, month, day, hour,
        -:  251:// minute, (fractional) second, and UTC offset. Other fields, like weekday (%a
        -:  252:// or %A), while parsed for syntactic validity, are ignored in the conversion.
        -:  253://
        -:  254:// Date and time fields that are out-of-range will be treated as errors rather
        -:  255:// than normalizing them like cctz::civil_second() would do. For example, it
        -:  256:// is an error to parse the date "Oct 32, 2013" because 32 is out of range.
        -:  257://
        -:  258:// A second of ":60" is normalized to ":00" of the following minute with
        -:  259:// fractional seconds discarded. The following table shows how the given
        -:  260:// seconds and subseconds will be parsed:
        -:  261://
        -:  262://   "59.x" -> 59.x  // exact
        -:  263://   "60.x" -> 00.0  // normalized
        -:  264://   "00.x" -> 00.x  // exact
        -:  265://
        -:  266:// Errors are indicated by returning false.
        -:  267://
        -:  268:// Example:
        -:  269://   const cctz::time_zone tz = ...
        -:  270://   std::chrono::system_clock::time_point tp;
        -:  271://   if (cctz::parse("%Y-%m-%d", "2015-10-09", tz, &tp)) {
        -:  272://     ...
        -:  273://   }
        -:  274:template <typename D>
        -:  275:inline bool parse(const std::string& fmt, const std::string& input,
        -:  276:                  const time_zone& tz, time_point<D>* tpp) {
        -:  277:  time_point<sys_seconds> tp{};
        -:  278:  std::chrono::nanoseconds ns{0};
        -:  279:  const bool b = detail::parse(fmt, input, tz, &tp, &ns);
        -:  280:  if (b) {
        -:  281:    *tpp = std::chrono::time_point_cast<D>(tp);
        -:  282:    *tpp += std::chrono::duration_cast<D>(ns);
        -:  283:  }
        -:  284:  return b;
        -:  285:}
        -:  286:
        -:  287:}  // namespace cctz
        -:  288:
        -:  289:#endif  // CCTZ_TIME_ZONE_H_
