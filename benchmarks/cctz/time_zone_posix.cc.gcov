        -:    0:Source:src/time_zone_posix.cc
        -:    0:Graph:/home/yfy/iut/benchmarks/cctz/time_zone_posix.gcno
        -:    0:Data:/home/yfy/iut/benchmarks/cctz/time_zone_posix.gcda
        -:    0:Runs:3
        -:    0:Programs:1
        -:    1:// Copyright 2016 Google Inc. All Rights Reserved.
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://   http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9://   Unless required by applicable law or agreed to in writing, software
        -:   10://   distributed under the License is distributed on an "AS IS" BASIS,
        -:   11://   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12://   See the License for the specific language governing permissions and
        -:   13://   limitations under the License.
        -:   14:
        -:   15:#include "time_zone_posix.h"
        -:   16:
        -:   17:#include <cstring>
        -:   18:#include <limits>
        -:   19:#include <string>
        -:   20:
        -:   21:namespace cctz {
        -:   22:
        -:   23:namespace {
        -:   24:
        -:   25:const char kDigits[] = "0123456789";
        -:   26:
function _ZN4cctz12_GLOBAL__N_18ParseIntEPKciiPi called 4224 returned 100% blocks executed 100%
     4224:   27:const char* ParseInt(const char* p, int min, int max, int* vp) {
        -:   28:  int value = 0;
        -:   29:  const char* op = p;
        -:   30:  const int kMaxInt = std::numeric_limits<int>::max();
    23154:   31:  for (; const char* dp = strchr(kDigits, *p); ++p) {
branch  0 taken 66% (fallthrough)
branch  1 taken 34%
     6064:   32:    int d = static_cast<int>(dp - kDigits);
     6064:   33:    if (d >= 10) break;  // '\0'
branch  0 taken 81% (fallthrough)
branch  1 taken 19%
     4902:   34:    if (value > kMaxInt / 10) return nullptr;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     4902:   35:    value *= 10;
     4902:   36:    if (value > kMaxInt - d) return nullptr;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     4902:   37:    value += d;
     4902:   38:  }
     4224:   39:  if (p == op || value < min || value > max) return nullptr;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     4224:   40:  *vp = value;
     4224:   41:  return p;
        -:   42:}
        -:   43:
        -:   44:// abbr = <.*?> | [^-+,\d]{3,}
function _ZN4cctz12_GLOBAL__N_19ParseAbbrEPKcPSs called 1608 returned 100% blocks executed 100%
     1608:   45:const char* ParseAbbr(const char* p, std::string* abbr) {
        -:   46:  const char* op = p;
     1608:   47:  if (*p == '<') {  // special zoneinfo <...> form
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
      328:   48:    while (*++p != '>') {
branch  0 taken 84%
branch  1 taken 16% (fallthrough)
      276:   49:      if (*p == '\0') return nullptr;
branch  0 taken 100%
branch  1 taken 0%
        -:   50:    }
       52:   51:    abbr->assign(op + 1, p - op - 1);
call    0 returned 100%
       52:   52:    return ++p;
        -:   53:  }
     6690:   54:  while (*p != '\0') {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
    13380:   55:    if (strchr("-+,", *p)) break;
branch  0 taken 85% (fallthrough)
branch  1 taken 15%
     5690:   56:    if (strchr(kDigits, *p)) break;
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
     5134:   57:    ++p;
        -:   58:  }
     1556:   59:  if (p - op < 3) return nullptr;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1556:   60:  abbr->assign(op, p - op);
call    0 returned 100%
     1556:   61:  return p;
        -:   62:}
        -:   63:
        -:   64:// offset = [+|-]hh[:mm[:ss]] (aggregated into single seconds value)
function _ZN4cctz12_GLOBAL__N_111ParseOffsetEPKciiiPi called 1504 returned 100% blocks executed 86%
     1504:   65:const char* ParseOffset(const char* p, int min_hour, int max_hour, int sign,
        -:   66:                        int* offset) {
     1504:   67:  if (p == nullptr) return nullptr;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1504:   68:  if (*p == '+' || *p == '-') {
branch  0 taken 39% (fallthrough)
branch  1 taken 61%
      592:   69:    if (*p++ == '-') sign = -sign;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   70:  }
     1504:   71:  int hours = 0;
     1504:   72:  int minutes = 0;
     1504:   73:  int seconds = 0;
     1504:   74:  p = ParseInt(p, min_hour, max_hour, &hours);
call    0 returned 100%
     1504:   75:  if (p == nullptr) return nullptr;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1504:   76:  if (*p == ':') {
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
       60:   77:    p = ParseInt(p + 1, 0, 59, &minutes);
call    0 returned 100%
       60:   78:    if (p == nullptr) return nullptr;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       60:   79:    if (*p == ':') {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   80:      p = ParseInt(p + 1, 0, 59, &seconds);
call    0 never executed
    #####:   81:      if (p == nullptr) return nullptr;
branch  0 never executed
branch  1 never executed
        -:   82:    }
        -:   83:  }
     1504:   84:  *offset = sign * ((((hours * 60) + minutes) * 60) + seconds);
     1504:   85:  return p;
        -:   86:}
        -:   87:
        -:   88:// datetime = ( Jn | n | Mm.w.d ) [ / offset ]
function _ZN4cctz12_GLOBAL__N_113ParseDateTimeEPKcPNS_15PosixTransitionE called 892 returned 100% blocks executed 81%
      892:   89:const char* ParseDateTime(const char* p, PosixTransition* res) {
      892:   90:  if (p != nullptr && *p == ',') {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
      892:   91:    if (*++p == 'M') {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
      884:   92:      int month = 0;
      884:   93:      if ((p = ParseInt(p + 1, 1, 12, &month)) != nullptr && *p == '.') {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
      884:   94:        int week = 0;
      884:   95:        if ((p = ParseInt(p + 1, 1, 5, &week)) != nullptr && *p == '.') {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
      884:   96:          int weekday = 0;
      884:   97:          if ((p = ParseInt(p + 1, 0, 6, &weekday)) != nullptr) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      884:   98:            res->date.fmt = PosixTransition::M;
      884:   99:            res->date.m.month = static_cast<int8_t>(month);
      884:  100:            res->date.m.week = static_cast<int8_t>(week);
      884:  101:            res->date.m.weekday = static_cast<int8_t>(weekday);
        -:  102:          }
        -:  103:        }
        -:  104:      }
        8:  105:    } else if (*p == 'J') {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        8:  106:      int day = 0;
        8:  107:      if ((p = ParseInt(p + 1, 1, 365, &day)) != nullptr) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        8:  108:        res->date.fmt = PosixTransition::J;
        8:  109:        res->date.j.day = static_cast<int16_t>(day);
        -:  110:      }
        -:  111:    } else {
    #####:  112:      int day = 0;
    #####:  113:      if ((p = ParseInt(p, 0, 365, &day)) != nullptr) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  114:        res->date.fmt = PosixTransition::N;
    #####:  115:        res->date.j.day = static_cast<int16_t>(day);
        -:  116:      }
        -:  117:    }
        -:  118:  }
      892:  119:  if (p != nullptr) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      892:  120:    res->time.offset = 2 * 60 * 60;  // default offset is 02:00:00
      892:  121:    if (*p == '/') p = ParseOffset(p + 1, -167, 167, 1, &res->time.offset);
branch  0 taken 38% (fallthrough)
branch  1 taken 62%
call    2 returned 100%
        -:  122:  }
      892:  123:  return p;
        -:  124:}
        -:  125:
        -:  126:}  // namespace
        -:  127:
        -:  128:// spec = std offset [ dst [ offset ] , datetime , datetime ]
function _ZN4cctz14ParsePosixSpecERKSsPNS_13PosixTimeZoneE called 1162 returned 100% blocks executed 94%
     1162:  129:bool ParsePosixSpec(const std::string& spec, PosixTimeZone* res) {
        -:  130:  const char* p = spec.c_str();
     1162:  131:  if (*p == ':') return false;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  132:
     1162:  133:  p = ParseAbbr(p, &res->std_abbr);
call    0 returned 100%
     1162:  134:  p = ParseOffset(p, 0, 24, -1, &res->std_offset);
call    0 returned 100%
     1162:  135:  if (p == nullptr) return false;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1162:  136:  if (*p == '\0') return true;
branch  0 taken 38% (fallthrough)
branch  1 taken 62%
        -:  137:
      446:  138:  p = ParseAbbr(p, &res->dst_abbr);
call    0 returned 100%
      446:  139:  if (p == nullptr) return false;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      446:  140:  res->dst_offset = res->std_offset + (60 * 60);  // default
      446:  141:  if (*p != ',') p = ParseOffset(p, 0, 24, -1, &res->dst_offset);
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
call    2 returned 100%
        -:  142:
      446:  143:  p = ParseDateTime(p, &res->dst_start);
call    0 returned 100%
      446:  144:  p = ParseDateTime(p, &res->dst_end);
call    0 returned 100%
        -:  145:
      446:  146:  return p != nullptr && *p == '\0';
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  147:}
        -:  148:
        -:  149:}  // namespace cctz
