        -:    0:Source:/usr/include/c++/4.9/streambuf
        -:    0:Graph:/home/yfy/iut/benchmarks/cctz/civil_time_test.gcno
        -:    0:Data:/home/yfy/iut/benchmarks/cctz/civil_time_test.gcda
        -:    0:Runs:22
        -:    0:Programs:1
        -:    1:// Stream buffer classes -*- C++ -*-
        -:    2:
        -:    3:// Copyright (C) 1997-2014 Free Software Foundation, Inc.
        -:    4://
        -:    5:// This file is part of the GNU ISO C++ Library.  This library is free
        -:    6:// software; you can redistribute it and/or modify it under the
        -:    7:// terms of the GNU General Public License as published by the
        -:    8:// Free Software Foundation; either version 3, or (at your option)
        -:    9:// any later version.
        -:   10:
        -:   11:// This library is distributed in the hope that it will be useful,
        -:   12:// but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   13:// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   14:// GNU General Public License for more details.
        -:   15:
        -:   16:// Under Section 7 of GPL version 3, you are granted additional
        -:   17:// permissions described in the GCC Runtime Library Exception, version
        -:   18:// 3.1, as published by the Free Software Foundation.
        -:   19:
        -:   20:// You should have received a copy of the GNU General Public License and
        -:   21:// a copy of the GCC Runtime Library Exception along with this program;
        -:   22:// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
        -:   23:// <http://www.gnu.org/licenses/>.
        -:   24:
        -:   25:/** @file include/streambuf
        -:   26: *  This is a Standard C++ Library header.
        -:   27: */
        -:   28:
        -:   29://
        -:   30:// ISO C++ 14882: 27.5  Stream buffers
        -:   31://
        -:   32:
        -:   33:#ifndef _GLIBXX_STREAMBUF
        -:   34:#define _GLIBXX_STREAMBUF 1
        -:   35:
        -:   36:#pragma GCC system_header
        -:   37:
        -:   38:#include <bits/c++config.h>
        -:   39:#include <iosfwd>
        -:   40:#include <bits/localefwd.h>
        -:   41:#include <bits/ios_base.h>
        -:   42:#include <bits/cpp_type_traits.h>
        -:   43:#include <ext/type_traits.h>
        -:   44:
        -:   45:namespace std _GLIBCXX_VISIBILITY(default)
        -:   46:{
        -:   47:_GLIBCXX_BEGIN_NAMESPACE_VERSION
        -:   48:
        -:   49:  template<typename _CharT, typename _Traits>
        -:   50:    streamsize
        -:   51:    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
        -:   52:			  basic_streambuf<_CharT, _Traits>*, bool&);
        -:   53:
        -:   54:  /**
        -:   55:   *  @brief  The actual work of input and output (interface).
        -:   56:   *  @ingroup io
        -:   57:   *
        -:   58:   *  @tparam _CharT  Type of character stream.
        -:   59:   *  @tparam _Traits  Traits for character type, defaults to
        -:   60:   *                   char_traits<_CharT>.
        -:   61:   *
        -:   62:   *  This is a base class.  Derived stream buffers each control a
        -:   63:   *  pair of character sequences:  one for input, and one for output.
        -:   64:   *
        -:   65:   *  Section [27.5.1] of the standard describes the requirements and
        -:   66:   *  behavior of stream buffer classes.  That section (three paragraphs)
        -:   67:   *  is reproduced here, for simplicity and accuracy.
        -:   68:   *
        -:   69:   *  -# Stream buffers can impose various constraints on the sequences
        -:   70:   *     they control.  Some constraints are:
        -:   71:   *     - The controlled input sequence can be not readable.
        -:   72:   *     - The controlled output sequence can be not writable.
        -:   73:   *     - The controlled sequences can be associated with the contents of
        -:   74:   *       other representations for character sequences, such as external
        -:   75:   *       files.
        -:   76:   *     - The controlled sequences can support operations @e directly to or
        -:   77:   *       from associated sequences.
        -:   78:   *     - The controlled sequences can impose limitations on how the
        -:   79:   *       program can read characters from a sequence, write characters to
        -:   80:   *       a sequence, put characters back into an input sequence, or alter
        -:   81:   *       the stream position.
        -:   82:   *     .
        -:   83:   *  -# Each sequence is characterized by three pointers which, if non-null,
        -:   84:   *     all point into the same @c charT array object.  The array object
        -:   85:   *     represents, at any moment, a (sub)sequence of characters from the
        -:   86:   *     sequence.  Operations performed on a sequence alter the values
        -:   87:   *     stored in these pointers, perform reads and writes directly to or
        -:   88:   *     from associated sequences, and alter <em>the stream position</em> and
        -:   89:   *     conversion state as needed to maintain this subsequence relationship.
        -:   90:   *     The three pointers are:
        -:   91:   *     - the <em>beginning pointer</em>, or lowest element address in the
        -:   92:   *       array (called @e xbeg here);
        -:   93:   *     - the <em>next pointer</em>, or next element address that is a
        -:   94:   *       current candidate for reading or writing (called @e xnext here);
        -:   95:   *     - the <em>end pointer</em>, or first element address beyond the
        -:   96:   *       end of the array (called @e xend here).
        -:   97:   *     .
        -:   98:   *  -# The following semantic constraints shall always apply for any set
        -:   99:   *     of three pointers for a sequence, using the pointer names given
        -:  100:   *     immediately above:
        -:  101:   *     - If @e xnext is not a null pointer, then @e xbeg and @e xend shall
        -:  102:   *       also be non-null pointers into the same @c charT array, as
        -:  103:   *       described above; otherwise, @e xbeg and @e xend shall also be null.
        -:  104:   *     - If @e xnext is not a null pointer and @e xnext < @e xend for an
        -:  105:   *       output sequence, then a <em>write position</em> is available.
        -:  106:   *       In this case, @e *xnext shall be assignable as the next element
        -:  107:   *       to write (to put, or to store a character value, into the sequence).
        -:  108:   *     - If @e xnext is not a null pointer and @e xbeg < @e xnext for an
        -:  109:   *       input sequence, then a <em>putback position</em> is available.
        -:  110:   *       In this case, @e xnext[-1] shall have a defined value and is the
        -:  111:   *       next (preceding) element to store a character that is put back
        -:  112:   *       into the input sequence.
        -:  113:   *     - If @e xnext is not a null pointer and @e xnext< @e xend for an
        -:  114:   *       input sequence, then a <em>read position</em> is available.
        -:  115:   *       In this case, @e *xnext shall have a defined value and is the
        -:  116:   *       next element to read (to get, or to obtain a character value,
        -:  117:   *       from the sequence).
        -:  118:  */
        -:  119:  template<typename _CharT, typename _Traits>
        -:  120:    class basic_streambuf 
        -:  121:    {
        -:  122:    public:
        -:  123:      //@{
        -:  124:      /**
        -:  125:       *  These are standard types.  They permit a standardized way of
        -:  126:       *  referring to names of (or names dependent on) the template
        -:  127:       *  parameters, which are specific to the implementation.
        -:  128:      */
        -:  129:      typedef _CharT 					char_type;
        -:  130:      typedef _Traits 					traits_type;
        -:  131:      typedef typename traits_type::int_type 		int_type;
        -:  132:      typedef typename traits_type::pos_type 		pos_type;
        -:  133:      typedef typename traits_type::off_type 		off_type;
        -:  134:      //@}
        -:  135:
        -:  136:      //@{
        -:  137:      /// This is a non-standard type.
        -:  138:      typedef basic_streambuf<char_type, traits_type>  	__streambuf_type;
        -:  139:      //@}
        -:  140:      
        -:  141:      friend class basic_ios<char_type, traits_type>;
        -:  142:      friend class basic_istream<char_type, traits_type>;
        -:  143:      friend class basic_ostream<char_type, traits_type>;
        -:  144:      friend class istreambuf_iterator<char_type, traits_type>;
        -:  145:      friend class ostreambuf_iterator<char_type, traits_type>;
        -:  146:
        -:  147:      friend streamsize
        -:  148:      __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);
        -:  149:
        -:  150:      template<bool _IsMove, typename _CharT2>
        -:  151:        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, 
        -:  152:					       _CharT2*>::__type
        -:  153:        __copy_move_a2(istreambuf_iterator<_CharT2>,
        -:  154:		       istreambuf_iterator<_CharT2>, _CharT2*);
        -:  155:
        -:  156:      template<typename _CharT2>
        -:  157:        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        -:  158:				  istreambuf_iterator<_CharT2> >::__type
        -:  159:        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
        -:  160:	     const _CharT2&);
        -:  161:
        -:  162:      template<typename _CharT2, typename _Traits2>
        -:  163:        friend basic_istream<_CharT2, _Traits2>&
        -:  164:        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);
        -:  165:
        -:  166:      template<typename _CharT2, typename _Traits2, typename _Alloc>
        -:  167:        friend basic_istream<_CharT2, _Traits2>&
        -:  168:        operator>>(basic_istream<_CharT2, _Traits2>&,
        -:  169:		   basic_string<_CharT2, _Traits2, _Alloc>&);
        -:  170:
        -:  171:      template<typename _CharT2, typename _Traits2, typename _Alloc>
        -:  172:        friend basic_istream<_CharT2, _Traits2>&
        -:  173:        getline(basic_istream<_CharT2, _Traits2>&,
        -:  174:		basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);
        -:  175:
        -:  176:    protected:
        -:  177:      /*
        -:  178:       *  This is based on _IO_FILE, just reordered to be more consistent,
        -:  179:       *  and is intended to be the most minimal abstraction for an
        -:  180:       *  internal buffer.
        -:  181:       *  -  get == input == read
        -:  182:       *  -  put == output == write
        -:  183:      */
        -:  184:      char_type* 		_M_in_beg;     ///< Start of get area.
        -:  185:      char_type* 		_M_in_cur;     ///< Current read area.
        -:  186:      char_type* 		_M_in_end;     ///< End of get area.
        -:  187:      char_type* 		_M_out_beg;    ///< Start of put area.
        -:  188:      char_type* 		_M_out_cur;    ///< Current put area.
        -:  189:      char_type* 		_M_out_end;    ///< End of put area.
        -:  190:
        -:  191:      /// Current locale setting.
        -:  192:      locale 			_M_buf_locale;	
        -:  193:
        -:  194:  public:
        -:  195:      /// Destructor deallocates no buffer space.
        -:  196:      virtual 
        -:  197:      ~basic_streambuf() 
      754:  198:      { }
call    0 returned 100%
        -:  199:
        -:  200:      // [27.5.2.2.1] locales
        -:  201:      /**
        -:  202:       *  @brief  Entry point for imbue().
        -:  203:       *  @param  __loc  The new locale.
        -:  204:       *  @return  The previous locale.
        -:  205:       *
        -:  206:       *  Calls the derived imbue(__loc).
        -:  207:      */
        -:  208:      locale 
        -:  209:      pubimbue(const locale& __loc)
        -:  210:      {
        -:  211:	locale __tmp(this->getloc());
        -:  212:	this->imbue(__loc);
        -:  213:	_M_buf_locale = __loc;
        -:  214:	return __tmp;
        -:  215:      }
        -:  216:
        -:  217:      /**
        -:  218:       *  @brief  Locale access.
        -:  219:       *  @return  The current locale in effect.
        -:  220:       *
        -:  221:       *  If pubimbue(loc) has been called, then the most recent @c loc
        -:  222:       *  is returned.  Otherwise the global locale in effect at the time
        -:  223:       *  of construction is returned.
        -:  224:      */
        -:  225:      locale   
        -:  226:      getloc() const
        -:  227:      { return _M_buf_locale; } 
        -:  228:
        -:  229:      // [27.5.2.2.2] buffer management and positioning
        -:  230:      //@{
        -:  231:      /**
        -:  232:       *  @brief  Entry points for derived buffer functions.
        -:  233:       *
        -:  234:       *  The public versions of @c pubfoo dispatch to the protected
        -:  235:       *  derived @c foo member functions, passing the arguments (if any)
        -:  236:       *  and returning the result unchanged.
        -:  237:      */
        -:  238:      basic_streambuf*
        -:  239:      pubsetbuf(char_type* __s, streamsize __n) 
        -:  240:      { return this->setbuf(__s, __n); }
        -:  241:
        -:  242:      /**
        -:  243:       *  @brief  Alters the stream position.
        -:  244:       *  @param  __off  Offset.
        -:  245:       *  @param  __way  Value for ios_base::seekdir.
        -:  246:       *  @param  __mode Value for ios_base::openmode.
        -:  247:       *
        -:  248:       *  Calls virtual seekoff function.
        -:  249:      */
        -:  250:      pos_type 
        -:  251:      pubseekoff(off_type __off, ios_base::seekdir __way, 
        -:  252:		 ios_base::openmode __mode = ios_base::in | ios_base::out)
        -:  253:      { return this->seekoff(__off, __way, __mode); }
        -:  254:
        -:  255:      /**
        -:  256:       *  @brief  Alters the stream position.
        -:  257:       *  @param  __sp  Position
        -:  258:       *  @param  __mode Value for ios_base::openmode.
        -:  259:       *
        -:  260:       *  Calls virtual seekpos function.
        -:  261:      */
        -:  262:      pos_type 
        -:  263:      pubseekpos(pos_type __sp,
        -:  264:		 ios_base::openmode __mode = ios_base::in | ios_base::out)
        -:  265:      { return this->seekpos(__sp, __mode); }
        -:  266:
        -:  267:      /**
        -:  268:       *  @brief  Calls virtual sync function.
        -:  269:      */
        -:  270:      int 
        -:  271:      pubsync() { return this->sync(); }
        -:  272:      //@}
        -:  273:
        -:  274:      // [27.5.2.2.3] get area
        -:  275:      /**
        -:  276:       *  @brief  Looking ahead into the stream.
        -:  277:       *  @return  The number of characters available.
        -:  278:       *
        -:  279:       *  If a read position is available, returns the number of characters
        -:  280:       *  available for reading before the buffer must be refilled.
        -:  281:       *  Otherwise returns the derived @c showmanyc().
        -:  282:      */
        -:  283:      streamsize 
        -:  284:      in_avail() 
        -:  285:      { 
        -:  286:	const streamsize __ret = this->egptr() - this->gptr();
        -:  287:	return __ret ? __ret : this->showmanyc();
        -:  288:      }
        -:  289:
        -:  290:      /**
        -:  291:       *  @brief  Getting the next character.
        -:  292:       *  @return  The next character, or eof.
        -:  293:       *
        -:  294:       *  Calls @c sbumpc(), and if that function returns
        -:  295:       *  @c traits::eof(), so does this function.  Otherwise, @c sgetc().
        -:  296:      */
        -:  297:      int_type 
        -:  298:      snextc()
        -:  299:      {
        -:  300:	int_type __ret = traits_type::eof();
        -:  301:	if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(), 
        -:  302:						       __ret), true))
        -:  303:	  __ret = this->sgetc();
        -:  304:	return __ret;
        -:  305:      }
        -:  306:
        -:  307:      /**
        -:  308:       *  @brief  Getting the next character.
        -:  309:       *  @return  The next character, or eof.
        -:  310:       *
        -:  311:       *  If the input read position is available, returns that character
        -:  312:       *  and increments the read pointer, otherwise calls and returns
        -:  313:       *  @c uflow().
        -:  314:      */
        -:  315:      int_type 
        -:  316:      sbumpc()
        -:  317:      {
        -:  318:	int_type __ret;
        -:  319:	if (__builtin_expect(this->gptr() < this->egptr(), true))
        -:  320:	  {
        -:  321:	    __ret = traits_type::to_int_type(*this->gptr());
        -:  322:	    this->gbump(1);
        -:  323:	  }
        -:  324:	else 
        -:  325:	  __ret = this->uflow();
        -:  326:	return __ret;
        -:  327:      }
        -:  328:
        -:  329:      /**
        -:  330:       *  @brief  Getting the next character.
        -:  331:       *  @return  The next character, or eof.
        -:  332:       *
        -:  333:       *  If the input read position is available, returns that character,
        -:  334:       *  otherwise calls and returns @c underflow().  Does not move the 
        -:  335:       *  read position after fetching the character.
        -:  336:      */
        -:  337:      int_type 
        -:  338:      sgetc()
        -:  339:      {
        -:  340:	int_type __ret;
        -:  341:	if (__builtin_expect(this->gptr() < this->egptr(), true))
        -:  342:	  __ret = traits_type::to_int_type(*this->gptr());
        -:  343:	else 
        -:  344:	  __ret = this->underflow();
        -:  345:	return __ret;
        -:  346:      }
        -:  347:
        -:  348:      /**
        -:  349:       *  @brief  Entry point for xsgetn.
        -:  350:       *  @param  __s  A buffer area.
        -:  351:       *  @param  __n  A count.
        -:  352:       *
        -:  353:       *  Returns xsgetn(__s,__n).  The effect is to fill @a __s[0] through
        -:  354:       *  @a __s[__n-1] with characters from the input sequence, if possible.
        -:  355:      */
        -:  356:      streamsize 
        -:  357:      sgetn(char_type* __s, streamsize __n)
        -:  358:      { return this->xsgetn(__s, __n); }
        -:  359:
        -:  360:      // [27.5.2.2.4] putback
        -:  361:      /**
        -:  362:       *  @brief  Pushing characters back into the input stream.
        -:  363:       *  @param  __c  The character to push back.
        -:  364:       *  @return  The previous character, if possible.
        -:  365:       *
        -:  366:       *  Similar to sungetc(), but @a __c is pushed onto the stream
        -:  367:       *  instead of <em>the previous character.</em> If successful,
        -:  368:       *  the next character fetched from the input stream will be @a
        -:  369:       *  __c.
        -:  370:      */
        -:  371:      int_type 
        -:  372:      sputbackc(char_type __c)
        -:  373:      {
        -:  374:	int_type __ret;
        -:  375:	const bool __testpos = this->eback() < this->gptr();
        -:  376:	if (__builtin_expect(!__testpos || 
        -:  377:			     !traits_type::eq(__c, this->gptr()[-1]), false))
        -:  378:	  __ret = this->pbackfail(traits_type::to_int_type(__c));
        -:  379:	else 
        -:  380:	  {
        -:  381:	    this->gbump(-1);
        -:  382:	    __ret = traits_type::to_int_type(*this->gptr());
        -:  383:	  }
        -:  384:	return __ret;
        -:  385:      }
        -:  386:
        -:  387:      /**
        -:  388:       *  @brief  Moving backwards in the input stream.
        -:  389:       *  @return  The previous character, if possible.
        -:  390:       *
        -:  391:       *  If a putback position is available, this function decrements
        -:  392:       *  the input pointer and returns that character.  Otherwise,
        -:  393:       *  calls and returns pbackfail().  The effect is to @a unget
        -:  394:       *  the last character @a gotten.
        -:  395:      */
        -:  396:      int_type 
        -:  397:      sungetc()
        -:  398:      {
        -:  399:	int_type __ret;
        -:  400:	if (__builtin_expect(this->eback() < this->gptr(), true))
        -:  401:	  {
        -:  402:	    this->gbump(-1);
        -:  403:	    __ret = traits_type::to_int_type(*this->gptr());
        -:  404:	  }
        -:  405:	else 
        -:  406:	  __ret = this->pbackfail();
        -:  407:	return __ret;
        -:  408:      }
        -:  409:
        -:  410:      // [27.5.2.2.5] put area
        -:  411:      /**
        -:  412:       *  @brief  Entry point for all single-character output functions.
        -:  413:       *  @param  __c  A character to output.
        -:  414:       *  @return  @a __c, if possible.
        -:  415:       *
        -:  416:       *  One of two public output functions.
        -:  417:       *
        -:  418:       *  If a write position is available for the output sequence (i.e.,
        -:  419:       *  the buffer is not full), stores @a __c in that position, increments
        -:  420:       *  the position, and returns @c traits::to_int_type(__c).  If a write
        -:  421:       *  position is not available, returns @c overflow(__c).
        -:  422:      */
        -:  423:      int_type 
        -:  424:      sputc(char_type __c)
        -:  425:      {
        -:  426:	int_type __ret;
        -:  427:	if (__builtin_expect(this->pptr() < this->epptr(), true))
        -:  428:	  {
        -:  429:	    *this->pptr() = __c;
        -:  430:	    this->pbump(1);
        -:  431:	    __ret = traits_type::to_int_type(__c);
        -:  432:	  }
        -:  433:	else
        -:  434:	  __ret = this->overflow(traits_type::to_int_type(__c));
        -:  435:	return __ret;
        -:  436:      }
        -:  437:
        -:  438:      /**
        -:  439:       *  @brief  Entry point for all single-character output functions.
        -:  440:       *  @param  __s  A buffer read area.
        -:  441:       *  @param  __n  A count.
        -:  442:       *
        -:  443:       *  One of two public output functions.
        -:  444:       *
        -:  445:       *
        -:  446:       *  Returns xsputn(__s,__n).  The effect is to write @a __s[0] through
        -:  447:       *  @a __s[__n-1] to the output sequence, if possible.
        -:  448:      */
        -:  449:      streamsize 
        -:  450:      sputn(const char_type* __s, streamsize __n)
        -:  451:      { return this->xsputn(__s, __n); }
        -:  452:
        -:  453:    protected:
        -:  454:      /**
        -:  455:       *  @brief  Base constructor.
        -:  456:       *
        -:  457:       *  Only called from derived constructors, and sets up all the
        -:  458:       *  buffer data to zero, including the pointers described in the
        -:  459:       *  basic_streambuf class description.  Note that, as a result,
        -:  460:       *  - the class starts with no read nor write positions available,
        -:  461:       *  - this is not an error
        -:  462:      */
        -:  463:      basic_streambuf()
        -:  464:      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0), 
        -:  465:      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
        -:  466:      _M_buf_locale(locale()) 
        -:  467:      { }
        -:  468:
        -:  469:      // [27.5.2.3.1] get area access
        -:  470:      //@{
        -:  471:      /**
        -:  472:       *  @brief  Access to the get area.
        -:  473:       *
        -:  474:       *  These functions are only available to other protected functions,
        -:  475:       *  including derived classes.
        -:  476:       *
        -:  477:       *  - eback() returns the beginning pointer for the input sequence
        -:  478:       *  - gptr() returns the next pointer for the input sequence
        -:  479:       *  - egptr() returns the end pointer for the input sequence
        -:  480:      */
        -:  481:      char_type* 
        -:  482:      eback() const { return _M_in_beg; }
        -:  483:
        -:  484:      char_type* 
        -:  485:      gptr()  const { return _M_in_cur;  }
        -:  486:
        -:  487:      char_type* 
        -:  488:      egptr() const { return _M_in_end; }
        -:  489:      //@}
        -:  490:
        -:  491:      /**
        -:  492:       *  @brief  Moving the read position.
        -:  493:       *  @param  __n  The delta by which to move.
        -:  494:       *
        -:  495:       *  This just advances the read position without returning any data.
        -:  496:      */
        -:  497:      void 
        -:  498:      gbump(int __n) { _M_in_cur += __n; }
        -:  499:
        -:  500:      /**
        -:  501:       *  @brief  Setting the three read area pointers.
        -:  502:       *  @param  __gbeg  A pointer.
        -:  503:       *  @param  __gnext  A pointer.
        -:  504:       *  @param  __gend  A pointer.
        -:  505:       *  @post  @a __gbeg == @c eback(), @a __gnext == @c gptr(), and
        -:  506:       *         @a __gend == @c egptr()
        -:  507:      */
        -:  508:      void 
        -:  509:      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
        -:  510:      {
        -:  511:	_M_in_beg = __gbeg;
        -:  512:	_M_in_cur = __gnext;
        -:  513:	_M_in_end = __gend;
        -:  514:      }
        -:  515:
        -:  516:      // [27.5.2.3.2] put area access
        -:  517:      //@{
        -:  518:      /**
        -:  519:       *  @brief  Access to the put area.
        -:  520:       *
        -:  521:       *  These functions are only available to other protected functions,
        -:  522:       *  including derived classes.
        -:  523:       *
        -:  524:       *  - pbase() returns the beginning pointer for the output sequence
        -:  525:       *  - pptr() returns the next pointer for the output sequence
        -:  526:       *  - epptr() returns the end pointer for the output sequence
        -:  527:      */
        -:  528:      char_type* 
        -:  529:      pbase() const { return _M_out_beg; }
        -:  530:
        -:  531:      char_type* 
        -:  532:      pptr() const { return _M_out_cur; }
        -:  533:
        -:  534:      char_type* 
        -:  535:      epptr() const { return _M_out_end; }
        -:  536:      //@}
        -:  537:
        -:  538:      /**
        -:  539:       *  @brief  Moving the write position.
        -:  540:       *  @param  __n  The delta by which to move.
        -:  541:       *
        -:  542:       *  This just advances the write position without returning any data.
        -:  543:      */
        -:  544:      void 
        -:  545:      pbump(int __n) { _M_out_cur += __n; }
        -:  546:
        -:  547:      /**
        -:  548:       *  @brief  Setting the three write area pointers.
        -:  549:       *  @param  __pbeg  A pointer.
        -:  550:       *  @param  __pend  A pointer.
        -:  551:       *  @post  @a __pbeg == @c pbase(), @a __pbeg == @c pptr(), and
        -:  552:       *         @a __pend == @c epptr()
        -:  553:      */
        -:  554:      void 
        -:  555:      setp(char_type* __pbeg, char_type* __pend)
        -:  556:      { 
        -:  557:	_M_out_beg = _M_out_cur = __pbeg; 
        -:  558:	_M_out_end = __pend;
        -:  559:      }
        -:  560:
        -:  561:      // [27.5.2.4] virtual functions
        -:  562:      // [27.5.2.4.1] locales
        -:  563:      /**
        -:  564:       *  @brief  Changes translations.
        -:  565:       *  @param  __loc  A new locale.
        -:  566:       *
        -:  567:       *  Translations done during I/O which depend on the current
        -:  568:       *  locale are changed by this call.  The standard adds,
        -:  569:       *  <em>Between invocations of this function a class derived
        -:  570:       *  from streambuf can safely cache results of calls to locale
        -:  571:       *  functions and to members of facets so obtained.</em>
        -:  572:       *
        -:  573:       *  @note  Base class version does nothing.
        -:  574:      */
        -:  575:      virtual void 
        -:  576:      imbue(const locale& __loc) 
        -:  577:      { }
        -:  578:
        -:  579:      // [27.5.2.4.2] buffer management and positioning
        -:  580:      /**
        -:  581:       *  @brief  Manipulates the buffer.
        -:  582:       *
        -:  583:       *  Each derived class provides its own appropriate behavior.  See
        -:  584:       *  the next-to-last paragraph of 
        -:  585:       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch25s02.html
        -:  586:       *  for more on this function.
        -:  587:       *
        -:  588:       *  @note  Base class version does nothing, returns @c this.
        -:  589:      */
        -:  590:      virtual basic_streambuf<char_type,_Traits>* 
        -:  591:      setbuf(char_type*, streamsize)
        -:  592:      {	return this; }
        -:  593:      
        -:  594:      /**
        -:  595:       *  @brief  Alters the stream positions.
        -:  596:       *
        -:  597:       *  Each derived class provides its own appropriate behavior.
        -:  598:       *  @note  Base class version does nothing, returns a @c pos_type
        -:  599:       *         that represents an invalid stream position.
        -:  600:      */
        -:  601:      virtual pos_type 
        -:  602:      seekoff(off_type, ios_base::seekdir,
        -:  603:	      ios_base::openmode /*__mode*/ = ios_base::in | ios_base::out)
        -:  604:      { return pos_type(off_type(-1)); } 
        -:  605:
        -:  606:      /**
        -:  607:       *  @brief  Alters the stream positions.
        -:  608:       *
        -:  609:       *  Each derived class provides its own appropriate behavior.
        -:  610:       *  @note  Base class version does nothing, returns a @c pos_type
        -:  611:       *         that represents an invalid stream position.
        -:  612:      */
        -:  613:      virtual pos_type 
        -:  614:      seekpos(pos_type, 
        -:  615:	      ios_base::openmode /*__mode*/ = ios_base::in | ios_base::out)
        -:  616:      { return pos_type(off_type(-1)); } 
        -:  617:
        -:  618:      /**
        -:  619:       *  @brief  Synchronizes the buffer arrays with the controlled sequences.
        -:  620:       *  @return  -1 on failure.
        -:  621:       *
        -:  622:       *  Each derived class provides its own appropriate behavior,
        -:  623:       *  including the definition of @a failure.
        -:  624:       *  @note  Base class version does nothing, returns zero.
        -:  625:      */
        -:  626:      virtual int 
        -:  627:      sync() { return 0; }
        -:  628:
        -:  629:      // [27.5.2.4.3] get area
        -:  630:      /**
        -:  631:       *  @brief  Investigating the data available.
        -:  632:       *  @return  An estimate of the number of characters available in the
        -:  633:       *           input sequence, or -1.
        -:  634:       *
        -:  635:       *  <em>If it returns a positive value, then successive calls to
        -:  636:       *  @c underflow() will not return @c traits::eof() until at
        -:  637:       *  least that number of characters have been supplied.  If @c
        -:  638:       *  showmanyc() returns -1, then calls to @c underflow() or @c
        -:  639:       *  uflow() will fail.</em> [27.5.2.4.3]/1
        -:  640:       *
        -:  641:       *  @note  Base class version does nothing, returns zero.
        -:  642:       *  @note  The standard adds that <em>the intention is not only that the
        -:  643:       *         calls [to underflow or uflow] will not return @c eof() but
        -:  644:       *         that they will return immediately.</em>
        -:  645:       *  @note  The standard adds that <em>the morphemes of @c showmanyc are
        -:  646:       *         @b es-how-many-see, not @b show-manic.</em>
        -:  647:      */
        -:  648:      virtual streamsize 
        -:  649:      showmanyc() { return 0; }
        -:  650:
        -:  651:      /**
        -:  652:       *  @brief  Multiple character extraction.
        -:  653:       *  @param  __s  A buffer area.
        -:  654:       *  @param  __n  Maximum number of characters to assign.
        -:  655:       *  @return  The number of characters assigned.
        -:  656:       *
        -:  657:       *  Fills @a __s[0] through @a __s[__n-1] with characters from the input
        -:  658:       *  sequence, as if by @c sbumpc().  Stops when either @a __n characters
        -:  659:       *  have been copied, or when @c traits::eof() would be copied.
        -:  660:       *
        -:  661:       *  It is expected that derived classes provide a more efficient
        -:  662:       *  implementation by overriding this definition.
        -:  663:      */
        -:  664:      virtual streamsize 
        -:  665:      xsgetn(char_type* __s, streamsize __n);
        -:  666:
        -:  667:      /**
        -:  668:       *  @brief  Fetches more data from the controlled sequence.
        -:  669:       *  @return  The first character from the <em>pending sequence</em>.
        -:  670:       *
        -:  671:       *  Informally, this function is called when the input buffer is
        -:  672:       *  exhausted (or does not exist, as buffering need not actually be
        -:  673:       *  done).  If a buffer exists, it is @a refilled.  In either case, the
        -:  674:       *  next available character is returned, or @c traits::eof() to
        -:  675:       *  indicate a null pending sequence.
        -:  676:       *
        -:  677:       *  For a formal definition of the pending sequence, see a good text
        -:  678:       *  such as Langer & Kreft, or [27.5.2.4.3]/7-14.
        -:  679:       *
        -:  680:       *  A functioning input streambuf can be created by overriding only
        -:  681:       *  this function (no buffer area will be used).  For an example, see
        -:  682:       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch25.html
        -:  683:       *
        -:  684:       *  @note  Base class version does nothing, returns eof().
        -:  685:      */
        -:  686:      virtual int_type 
        -:  687:      underflow()
        -:  688:      { return traits_type::eof(); }
        -:  689:
        -:  690:      /**
        -:  691:       *  @brief  Fetches more data from the controlled sequence.
        -:  692:       *  @return  The first character from the <em>pending sequence</em>.
        -:  693:       *
        -:  694:       *  Informally, this function does the same thing as @c underflow(),
        -:  695:       *  and in fact is required to call that function.  It also returns
        -:  696:       *  the new character, like @c underflow() does.  However, this
        -:  697:       *  function also moves the read position forward by one.
        -:  698:      */
        -:  699:      virtual int_type 
        -:  700:      uflow() 
        -:  701:      {
        -:  702:	int_type __ret = traits_type::eof();
        -:  703:	const bool __testeof = traits_type::eq_int_type(this->underflow(), 
        -:  704:							__ret);
        -:  705:	if (!__testeof)
        -:  706:	  {
        -:  707:	    __ret = traits_type::to_int_type(*this->gptr());
        -:  708:	    this->gbump(1);
        -:  709:	  }
        -:  710:	return __ret;    
        -:  711:      }
        -:  712:
        -:  713:      // [27.5.2.4.4] putback
        -:  714:      /**
        -:  715:       *  @brief  Tries to back up the input sequence.
        -:  716:       *  @param  __c  The character to be inserted back into the sequence.
        -:  717:       *  @return  eof() on failure, <em>some other value</em> on success
        -:  718:       *  @post  The constraints of @c gptr(), @c eback(), and @c pptr()
        -:  719:       *         are the same as for @c underflow().
        -:  720:       *
        -:  721:       *  @note  Base class version does nothing, returns eof().
        -:  722:      */
        -:  723:      virtual int_type 
        -:  724:      pbackfail(int_type __c  = traits_type::eof())
        -:  725:      { return traits_type::eof(); }
        -:  726:
        -:  727:      // Put area:
        -:  728:      /**
        -:  729:       *  @brief  Multiple character insertion.
        -:  730:       *  @param  __s  A buffer area.
        -:  731:       *  @param  __n  Maximum number of characters to write.
        -:  732:       *  @return  The number of characters written.
        -:  733:       *
        -:  734:       *  Writes @a __s[0] through @a __s[__n-1] to the output sequence, as if
        -:  735:       *  by @c sputc().  Stops when either @a n characters have been
        -:  736:       *  copied, or when @c sputc() would return @c traits::eof().
        -:  737:       *
        -:  738:       *  It is expected that derived classes provide a more efficient
        -:  739:       *  implementation by overriding this definition.
        -:  740:      */
        -:  741:      virtual streamsize 
        -:  742:      xsputn(const char_type* __s, streamsize __n);
        -:  743:
        -:  744:      /**
        -:  745:       *  @brief  Consumes data from the buffer; writes to the
        -:  746:       *          controlled sequence.
        -:  747:       *  @param  __c  An additional character to consume.
        -:  748:       *  @return  eof() to indicate failure, something else (usually
        -:  749:       *           @a __c, or not_eof())
        -:  750:       *
        -:  751:       *  Informally, this function is called when the output buffer
        -:  752:       *  is full (or does not exist, as buffering need not actually
        -:  753:       *  be done).  If a buffer exists, it is @a consumed, with
        -:  754:       *  <em>some effect</em> on the controlled sequence.
        -:  755:       *  (Typically, the buffer is written out to the sequence
        -:  756:       *  verbatim.)  In either case, the character @a c is also
        -:  757:       *  written out, if @a __c is not @c eof().
        -:  758:       *
        -:  759:       *  For a formal definition of this function, see a good text
        -:  760:       *  such as Langer & Kreft, or [27.5.2.4.5]/3-7.
        -:  761:       *
        -:  762:       *  A functioning output streambuf can be created by overriding only
        -:  763:       *  this function (no buffer area will be used).
        -:  764:       *
        -:  765:       *  @note  Base class version does nothing, returns eof().
        -:  766:      */
        -:  767:      virtual int_type 
        -:  768:      overflow(int_type __c  = traits_type::eof())
        -:  769:      { return traits_type::eof(); }
        -:  770:
        -:  771:#if _GLIBCXX_USE_DEPRECATED
        -:  772:    // Annex D.6
        -:  773:    public:
        -:  774:      /**
        -:  775:       *  @brief  Tosses a character.
        -:  776:       *
        -:  777:       *  Advances the read pointer, ignoring the character that would have
        -:  778:       *  been read.
        -:  779:       *
        -:  780:       *  See http://gcc.gnu.org/ml/libstdc++/2002-05/msg00168.html
        -:  781:       */
        -:  782:      void 
        -:  783:      stossc() 
        -:  784:      {
        -:  785:	if (this->gptr() < this->egptr()) 
        -:  786:	  this->gbump(1);
        -:  787:	else 
        -:  788:	  this->uflow();
        -:  789:      }
        -:  790:#endif
        -:  791:
        -:  792:      // Also used by specializations for char and wchar_t in src.
        -:  793:      void 
        -:  794:      __safe_gbump(streamsize __n) { _M_in_cur += __n; }
        -:  795:
        -:  796:      void
        -:  797:      __safe_pbump(streamsize __n) { _M_out_cur += __n; }
        -:  798:
        -:  799:    private:
        -:  800:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
        -:  801:      // Side effect of DR 50. 
        -:  802:      basic_streambuf(const basic_streambuf& __sb)
        -:  803:      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur), 
        -:  804:      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg), 
        -:  805:      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
        -:  806:      _M_buf_locale(__sb._M_buf_locale) 
        -:  807:      { }
        -:  808:
        -:  809:      basic_streambuf&
        -:  810:      operator=(const basic_streambuf&) { return *this; };
        -:  811:    };
        -:  812:
        -:  813:  // Explicit specialization declarations, defined in src/streambuf.cc.
        -:  814:  template<>
        -:  815:    streamsize
        -:  816:    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
        -:  817:			  basic_streambuf<char>* __sbout, bool& __ineof);
        -:  818:#ifdef _GLIBCXX_USE_WCHAR_T
        -:  819:  template<>
        -:  820:    streamsize
        -:  821:    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
        -:  822:			  basic_streambuf<wchar_t>* __sbout, bool& __ineof);
        -:  823:#endif
        -:  824:
        -:  825:_GLIBCXX_END_NAMESPACE_VERSION
        -:  826:} // namespace
        -:  827:
        -:  828:#include <bits/streambuf.tcc>
        -:  829:
        -:  830:#endif /* _GLIBCXX_STREAMBUF */
